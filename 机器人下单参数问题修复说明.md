# 机器人下单参数问题修复说明

## 问题描述

系统没有根据市场状态和风险偏好下单，机器人使用了固定参数，没有读取动态参数。

## 问题根源分析

### 1. 策略参数初始化问题

**问题：** `checkAndUpdateStrategyConfig()` 函数只在市场状态**变化**时才更新策略参数，导致首次初始化时可能不会更新。

**原代码逻辑：**
```go
if currentMarketState == "" || currentMarketState == e.LastMarketState {
    return  // 如果市场状态为空或与上次相同，直接返回，不更新策略参数
}
```

**问题场景：**
- 机器人启动时，`LastMarketState` 为空字符串 `""`
- 第一次市场分析时，如果 `currentMarketState` 也为空，就不会更新策略参数
- 或者如果第一次分析时 `currentMarketState` 有值，但后续市场状态不变，也不会更新
- 导致 `CurrentStrategyParams` 可能一直为 `nil`

### 2. executeOpen 中的降级逻辑问题

**问题：** 如果 `CurrentStrategyParams` 为 `nil`，会重新加载，但获取市场状态的逻辑不够完善。

**原代码逻辑：**
```go
if strategyParams == nil {
    marketState := t.engine.LastMarketState
    if marketState == "" {
        marketState = "trend" // 默认趋势市场
    }
    // ...
}
```

**问题场景：**
- 如果 `LastMarketState` 为空，直接使用默认值 "trend"
- 没有尝试从 `LastAnalysis.MarketState` 获取实际的市场状态
- 可能导致使用错误的参数

### 3. 日志信息不完整

**问题：** 下单时的日志没有记录风险偏好，无法验证是否正确使用了动态参数。

## 修复方案

### 修复1：允许首次初始化时更新策略参数

**文件：** `server/internal/logic/toogo/robot_engine.go`

**修改位置：** `checkAndUpdateStrategyConfig()` 函数（第429-477行）

**修改内容：**
```go
// 修改前：
if currentMarketState == "" || currentMarketState == e.LastMarketState {
    return
}

// 修改后：
// 如果市场状态为空，不更新
if currentMarketState == "" {
    return
}

// 检查是否需要更新：首次初始化（LastMarketState为空）或市场状态变化
e.mu.RLock()
needUpdate := e.LastMarketState == "" || currentMarketState != e.LastMarketState
e.mu.RUnlock()

if !needUpdate {
    return
}
```

**效果：**
- 首次初始化时（`LastMarketState` 为空），即使市场状态与上次相同，也会更新策略参数
- 确保策略参数一定会被初始化

### 修复2：完善 executeOpen 中的市场状态获取逻辑

**文件：** `server/internal/logic/toogo/robot_engine.go`

**修改位置：** `executeOpen()` 函数（第2413-2521行）

**修改内容：**
```go
// 修改前：
if strategyParams == nil {
    marketState := t.engine.LastMarketState
    if marketState == "" {
        marketState = "trend" // 默认趋势市场
    }
    // ...
}

// 修改后：
var strategyParams *StrategyParams
var marketState string
t.engine.mu.RLock()
strategyParams = t.engine.CurrentStrategyParams
marketState = t.engine.LastMarketState
// 如果 LastMarketState 为空，尝试从 LastAnalysis 获取
if marketState == "" && t.engine.LastAnalysis != nil {
    marketState = t.engine.LastAnalysis.MarketState
}
t.engine.mu.RUnlock()

if strategyParams == nil {
    if marketState == "" {
        marketState = "trend" // 默认趋势市场
        g.Log().Warningf(ctx, "[RobotTrader] robotId=%d 市场状态为空，使用默认值: trend", robot.Id)
    }
    // ... 重新加载策略参数
    // 缓存策略参数，避免下次重复加载
    t.engine.mu.Lock()
    t.engine.CurrentStrategyParams = strategyParams
    if t.engine.LastMarketState == "" {
        t.engine.LastMarketState = marketState
    }
    t.engine.mu.Unlock()
}
```

**效果：**
- 优先使用 `LastMarketState`
- 如果为空，尝试从 `LastAnalysis.MarketState` 获取
- 如果还是为空，才使用默认值 "trend"
- 重新加载后缓存策略参数，避免重复加载

### 修复3：增强日志信息

**文件：** `server/internal/logic/toogo/robot_engine.go`

**修改位置：** `executeOpen()` 函数中的日志输出

**修改内容：**
```go
// 修改前：
g.Log().Infof(ctx, "[RobotTrader] robotId=%d 下单参数: 市场=%s, 杠杆=%dx, 保证金=%.1f%%, 止损=%.1f%%, 可用余额=%.2f USDT",
    robot.Id, t.engine.LastMarketState, leverage, marginPercent,
    strategyParams.StopLossPercent, balance.AvailableBalance)

// 修改后：
// 获取当前市场状态用于日志（优先使用 LastMarketState）
currentMarketStateForLog := marketState
if currentMarketStateForLog == "" {
    t.engine.mu.RLock()
    if t.engine.LastAnalysis != nil {
        currentMarketStateForLog = t.engine.LastAnalysis.MarketState
    }
    if currentMarketStateForLog == "" {
        currentMarketStateForLog = t.engine.LastMarketState
    }
    t.engine.mu.RUnlock()
}
if currentMarketStateForLog == "" {
    currentMarketStateForLog = "未知"
}

g.Log().Infof(ctx, "[RobotTrader] robotId=%d 下单参数: 市场=%s, 风险偏好=%s, 杠杆=%dx, 保证金=%.1f%%, 止损=%.1f%%, 可用余额=%.2f USDT",
    robot.Id, currentMarketStateForLog, robot.RiskPreference, leverage, marginPercent,
    strategyParams.StopLossPercent, balance.AvailableBalance)
```

**效果：**
- 日志中增加了风险偏好信息
- 可以验证是否正确使用了动态参数

## 修复后的执行流程

### 1. 机器人启动时

```
启动 → doAnalysis() → Analyzer.Analyze() → 获取市场状态
  → checkAndUpdateStrategyConfig()
  → LastMarketState == "" → 允许更新
  → loadFullStrategyParams(marketState, riskPreference)
  → CurrentStrategyParams = strategyParams ✅
```

### 2. 下单时

```
executeOpen()
  → 检查 CurrentStrategyParams
  → 如果为 nil：
      → 获取 marketState（优先 LastMarketState，其次 LastAnalysis.MarketState）
      → 获取 riskPreference（从 Robot.RiskPreference）
      → loadFullStrategyParams(marketState, riskPreference)
      → 缓存到 CurrentStrategyParams ✅
  → 使用策略参数下单 ✅
```

## 验证方法

### 1. 查看日志

下单时应该能看到以下日志：

```
[RobotTrader] robotId=X 下单参数: 市场=trend, 风险偏好=balanced, 杠杆=10x, 保证金=12.5%, 止损=5.0%, 可用余额=100.00 USDT
```

或者如果策略参数未初始化：

```
[RobotTrader] robotId=X 策略参数未初始化，重新加载: market=trend, risk=balanced
[RobotEngine] robotId=X 从策略模板加载参数: market=trend(db=trend), risk=balanced, 窗口=90, 波动=12.0, 杠杆=10, 保证金=12.5%, ...
```

### 2. 检查策略模板

确保数据库中存在对应的策略模板：

```sql
SELECT * FROM hg_trading_strategy_template 
WHERE group_id = ? 
  AND market_state = ? 
  AND risk_preference = ? 
  AND is_active = 1;
```

### 3. 检查机器人配置

确保机器人配置了风险偏好：

```sql
SELECT id, robot_name, risk_preference, strategy_group_id 
FROM hg_trading_robot 
WHERE id = ?;
```

## 注意事项

1. **策略模板必须存在**：如果策略模板不存在，会使用默认参数（根据风险偏好）
2. **市场状态必须正确**：确保市场分析模块正常工作，能正确判断市场状态
3. **风险偏好必须配置**：机器人的 `risk_preference` 字段必须设置，否则会使用默认值 "balanced"

## 相关文件

- `server/internal/logic/toogo/robot_engine.go` - 机器人引擎核心逻辑
- `server/internal/logic/toogo/robot_engine.go:429-477` - `checkAndUpdateStrategyConfig()` 函数
- `server/internal/logic/toogo/robot_engine.go:2413-2521` - `executeOpen()` 函数
- `server/internal/logic/toogo/robot_engine.go:567-685` - `loadFullStrategyParams()` 函数

## 总结

修复后的系统会：
1. ✅ 在首次初始化时正确加载策略参数
2. ✅ 根据市场状态和风险偏好动态加载策略参数
3. ✅ 在下单时使用正确的动态参数
4. ✅ 提供详细的日志信息用于验证

如果问题仍然存在，请检查：
- 策略模板是否正确配置
- 市场状态是否正确分析
- 机器人的风险偏好是否正确设置

