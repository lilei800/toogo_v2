# 下单数量计算优化方案

## 一、当前公式分析

### 当前实现
```go
quantity = (可用余额 × 保证金比例% × 杠杆) / 当前价格
```

### 公式推导
```
保证金 = 可用余额 × 保证金比例% / 100
订单金额（名义价值）= 保证金 × 杠杆
下单数量 = 订单金额 / 当前价格
```

### 存在的问题

1. **缺少交易所规则校验**
   - 未考虑最小下单量（minQuantity）
   - 未考虑最大下单量（maxQuantity）
   - 未考虑数量精度（quantityPrecision/stepSize）
   - 未考虑价格精度（pricePrecision/tickSize）

2. **风险控制不足**
   - 未限制单笔订单最大金额
   - 未考虑账户最大持仓价值限制
   - 未考虑单币种持仓限制

3. **资金利用率问题**
   - 保证金比例应该控制实际使用的资金比例
   - 需要考虑已持仓占用的保证金

4. **精度处理不当**
   - 硬编码最小数量 0.0001，可能不符合交易所规则
   - 未对数量进行精度舍入

## 二、优化后的计算公式

### 核心公式（保持不变）
```go
// 步骤1：计算保证金
保证金 = 可用余额 × 保证金比例% / 100

// 步骤2：计算订单名义价值
订单名义价值 = 保证金 × 杠杆

// 步骤3：计算基础下单数量
基础数量 = 订单名义价值 / 当前价格
```

### 优化后的完整流程

```go
// 步骤1：计算基础数量
margin := availableBalance * marginPercent / 100
orderValue := margin * float64(leverage)
baseQuantity := orderValue / currentPrice

// 步骤2：获取交易所交易规则（从交易所API或缓存获取）
symbolInfo := exchange.GetSymbolInfo(symbol)
minQuantity := symbolInfo.MinQuantity      // 最小下单量，如 0.001
maxQuantity := symbolInfo.MaxQuantity      // 最大下单量，如 1000
quantityStep := symbolInfo.QuantityStep    // 数量精度，如 0.001
priceTick := symbolInfo.PriceTick          // 价格精度，如 0.01

// 步骤3：应用最小/最大数量限制
if baseQuantity < minQuantity {
    // 如果计算出的数量小于最小值，有两种处理方式：
    // 方式1：不满足最小下单量，取消本次下单
    if baseQuantity < minQuantity {
        return error("计算出的数量 %.6f 小于最小下单量 %.6f", baseQuantity, minQuantity)
    }
    // 方式2：使用最小下单量（但需要重新计算保证金）
    // baseQuantity = minQuantity
    // margin = baseQuantity * currentPrice / float64(leverage)
}

if baseQuantity > maxQuantity {
    baseQuantity = maxQuantity
    // 重新计算实际使用的保证金
    margin = baseQuantity * currentPrice / float64(leverage)
}

// 步骤4：应用数量精度（向下取整到精度）
quantity := math.Floor(baseQuantity/quantityStep) * quantityStep

// 步骤5：风险控制校验
// 5.1 单笔订单最大金额限制（如不超过账户权益的50%）
maxOrderValue := totalBalance * 0.5
actualOrderValue := quantity * currentPrice
if actualOrderValue > maxOrderValue {
    // 重新计算数量
    quantity = math.Floor((maxOrderValue/currentPrice)/quantityStep) * quantityStep
    // 重新计算保证金
    margin = quantity * currentPrice / float64(leverage)
}

// 5.2 账户最大持仓价值限制
currentPositionValue := getCurrentPositionValue() // 当前持仓的名义价值
maxPositionValue := totalBalance * maxPositionRatio // 如账户权益的10倍
if currentPositionValue + actualOrderValue > maxPositionValue {
    // 调整数量
    availablePositionValue := maxPositionValue - currentPositionValue
    quantity = math.Floor((availablePositionValue/currentPrice)/quantityStep) * quantityStep
    margin = quantity * currentPrice / float64(leverage)
}

// 5.3 单币种持仓限制（如不超过该币种总持仓的30%）
symbolPositionValue := getSymbolPositionValue(symbol)
maxSymbolPositionValue := totalBalance * symbolPositionRatio
if symbolPositionValue + actualOrderValue > maxSymbolPositionValue {
    availableSymbolValue := maxSymbolPositionValue - symbolPositionValue
    quantity = math.Floor((availableSymbolValue/currentPrice)/quantityStep) * quantityStep
    margin = quantity * currentPrice / float64(leverage)
}

// 步骤6：最终校验
// 6.1 确保数量大于0
if quantity <= 0 {
    return error("计算出的数量无效: %.6f", quantity)
}

// 6.2 确保保证金不超过可用余额
if margin > availableBalance {
    // 调整保证金到可用余额
    margin = availableBalance
    // 重新计算数量
    quantity = math.Floor((margin*float64(leverage)/currentPrice)/quantityStep) * quantityStep
}

// 6.3 确保订单价值合理（考虑滑点，预留5%缓冲）
estimatedOrderValue := quantity * currentPrice
if estimatedOrderValue > orderValue * 1.05 {
    // 如果实际订单价值超过预期5%，需要调整
    quantity = math.Floor((orderValue*0.95/currentPrice)/quantityStep) * quantityStep
    margin = quantity * currentPrice / float64(leverage)
}
```

## 三、推荐的计算公式

### 简化版（推荐用于生产环境）

```go
func CalculateOrderQuantity(
    availableBalance float64,  // 可用余额
    marginPercent float64,     // 保证金比例（如 10 表示 10%）
    leverage int,               // 杠杆倍数
    currentPrice float64,       // 当前价格
    symbolInfo SymbolInfo,      // 交易对信息
    riskLimits RiskLimits,      // 风险限制
) (quantity float64, margin float64, err error) {
    
    // 1. 计算基础数量
    margin = availableBalance * marginPercent / 100
    orderValue := margin * float64(leverage)
    baseQuantity := orderValue / currentPrice
    
    // 2. 应用交易所规则
    if baseQuantity < symbolInfo.MinQuantity {
        return 0, 0, fmt.Errorf("数量 %.6f 小于最小下单量 %.6f", baseQuantity, symbolInfo.MinQuantity)
    }
    
    if baseQuantity > symbolInfo.MaxQuantity {
        baseQuantity = symbolInfo.MaxQuantity
    }
    
    // 3. 精度处理（向下取整）
    quantity = math.Floor(baseQuantity/symbolInfo.QuantityStep) * symbolInfo.QuantityStep
    
    // 4. 重新计算实际保证金（因为数量可能被调整）
    actualOrderValue := quantity * currentPrice
    margin = actualOrderValue / float64(leverage)
    
    // 5. 风险控制
    // 单笔订单不超过账户权益的50%
    if actualOrderValue > riskLimits.MaxOrderValueRatio * riskLimits.TotalBalance {
        maxOrderValue := riskLimits.MaxOrderValueRatio * riskLimits.TotalBalance
        quantity = math.Floor((maxOrderValue/currentPrice)/symbolInfo.QuantityStep) * symbolInfo.QuantityStep
        margin = quantity * currentPrice / float64(leverage)
    }
    
    // 6. 最终校验
    if quantity <= 0 {
        return 0, 0, fmt.Errorf("计算出的数量无效: %.6f", quantity)
    }
    
    if margin > availableBalance {
        margin = availableBalance
        quantity = math.Floor((margin*float64(leverage)/currentPrice)/symbolInfo.QuantityStep) * symbolInfo.QuantityStep
    }
    
    return quantity, margin, nil
}
```

## 四、关键改进点

### 1. 交易所规则集成
- ✅ 从交易所API获取交易对信息（最小/最大数量、精度）
- ✅ 动态适配不同交易所的规则
- ✅ 避免硬编码

### 2. 精度处理
- ✅ 数量向下取整到交易所要求的精度
- ✅ 价格精度处理（虽然当前是市价单，但记录时需要考虑）

### 3. 风险控制
- ✅ 单笔订单金额限制
- ✅ 账户最大持仓价值限制
- ✅ 单币种持仓限制
- ✅ 保证金不超过可用余额

### 4. 资金管理
- ✅ 保证金比例控制实际使用的资金
- ✅ 考虑已持仓占用的保证金
- ✅ 预留缓冲空间（如5%）应对滑点

## 五、实施建议

### 优先级1（必须）
1. 集成交易所交易规则API
2. 实现数量精度处理
3. 添加最小/最大数量校验

### 优先级2（重要）
1. 添加单笔订单金额限制
2. 添加账户最大持仓价值限制
3. 优化保证金计算逻辑

### 优先级3（可选）
1. 添加单币种持仓限制
2. 添加滑点缓冲处理
3. 添加更细粒度的风险控制

## 六、示例代码

```go
// SymbolInfo 交易对信息
type SymbolInfo struct {
    Symbol          string  // 交易对，如 BTCUSDT
    MinQuantity     float64 // 最小下单量，如 0.001
    MaxQuantity     float64 // 最大下单量，如 1000
    QuantityStep    float64 // 数量精度，如 0.001
    MinPrice        float64 // 最小价格
    MaxPrice        float64 // 最大价格
    PriceTick       float64 // 价格精度，如 0.01
}

// RiskLimits 风险限制
type RiskLimits struct {
    TotalBalance           float64 // 账户总权益
    MaxOrderValueRatio     float64 // 单笔订单最大金额比例，如 0.5（50%）
    MaxPositionValueRatio  float64 // 最大持仓价值比例，如 10（10倍）
    SymbolPositionRatio    float64 // 单币种持仓比例，如 0.3（30%）
}
```

## 七、总结

**当前公式的核心逻辑是正确的**，但需要增加以下改进：

1. ✅ **交易所规则校验**：最小/最大数量、精度处理
2. ✅ **风险控制**：单笔订单限制、持仓限制
3. ✅ **资金管理**：保证金校验、可用余额校验
4. ✅ **精度处理**：数量向下取整、避免精度误差

**推荐的计算流程**：
```
基础数量计算 → 交易所规则校验 → 精度处理 → 风险控制 → 最终校验
```

这样既能保证资金利用率，又能确保交易安全和合规。










