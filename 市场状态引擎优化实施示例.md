# 市场状态引擎优化实施示例

## 快速开始：最小化改动方案

### 步骤1：创建配置管理器（新增文件）

创建文件：`server/internal/library/market/config_manager.go`

```go
package market

import (
    "context"
    "sync"
    "hotgo/internal/service"
    "github.com/gogf/gf/v2/frame/g"
)

// VolatilityConfig 波动率配置（与 robot_engine.go 中的结构保持一致）
type VolatilityConfig struct {
    HighVolatilityThreshold float64
    LowVolatilityThreshold  float64
    TrendStrengthThreshold  float64
    Weight1m                float64
    Weight5m                float64
    Weight15m               float64
    Weight30m               float64
    Weight1h                float64
    Symbol                  string
}

// VolatilityConfigManager 波动率配置管理器
type VolatilityConfigManager struct {
    cache sync.Map // key: symbol, value: *VolatilityConfig
}

var (
    globalConfigManager *VolatilityConfigManager
    configManagerOnce   sync.Once
)

// GetVolatilityConfigManager 获取全局配置管理器单例
func GetVolatilityConfigManager() *VolatilityConfigManager {
    configManagerOnce.Do(func() {
        globalConfigManager = &VolatilityConfigManager{}
    })
    return globalConfigManager
}

// GetConfig 获取币种的波动率配置
func (m *VolatilityConfigManager) GetConfig(symbol string) *VolatilityConfig {
    // 1. 先从缓存获取
    if val, ok := m.cache.Load(symbol); ok {
        return val.(*VolatilityConfig)
    }
    
    // 2. 从数据库加载
    ctx := context.Background()
    dbConfig, err := service.ToogoVolatilityConfig().GetBySymbol(ctx, symbol)
    if err == nil && dbConfig != nil {
        config := &VolatilityConfig{
            HighVolatilityThreshold: dbConfig.HighVolatilityThreshold,
            LowVolatilityThreshold:  dbConfig.LowVolatilityThreshold,
            TrendStrengthThreshold:  dbConfig.TrendStrengthThreshold,
            Weight1m:                dbConfig.Weight1m,
            Weight5m:                dbConfig.Weight5m,
            Weight15m:               dbConfig.Weight15m,
            Weight30m:               dbConfig.Weight30m,
            Weight1h:                dbConfig.Weight1h,
            Symbol:                  symbol,
        }
        
        // 验证权重总和，如果不为1则归一化
        totalWeight := config.Weight1m + config.Weight5m + config.Weight15m + 
                      config.Weight30m + config.Weight1h
        if totalWeight > 0 && (totalWeight < 0.9 || totalWeight > 1.1) {
            config.Weight1m /= totalWeight
            config.Weight5m /= totalWeight
            config.Weight15m /= totalWeight
            config.Weight30m /= totalWeight
            config.Weight1h /= totalWeight
        }
        
        // 缓存配置
        m.cache.Store(symbol, config)
        return config
    }
    
    // 3. 使用默认配置
    defaultConfig := m.getDefaultConfig()
    m.cache.Store(symbol, defaultConfig)
    return defaultConfig
}

// ReloadConfig 重新加载配置（配置更新时调用）
func (m *VolatilityConfigManager) ReloadConfig(symbol string) {
    m.cache.Delete(symbol)
    m.GetConfig(symbol) // 重新加载
}

// getDefaultConfig 获取默认配置
func (m *VolatilityConfigManager) getDefaultConfig() *VolatilityConfig {
    return &VolatilityConfig{
        HighVolatilityThreshold: 2.0,
        LowVolatilityThreshold:  0.5,
        TrendStrengthThreshold:  0.35,
        Weight1m:                0.10,
        Weight5m:                0.15,
        Weight15m:               0.25,
        Weight30m:               0.25,
        Weight1h:                0.25,
        Symbol:                  "default",
    }
}
```

### 步骤2：修改 MarketAnalyzer（最小改动）

修改文件：`server/internal/library/market/market_analyzer.go`

#### 2.1 在 analyzeMarket 方法中获取配置

```go
// analyzeMarket 分析单个市场（精简版）
func (a *MarketAnalyzer) analyzeMarket(ctx context.Context, platform, symbol string, ticker *exchange.Ticker, klineCache *KlineCache, previousAnalysis *MarketAnalysis) *MarketAnalysis {
    analysis := &MarketAnalysis{
        Platform:          platform,
        Symbol:            symbol,
        UpdatedAt:         time.Now(),
        CurrentPrice:      ticker.LastPrice,
        TimeframeAnalysis: make(map[string]*TimeframeResult),
    }

    // 【优化】获取币种特定的波动率配置
    config := GetVolatilityConfigManager().GetConfig(symbol)

    // 【优化】使用配置的权重替换硬编码权重
    timeframes := a.getTimeframesWithConfig(klineCache, config)
    
    // ... 后续代码保持不变，但使用 timeframes 变量
}
```

#### 2.2 新增 getTimeframesWithConfig 方法

```go
// getTimeframesWithConfig 根据配置获取时间周期配置
func (a *MarketAnalyzer) getTimeframesWithConfig(klineCache *KlineCache, config *VolatilityConfig) []struct {
    interval  string
    klines    []*exchange.Kline
    weight    float64
    minKlines int
    maxKlines int
} {
    // 使用配置的权重
    weights := map[string]float64{
        "1m":  config.Weight1m,
        "5m":  config.Weight5m,
        "15m": config.Weight15m,
        "30m": config.Weight30m,
        "1h":  config.Weight1h,
    }
    
    // 如果配置权重为0，使用默认权重
    if weights["1m"] == 0 && weights["5m"] == 0 {
        weights = map[string]float64{
            "1m":  0.30,
            "5m":  0.40,
            "15m": 0.20,
            "30m": 0.07,
            "1h":  0.03,
        }
    }
    
    return []struct {
        interval  string
        klines    []*exchange.Kline
        weight    float64
        minKlines int
        maxKlines int
    }{
        {"1m", klineCache.Klines1m, weights["1m"], 8, 15},
        {"5m", klineCache.Klines5m, weights["5m"], 20, 30},
        {"15m", klineCache.Klines15m, weights["15m"], 12, 20},
        {"30m", klineCache.Klines30m, weights["30m"], 6, 10},
        {"1h", klineCache.Klines1h, weights["1h"], 5, 8},
    }
}
```

#### 2.3 修改 calculateDynamicThresholdsFromMarketStates 方法

```go
// calculateDynamicThresholdsFromMarketStates 根据历史K线识别的市场状态波动率特征值计算动态阈值
func (a *MarketAnalyzer) calculateDynamicThresholdsFromMarketStates(
    baselineVolatility float64, 
    marketStateVolatilities *MarketStateVolatilities,
    config *VolatilityConfig) (highThreshold, lowThreshold float64) {
    
    if marketStateVolatilities == nil {
        // 降级：使用原来的方法，但传入配置
        return a.calculateDynamicThresholds(baselineVolatility, config)
    }

    // 【优化】优先使用配置的阈值作为基准
    var baseHigh, baseLow float64
    if config != nil && config.HighVolatilityThreshold > 0 {
        baseHigh = config.HighVolatilityThreshold
        baseLow = config.LowVolatilityThreshold
    } else {
        // 降级：使用历史基准波动率
        baseHigh = baselineVolatility * 1.5
        baseLow = baselineVolatility * 0.5
    }

    // 【优化】根据历史市场状态模式调整
    highVolCandidates := []float64{
        marketStateVolatilities.HighVolVolatility,
        marketStateVolatilities.SpikeVolatility,
        marketStateVolatilities.TrendUpVolatility,
        marketStateVolatilities.TrendDownVolatility,
    }
    
    maxHighVol := 0.0
    for _, v := range highVolCandidates {
        if v > maxHighVol {
            maxHighVol = v
        }
    }
    
    if maxHighVol > 0 {
        // 综合配置基准和历史模式：70%配置 + 30%历史模式
        highThreshold = baseHigh*0.7 + maxHighVol*0.3
    } else {
        highThreshold = baseHigh
    }
    
    // 低波动阈值
    var lowThresholdFromPattern float64
    if marketStateVolatilities.LowVolVolatility > 0 {
        lowThresholdFromPattern = marketStateVolatilities.LowVolVolatility * 1.5
    } else if marketStateVolatilities.VolatileVolatility > 0 {
        lowThresholdFromPattern = marketStateVolatilities.VolatileVolatility * 0.8
    }
    
    if lowThresholdFromPattern > 0 {
        // 综合配置基准和历史模式：70%配置 + 30%历史模式
        lowThreshold = baseLow*0.7 + lowThresholdFromPattern*0.3
    } else {
        lowThreshold = baseLow
    }
    
    // 【优化】币种特定校准
    highThreshold, lowThreshold = a.adjustThresholdsBySymbol(config.Symbol, highThreshold, lowThreshold)
    
    // 确保阈值在合理范围内
    if baselineVolatility > 0 {
        highThreshold = math.Max(baselineVolatility*1.2, math.Min(baselineVolatility*3.0, highThreshold))
        lowThreshold = math.Max(baselineVolatility*0.2, math.Min(baselineVolatility*0.8, lowThreshold))
    }
    
    highThreshold = math.Max(0.6, math.Min(10.0, highThreshold))
    lowThreshold = math.Max(0.1, math.Min(2.0, lowThreshold))
    
    return highThreshold, lowThreshold
}
```

#### 2.4 新增 adjustThresholdsBySymbol 方法

```go
// adjustThresholdsBySymbol 根据币种特性调整阈值
func (a *MarketAnalyzer) adjustThresholdsBySymbol(
    symbol string, high, low float64) (adjustedHigh, adjustedLow float64) {
    
    // BTC/ETH 等主流币：波动率相对稳定
    if contains(symbol, "BTC") || contains(symbol, "ETH") {
        adjustedHigh = math.Max(0.8, math.Min(2.0, high))
        adjustedLow = math.Max(0.2, math.Min(0.5, low))
        return adjustedHigh, adjustedLow
    }
    
    // USDT 稳定币对：波动率通常较低
    if contains(symbol, "USDT") {
        adjustedHigh = math.Max(0.6, math.Min(1.5, high))
        adjustedLow = math.Max(0.1, math.Min(0.4, low))
        return adjustedHigh, adjustedLow
    }
    
    // 山寨币：波动率通常较高
    adjustedHigh = math.Max(1.5, math.Min(5.0, high))
    adjustedLow = math.Max(0.3, math.Min(1.0, low))
    
    return adjustedHigh, adjustedLow
}

func contains(s, substr string) bool {
    return len(s) >= len(substr) && (s == substr || 
        (len(s) > len(substr) && (s[:len(substr)] == substr || 
         s[len(s)-len(substr):] == substr || 
         indexOf(s, substr) >= 0)))
}

func indexOf(s, substr string) int {
    for i := 0; i <= len(s)-len(substr); i++ {
        if s[i:i+len(substr)] == substr {
            return i
        }
    }
    return -1
}
```

#### 2.5 修改 calculateDynamicThresholds 方法签名

```go
// calculateDynamicThresholds 计算动态阈值（基于基准波动率）
func (a *MarketAnalyzer) calculateDynamicThresholds(
    baselineVolatility float64,
    config *VolatilityConfig) (highThreshold, lowThreshold float64) {
    
    // 【优化】优先使用配置的阈值
    if config != nil && config.HighVolatilityThreshold > 0 {
        baseHigh := config.HighVolatilityThreshold
        baseLow := config.LowVolatilityThreshold
        
        // 根据基准波动率微调
        volatilityRatio := baselineVolatility / ((baseHigh + baseLow) / 2)
        if volatilityRatio > 1.2 {
            baseHigh *= 1.1
            baseLow *= 1.05
        } else if volatilityRatio < 0.8 {
            baseHigh *= 0.95
            baseLow *= 0.9
        }
        
        highThreshold, lowThreshold = a.adjustThresholdsBySymbol(
            config.Symbol, baseHigh, baseLow)
        return
    }
    
    // 降级：原有逻辑
    if baselineVolatility <= 0 || baselineVolatility > 30.0 {
        baselineVolatility = 0.8
    }
    
    var highMultiplier, lowMultiplier float64
    if baselineVolatility < 0.5 {
        highMultiplier = 2.0
        lowMultiplier = 0.4
    } else if baselineVolatility > 2.0 {
        highMultiplier = 1.2
        lowMultiplier = 0.6
    } else {
        highMultiplier = 1.5
        lowMultiplier = 0.5
    }
    
    highThreshold = baselineVolatility * highMultiplier
    lowThreshold = baselineVolatility * lowMultiplier
    
    highThreshold = math.Max(0.6, math.Min(10.0, highThreshold))
    lowThreshold = math.Max(0.2, math.Min(2.0, lowThreshold))
    
    return highThreshold, lowThreshold
}
```

#### 2.6 修改 determineMarketState 方法调用

```go
func (a *MarketAnalyzer) determineMarketState(
    analysis *MarketAnalysis, 
    baselineVolatility float64, 
    previousAnalysis *MarketAnalysis, 
    marketStateVolatilities *MarketStateVolatilities,
    config *VolatilityConfig) (MarketState, float64) {
    
    // 【优化】传入配置参数
    highVolThreshold, lowVolThreshold := a.calculateDynamicThresholdsFromMarketStates(
        baselineVolatility, marketStateVolatilities, config)
    
    // ... 后续代码保持不变
}
```

#### 2.7 修改 analyzeMarket 方法中调用 determineMarketState

```go
// 在 analyzeMarket 方法中
analysis.MarketState, analysis.MarketStateConf = a.determineMarketState(
    analysis, baselineVolatility, previousAnalysis, marketStateVolatilities, config)
```

### 步骤3：配置更新时刷新缓存

修改文件：`server/internal/logic/toogo/volatility_config.go`

在配置更新时，通知 MarketAnalyzer 刷新缓存：

```go
func (s *sToogoVolatilityConfig) Edit(ctx context.Context, in *toogoin.VolatilityConfigEditInp) error {
    // ... 原有更新逻辑 ...
    
    // 【新增】通知 MarketAnalyzer 刷新配置缓存
    if in.Symbol != nil && *in.Symbol != "" {
        market.GetVolatilityConfigManager().ReloadConfig(*in.Symbol)
    } else {
        // 全局配置更新，清除所有缓存
        market.GetVolatilityConfigManager().ReloadAll()
    }
    
    return nil
}
```

### 步骤4：测试验证

创建测试文件：`server/internal/library/market/config_manager_test.go`

```go
package market

import (
    "testing"
)

func TestVolatilityConfigManager(t *testing.T) {
    manager := GetVolatilityConfigManager()
    
    // 测试获取默认配置
    config := manager.GetConfig("TESTUSDT")
    if config == nil {
        t.Fatal("配置不应为nil")
    }
    
    // 测试权重归一化
    totalWeight := config.Weight1m + config.Weight5m + config.Weight15m + 
                  config.Weight30m + config.Weight1h
    if totalWeight < 0.99 || totalWeight > 1.01 {
        t.Errorf("权重总和应为1，实际为%.2f", totalWeight)
    }
}
```

---

## 实施检查清单

- [ ] 创建 `config_manager.go` 文件
- [ ] 修改 `market_analyzer.go` 中的 `analyzeMarket` 方法
- [ ] 新增 `getTimeframesWithConfig` 方法
- [ ] 修改 `calculateDynamicThresholdsFromMarketStates` 方法
- [ ] 新增 `adjustThresholdsBySymbol` 方法
- [ ] 修改 `calculateDynamicThresholds` 方法
- [ ] 修改 `determineMarketState` 方法调用
- [ ] 在配置更新时刷新缓存
- [ ] 编写单元测试
- [ ] 测试不同币种的配置生效
- [ ] 性能测试
- [ ] 对比优化前后的精准度

---

## 注意事项

1. **向后兼容**：确保没有配置时使用默认值，不影响现有功能
2. **性能考虑**：配置缓存使用 sync.Map，并发安全
3. **配置验证**：权重总和不为1时自动归一化
4. **币种识别**：简单的字符串匹配，可根据需要优化

---

## 预期效果

实施后，用户配置的阈值和权重将直接生效：
- ✅ 阈值配置作为基准值，在此基础上动态调整
- ✅ 权重配置替换硬编码权重
- ✅ 不同币种使用不同的阈值范围
- ✅ 配置更新后自动刷新缓存

