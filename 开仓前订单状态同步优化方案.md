# 开仓前订单状态同步优化方案

## 问题分析

**用户反馈**：如果不是实时同步订单及状态，有做多做空信号根本下不了单。

**根本原因**：
1. 开仓前需要检查是否有持仓（`HasActivePosition`）
2. 如果订单状态不同步，可能误判为有持仓，导致无法下单
3. 或者误判为无持仓，导致重复开仓

## 当前实现分析

### 1. 开仓前检查逻辑

**位置**：`robot_engine.go` 的 `checkTradingConditions()` 方法（2462-2495行）

```go
func (t *RobotTrader) checkTradingConditions(ctx context.Context, signal *RobotSignal) (bool, string) {
    // ...
    hasCurrentPosition := t.engine.HasActivePosition(positionSide)
    if hasCurrentPosition {
        return false, "该方向已有持仓"
    }
    // ...
}
```

**问题**：
- ⚠️ `checkTradingConditions()` 中**没有强制同步订单状态**
- ⚠️ 依赖内存中的 `CurrentPositions`，可能不准确

### 2. 另一个开仓路径

**位置**：`CheckAndOpenPositionWithSignal()` 方法（2534行）

```go
// 【全面方案】开仓前强制同步，确保准确性
t.engine.syncAccountDataIfNeeded(ctx, "before_open")
hasCurrentPosition := t.engine.HasActivePosition(positionSide)
```

**优点**：
- ✅ 有强制同步（`before_open`）
- ✅ 确保准确性

**问题**：
- ⚠️ `TryAutoTradeAndUpdate()` 调用的是 `checkTradingConditions()`，不是 `CheckAndOpenPositionWithSignal()`
- ⚠️ 两个路径不一致

### 3. HasActivePosition 实现

**位置**：`robot_engine.go` 的 `HasActivePosition()` 方法（1900行）

```go
func (e *RobotEngine) HasActivePosition(side string) bool {
    e.mu.RLock()
    defer e.mu.RUnlock()
    
    if e.CurrentPositions == nil {
        return false
    }
    
    for _, pos := range e.CurrentPositions {
        if pos.PositionSide == side && math.Abs(pos.PositionAmt) > 0.0001 {
            return true
        }
    }
    return false
}
```

**问题**：
- ⚠️ 只检查内存中的 `CurrentPositions`
- ⚠️ 如果订单状态不同步，可能不准确

## 最佳方案

### 方案1：开仓前强制同步订单状态（推荐）

**核心思路**：
1. 在 `checkTradingConditions()` 中强制同步订单状态
2. 同步持仓数据（`syncAccountData`）
3. 同步订单状态（`SyncSingleRobot`）

**实现**：

```go
func (t *RobotTrader) checkTradingConditions(ctx context.Context, signal *RobotSignal) (bool, string) {
    // ... 现有检查 ...
    
    // 【关键】开仓前强制同步订单状态，确保准确性
    // 1. 同步持仓数据（从交易所获取最新持仓）
    t.engine.syncAccountDataIfNeeded(ctx, "before_open")
    
    // 2. 同步订单状态（从数据库查询最新订单状态）
    // 异步执行，不阻塞，但确保订单状态是最新的
    go func() {
        syncCtx := context.Background()
        if err := GetOrderStatusSyncService().SyncSingleRobot(syncCtx, robot.Id); err != nil {
            g.Log().Debugf(syncCtx, "[RobotTrader] 开仓前订单状态同步失败: robotId=%d, err=%v", robot.Id, err)
        }
    }()
    
    // 3. 检查是否有持仓（使用同步后的数据）
    hasCurrentPosition := t.engine.HasActivePosition(positionSide)
    if hasCurrentPosition {
        return false, "该方向已有持仓"
    }
    
    // ...
}
```

**优点**：
- ✅ 确保开仓前订单状态是最新的
- ✅ 避免误判导致无法下单
- ✅ 避免重复开仓

**缺点**：
- ⚠️ 增加一次API调用（但开仓是重要操作，值得）

---

### 方案2：双重检查（持仓数据 + 数据库订单）

**核心思路**：
1. 检查内存中的持仓数据
2. 同时检查数据库中的订单状态
3. 任一有持仓，都认为有持仓

**实现**：

```go
func (t *RobotTrader) checkTradingConditions(ctx context.Context, signal *RobotSignal) (bool, string) {
    // ... 现有检查 ...
    
    // 【关键】开仓前强制同步持仓数据
    t.engine.syncAccountDataIfNeeded(ctx, "before_open")
    
    // 1. 检查内存中的持仓
    hasMemoryPosition := t.engine.HasActivePosition(positionSide)
    
    // 2. 检查数据库中的订单状态
    hasDbOrder := false
    var order *entity.TradingOrder
    err := dao.TradingOrder.Ctx(ctx).
        Where("robot_id", robot.Id).
        Where("direction", func() string {
            if positionSide == "LONG" {
                return "long"
            }
            return "short"
        }()).
        Where("status", 1). // 持仓中
        Scan(&order)
    if err == nil && order != nil {
        hasDbOrder = true
    }
    
    // 任一有持仓，都认为有持仓
    if hasMemoryPosition || hasDbOrder {
        return false, "该方向已有持仓"
    }
    
    // ...
}
```

**优点**：
- ✅ 双重检查，更可靠
- ✅ 不依赖订单状态同步服务

**缺点**：
- ⚠️ 需要查询数据库，增加延迟
- ⚠️ 如果数据库订单状态不同步，仍可能误判

---

### 方案3：开仓前同步 + 数据库订单检查（最佳）

**核心思路**：
1. 强制同步持仓数据（从交易所）
2. 检查数据库订单状态（作为双重验证）
3. 触发订单状态同步（异步，确保后续准确）

**实现**：

```go
func (t *RobotTrader) checkTradingConditions(ctx context.Context, signal *RobotSignal) (bool, string) {
    // ... 现有检查 ...
    
    // 【关键】开仓前强制同步持仓数据，确保准确性
    t.engine.syncAccountDataIfNeeded(ctx, "before_open")
    
    // 【双重检查】同时检查内存持仓和数据库订单状态
    positionSide := "LONG"
    if signal.Direction == "SHORT" {
        positionSide = "SHORT"
    }
    
    // 1. 检查内存中的持仓（已同步）
    hasMemoryPosition := t.engine.HasActivePosition(positionSide)
    
    // 2. 检查数据库中的订单状态（作为双重验证）
    hasDbOrder := false
    count, err := dao.TradingOrder.Ctx(ctx).
        Where("robot_id", robot.Id).
        Where("direction", func() string {
            if positionSide == "LONG" {
                return "long"
            }
            return "short"
        }()).
        Where("status", 1). // 持仓中
        Count()
    if err == nil && count > 0 {
        hasDbOrder = true
    }
    
    // 任一有持仓，都认为有持仓
    if hasMemoryPosition || hasDbOrder {
        // 如果内存和数据库不一致，触发同步
        if hasMemoryPosition != hasDbOrder {
            g.Log().Warningf(ctx, "[RobotTrader] 持仓状态不一致: robotId=%d, side=%s, memory=%v, db=%v，触发同步",
                robot.Id, positionSide, hasMemoryPosition, hasDbOrder)
            go func() {
                syncCtx := context.Background()
                GetOrderStatusSyncService().SyncSingleRobot(syncCtx, robot.Id)
            }()
        }
        return false, "该方向已有持仓"
    }
    
    // 触发订单状态同步（异步，确保后续准确）
    go func() {
        syncCtx := context.Background()
        if err := GetOrderStatusSyncService().SyncSingleRobot(syncCtx, robot.Id); err != nil {
            g.Log().Debugf(syncCtx, "[RobotTrader] 开仓前订单状态同步失败: robotId=%d, err=%v", robot.Id, err)
        }
    }()
    
    // ...
}
```

**优点**：
- ✅ 双重检查，最可靠
- ✅ 检测不一致并触发同步
- ✅ 确保开仓前状态准确

**缺点**：
- ⚠️ 需要查询数据库，但开仓是重要操作，值得

---

## 推荐方案

**推荐：方案3（开仓前同步 + 数据库订单检查）**

**理由**：
1. 双重检查，最可靠
2. 能检测到状态不一致并自动修复
3. 确保开仓前状态准确
4. 避免误判导致无法下单或重复开仓

---

## 实施步骤

1. 修改 `checkTradingConditions()` 方法
2. 添加双重检查逻辑
3. 添加状态不一致检测和自动修复
4. 测试验证

