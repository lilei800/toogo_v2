# Hotgo_v2 项目自动下单逻辑分析

## 一、整体架构

自动下单采用**事件驱动架构**，核心流程如下：

```
信号生成 → 保存预警记录 → 立即触发下单检查 → 条件验证 → 执行下单
```

## 二、核心流程详解

### 1. 信号生成阶段 (`doSignalGeneration`)

**位置**: `robot_engine.go:1218-1261`

**触发时机**: 
- 定时任务定期调用（通常每1-3秒）
- 通过 `SignalGen.Generate()` 生成交易信号

**信号生成逻辑** (`generateWindowSignal`):
- 基于**价格窗口**和**时间窗口**计算
- 计算窗口内的最低价(`WindowMinPrice`)和最高价(`WindowMaxPrice`)
- 计算当前价格与窗口极值的距离
- 当距离达到阈值(`SignalThreshold`)时触发信号：
  - **做多信号**: `当前价 - 窗口最低价 ≥ 阈值`
  - **做空信号**: `窗口最高价 - 当前价 ≥ 阈值`

**关键代码**:
```go
// robot_engine.go:2056-2071
if isNewDirection {
    // 1. 保存预警记录
    logId := e.saveSignalAlertSimple(&signalCopy)
    if logId > 0 {
        // 2. 立即触发自动下单检查（异步执行）
        go func() {
            e.Trader.TryAutoTradeAndUpdate(ctx, &signalCopy, logId)
        }()
    }
}
```

### 2. 下单检查阶段 (`TryAutoTradeAndUpdate`)

**位置**: `robot_engine.go:3225-3384`

**检查步骤**:

#### 步骤1: 基础验证
- ✅ 机器人存在性检查
- ✅ 信号有效性检查（非空、非NEUTRAL）
- ✅ 信号类型检查（只处理 `OPEN_LONG` 或 `OPEN_SHORT`）
- ✅ 防重复下单检查（检查该预警记录是否已下过单）

#### 步骤2: 自动交易开关检查
```go
// robot_engine.go:3286-3298
if autoTradeEnabled != 1 {
    // 记录失败日志：自动下单未开启
    return
}
```

#### 步骤3: 持仓检查（防止重复开仓）
- **实时检查**: 从交易所API获取当前持仓
- **检查逻辑**: 如果该方向已有持仓（持仓数量 > 0.0001），跳过下单
```go
// robot_engine.go:3317-3351
positions, err := t.engine.Exchange.GetPositions(ctx, robot.Symbol)
// 检查该方向是否有持仓
hasPosition := false
for _, pos := range positions {
    if pos.PositionSide == positionSide && math.Abs(pos.PositionAmt) > 0.0001 {
        hasPosition = true
        break
    }
}
```

#### 步骤4: 获取锁
- 使用 `orderLock` 防止并发下单
- 最多重试5次，每次间隔10ms

### 3. 参数计算阶段 (`getStrategyParamsForTrade`)

**位置**: `robot_engine.go:4063-4102`

**计算步骤**:

#### 步骤1: 获取市场状态
```go
globalAnalysis := market.GetMarketAnalyzer().GetAnalysis(t.engine.Platform, robot.Symbol)
marketState = normalizeMarketState(string(globalAnalysis.MarketState))
```
- 从全局市场分析器获取实时市场状态
- 市场状态包括: `bullish`(牛市)、`bearish`(熊市)、`sideways`(震荡)等

#### 步骤2: 选择风险偏好
```go
// 根据创建机器人时提交的映射关系选择风险偏好
riskConfig["marketRiskMapping"].(map[string]interface{})
```
- 根据市场状态从机器人的风险配置映射关系中获取对应的风险偏好
- 风险偏好包括: `conservative`(保守)、`moderate`(中等)、`aggressive`(激进)等

#### 步骤3: 获取策略参数
```go
strategyParams, err = t.engine.loadFullStrategyParams(ctx, marketState, riskPreference)
```
- 根据市场状态 + 风险偏好从策略组中获取对应的策略参数
- 策略参数包括:
  - `LeverageMin`: 杠杆倍数
  - `MarginPercentMin`: 保证金比例
  - `StopLossPercent`: 止损百分比
  - `AutoStartRetreatPercent`: 启动止盈百分比
  - `ProfitRetreatPercent`: 止盈回撤百分比

### 4. 执行下单阶段 (`executeOpen`)

**位置**: `robot_engine.go:4104-4390`

**执行步骤**:

#### 步骤1: 余额和行情检查
```go
// robot_engine.go:4108-4127
if balance == nil || balance.AvailableBalance <= 0 {
    return gerror.New("余额不足")
}
if ticker == nil {
    return gerror.New("获取行情失败")
}
```

#### 步骤2: 计算下单参数
```go
// robot_engine.go:4143-4183
leverage := strategyParams.LeverageMin
marginPercent := strategyParams.MarginPercentMin
margin := balance.AvailableBalance * marginPercent / 100
quantity := margin * float64(leverage) / ticker.LastPrice
```

**关键计算**:
- **保证金**: `可用余额 × 保证金比例`
- **下单数量**: `保证金 × 杠杆 / 当前价格`
- **最小订单金额**: 订单金额 = `margin × leverage`，必须 ≥ 5 USDT
- **最小下单数量**: 0.0001

#### 步骤3: 预创建订单记录 (`preCreateOrder`)
**位置**: `robot_engine.go:3765-3805`

**作用**: 
- 在调用交易所API之前，先在数据库中创建订单记录（状态=PENDING）
- 确保数据库保存成功后再调用交易所API
- 如果交易所API失败，订单状态会更新为FAILED

**保存的订单信息**:
- 用户ID、机器人ID、交易对、方向
- 开仓价格、数量、杠杆、保证金
- 市场状态、风险偏好、策略参数（止损、止盈等）

#### 步骤4: 设置杠杆
```go
// robot_engine.go:4215-4217
_ = t.engine.Exchange.SetLeverage(ctx, robot.Symbol, leverage)
```

#### 步骤5: 调用交易所API下单
```go
// robot_engine.go:4242-4248
order, err := t.engine.Exchange.CreateOrder(ctx, &exchange.OrderRequest{
    Symbol:       robot.Symbol,
    Side:         side,          // BUY 或 SELL
    PositionSide: positionSide, // LONG 或 SHORT
    Type:         "MARKET",      // 市价单
    Quantity:     quantity,
})
```

**订单类型**: 市价单（MARKET），立即成交

#### 步骤6: 更新订单状态
```go
// robot_engine.go:4294
err = t.updateOrderStatus(ctx, localOrderId, OrderStatusOpen, order.OrderId, order)
```

**状态更新**:
- 如果交易所API成功: 订单状态更新为 `OrderStatusOpen`(持仓中)
- 如果交易所API失败: 订单状态更新为 `OrderStatusFailed`(下单失败)

#### 步骤7: 更新内存缓存
```go
// robot_engine.go:4319-4361
// 初始化持仓跟踪器
t.engine.PositionTrackers[positionSide] = &PositionTracker{
    PositionSide: positionSide,
    EntryMargin:  margin,
    EntryTime:    time.Now(),
}
// 更新 CurrentPositions
```

#### 步骤8: 记录执行日志
```go
// robot_engine.go:4363-4381
t.saveExecutionLog(ctx, signalLogId, localOrderId, "order_success", "success", ...)
```

**日志记录**:
- `order_submit`: 提交API下单时记录
- `order_success`: 订单成功时记录
- `order_failed`: 订单失败时记录

## 三、关键数据结构

### RobotSignal (交易信号)
```go
type RobotSignal struct {
    Timestamp      time.Time
    Direction      string  // LONG, SHORT, NEUTRAL
    Action         string  // OPEN_LONG, OPEN_SHORT, HOLD
    Strength       float64 // 信号强度 0-100
    Confidence     float64 // 置信度 0-100
    CurrentPrice   float64
    WindowMinPrice float64
    WindowMaxPrice float64
    SignalThreshold float64
    Reason         string
}
```

### StrategyParams (策略参数)
```go
type StrategyParams struct {
    LeverageMin            int     // 杠杆倍数
    MarginPercentMin       float64 // 保证金比例
    StopLossPercent        float64 // 止损百分比
    AutoStartRetreatPercent float64 // 启动止盈百分比
    ProfitRetreatPercent   float64 // 止盈回撤百分比
    Window                 int     // 时间窗口（秒）
    Threshold              float64 // 波动阈值（USDT）
}
```

## 四、防重复下单机制

### 1. 预警记录级别防重复
```go
// robot_engine.go:3274-3283
// 检查该预警记录是否已经下过单
existingOrderCount, err := dao.TradingExecutionLog.Ctx(ctx).
    Where("signal_log_id", logId).
    Where("event_type IN (?)", []string{"order_submit", "order_success"}).
    Count()
if existingOrderCount > 0 {
    return // 已下过单，跳过
}
```

### 2. 持仓级别防重复
```go
// robot_engine.go:3317-3351
// 从交易所实时获取持仓，检查该方向是否已有持仓
positions, err := t.engine.Exchange.GetPositions(ctx, robot.Symbol)
for _, pos := range positions {
    if pos.PositionSide == positionSide && math.Abs(pos.PositionAmt) > 0.0001 {
        hasPosition = true // 已有持仓，跳过下单
        break
    }
}
```

### 3. 信号时间戳防重复
```go
// robot_engine.go:3673-3685
// 更新已处理的信号时间戳
if signal.Timestamp.After(t.engine.LastProcessedSignalTime) {
    t.engine.LastProcessedSignalTime = signal.Timestamp
}
```

### 4. 锁机制防并发
```go
// robot_engine.go:3354-3371
// 获取锁，防止并发下单
if t.engine.orderLock.TryLock() {
    defer t.engine.orderLock.Unlock()
    // 执行下单
}
```

## 五、订单状态流转

```
PENDING (预创建)
  ↓
  ├─→ FAILED (交易所API失败)
  │
  └─→ OPEN (持仓中，交易所API成功)
        ↓
     CLOSED (平仓)
```

**订单状态常量**:
- `OrderStatusPending = 0`: 待成交
- `OrderStatusOpen = 1`: 持仓中
- `OrderStatusClosed = 2`: 已平仓
- `OrderStatusCanceled = 3`: 已取消
- `OrderStatusFailed = 4`: 下单失败

## 六、关键配置项

### 机器人配置 (`TradingRobot`)
- `AutoTradeEnabled`: 自动交易开关（1=开启，0=关闭）
- `CurrentStrategy`: 当前策略配置（JSON格式，包含市场状态到风险偏好的映射）
- `Symbol`: 交易对
- `Exchange`: 交易所名称

### 策略配置 (`CurrentStrategy` JSON结构)
```json
{
  "riskConfig": {
    "marketRiskMapping": {
      "bullish": "aggressive",
      "bearish": "conservative",
      "sideways": "moderate"
    }
  }
}
```

## 七、日志记录

### 预警记录 (`hg_trading_signal_log`)
- 记录信号生成信息
- 不记录执行结果（执行结果记录在交易日志中）

### 交易执行日志 (`hg_trading_execution_log`)
- `order_submit`: 提交API下单
- `order_success`: 订单成功
- `order_failed`: 订单失败

### 订单记录 (`hg_trading_order`)
- 保存完整的订单信息
- 包括开仓价格、数量、杠杆、保证金、策略参数等

## 八、异常处理

### 1. 余额不足
```go
if balance == nil || balance.AvailableBalance <= 0 {
    return gerror.New("余额不足")
}
```

### 2. 订单金额不足
```go
minOrderValue := 5.0 // 最小订单价值 5 USDT
orderValue := margin * float64(leverage)
if orderValue < minOrderValue {
    return gerror.New("订单金额不足")
}
```

### 3. 交易所API失败
```go
if err != nil {
    // 更新订单状态为FAILED
    t.updateOrderStatus(ctx, localOrderId, OrderStatusFailed, "", nil)
    return gerror.Wrap(err, "交易所下单失败")
}
```

### 4. 策略参数获取失败
```go
if err != nil {
    return gerror.Wrap(err, "获取策略参数失败")
}
```

## 九、性能优化

### 1. 异步执行
- 信号生成后，下单检查在goroutine中异步执行，不阻塞信号生成

### 2. 锁机制
- 使用 `TryLock` 非阻塞锁，避免长时间等待

### 3. 实时持仓检查
- 直接从交易所API获取持仓，确保数据准确性

### 4. 预创建订单
- 先创建数据库记录，再调用交易所API，确保数据一致性

## 十、总结

自动下单逻辑采用**事件驱动架构**，核心特点：

1. **信号驱动**: 基于价格窗口和时间窗口生成交易信号
2. **立即响应**: 信号生成后立即触发下单检查
3. **多重验证**: 自动交易开关、持仓检查、余额检查等多重验证
4. **参数动态**: 根据实时市场状态和风险偏好动态获取策略参数
5. **防重复**: 预警记录级别、持仓级别、信号时间戳、锁机制等多层防护
6. **完整日志**: 预警记录、交易执行日志、订单记录完整记录整个流程

整个流程设计合理，具有良好的容错性和可追溯性。

