# 开仓信号与预警计算逻辑分析

## 一、整体流程

```
主循环（每500ms）：
  doTradingCheck() - 交易检查
    ↓
信号生成（每1秒）：
  doSignalGeneration()
    ↓
窗口信号评估：
  EvaluateWindowSignal()
    ↓
信号判断：
  - 计算窗口内最高价和最低价
  - 计算距离（distanceFromMax, distanceFromMin）
  - 判断是否触发（>= threshold）
    ↓
保存预警记录：
  saveSignalAlert()
    ↓
检查信号条件：
  checkSignalConditions()
    ↓
尝试下单：
  TryAutoTradeAndUpdate()
```

---

## 二、价格窗口管理

### 2.1 价格数据点添加

**方法：** `AddPricePoint(price float64)`

**位置：** `robot_engine.go:1074`

**调用时机：**
- WebSocket 实时价格推送时
- 定时同步行情数据时

**逻辑：**
```go
func (e *RobotEngine) AddPricePoint(price float64) {
    e.priceLock.Lock()
    defer e.priceLock.Unlock()
    
    now := time.Now().UnixMilli()
    
    // 添加新价格点
    e.PriceWindow = append(e.PriceWindow, PricePoint{
        Timestamp: now,
        Price:     price,
    })
    
    // 清理过期数据（超过窗口时间的数据）
    cutoff := now - int64(e.MonitorConfig.Window)*1000
    newWindow := make([]PricePoint, 0, len(e.PriceWindow))
    for _, p := range e.PriceWindow {
        if p.Timestamp >= cutoff {
            newWindow = append(newWindow, p)
        }
    }
    e.PriceWindow = newWindow
}
```

**关键点：**
- ✅ 维护一个时间窗口内的价格数据点
- ✅ 自动清理过期数据（超过窗口时间的数据）
- ✅ 窗口大小由 `MonitorConfig.Window` 决定（单位：秒）

---

### 2.2 窗口配置

**字段：** `MonitorConfig`

**包含：**
- `Window` = 时间窗口（秒）
- `Threshold` = 波动阈值（USDT）

**来源：**
- 从策略模板加载
- 可通过 `UpdateMonitorConfig()` 更新

---

## 三、信号生成逻辑

### 3.1 doSignalGeneration 方法

**位置：** `robot_engine.go:1029`

**调用时机：** 每1秒（`tickCount % 2 == 0`）

**代码：**
```go
func (e *RobotEngine) doSignalGeneration(ctx context.Context) {
    signal := e.SignalGen.Generate(ctx)
    if signal != nil {
        e.mu.Lock()
        e.LastSignal = signal
        e.LastSignalUpdate = time.Now()
        e.mu.Unlock()
        
        if signal.Direction != "NEUTRAL" {
            g.Log().Debugf(ctx, "[RobotEngine] robotId=%d, 方向信号: %s, 强度=%.2f%%, 置信度=%.2f%%",
                e.Robot.Id, signal.Direction, signal.Strength, signal.Confidence)
        }
    }
}
```

**作用：**
- ✅ 调用信号生成器生成信号
- ✅ 更新 `LastSignal` 和 `LastSignalUpdate`

---

### 3.2 Generate 方法（信号生成器）

**位置：** `robot_engine.go:2124`

**代码：**
```go
func (s *RobotSignalGen) Generate(ctx context.Context) *RobotSignal {
    // 直接评估窗口价格信号
    windowSignal := s.engine.EvaluateWindowSignal()
    if windowSignal == nil {
        return &RobotSignal{
            Timestamp:  time.Now(),
            Direction:  "NEUTRAL",
            SignalType: "none",
            Reason:     "等待数据...",
        }
    }
    
    // 直接返回窗口信号，不再做技术分析确认
    return windowSignal
}
```

**特点：**
- ✅ 只使用窗口信号，不做技术分析
- ✅ 如果窗口信号为空，返回 NEUTRAL 信号

---

## 四、窗口信号评估（核心逻辑）

### 4.1 EvaluateWindowSignal 方法

**位置：** `robot_engine.go:1128`

**核心算法：**

```
1. 计算窗口内最高价和最低价
   minPrice = 窗口内最低价
   maxPrice = 窗口内最高价
   currentPrice = 最新价格

2. 计算距离
   distanceFromMax = maxPrice - currentPrice  // 最高价 - 实时价格
   distanceFromMin = currentPrice - minPrice  // 实时价格 - 最低价

3. 判断触发条件
   做空触发：distanceFromMax >= threshold
   做多触发：distanceFromMin >= threshold

4. 生成信号
   - 如果做多触发 → LONG 信号（OPEN_LONG）
   - 如果做空触发 → SHORT 信号（OPEN_SHORT）
   - 如果双向触发 → NEUTRAL（继续监控）
   - 如果都不触发 → NEUTRAL（显示进度）
```

---

### 4.2 详细计算逻辑

#### 4.2.1 数据准备

```go
// 1. 检查窗口数据
dataCount := len(e.PriceWindow)
if dataCount == 0 {
    return NEUTRAL  // 等待价格数据...
}
if dataCount == 1 {
    return NEUTRAL  // 已获取初始价格，等待更多数据...
}

// 2. 计算窗口内最高价和最低价
minPrice := e.PriceWindow[0].Price
maxPrice := e.PriceWindow[0].Price
for _, p := range e.PriceWindow {
    if p.Price < minPrice {
        minPrice = p.Price
    }
    if p.Price > maxPrice {
        maxPrice = p.Price
    }
}

currentPrice := e.PriceWindow[dataCount-1].Price
threshold := e.MonitorConfig.Threshold
```

---

#### 4.2.2 距离计算

```go
// 计算距离
distanceFromMax := maxPrice - currentPrice  // 最高价 - 实时价格
distanceFromMin := currentPrice - minPrice  // 实时价格 - 最低价
```

**含义：**
- `distanceFromMax`：当前价格距离窗口最高价的距离
- `distanceFromMin`：当前价格距离窗口最低价的距离

---

#### 4.2.3 触发条件判断

```go
// 触发条件
shortTriggered := distanceFromMax >= threshold  // 做空：最高价 - 实时价格 >= 波动值
longTriggered := distanceFromMin >= threshold   // 做多：实时价格 - 最低价 >= 波动值
```

**逻辑：**
- ✅ **做空信号**：价格从高点回落，回落幅度 ≥ 波动阈值
- ✅ **做多信号**：价格从低点反弹，反弹幅度 ≥ 波动阈值

---

#### 4.2.4 双向触发处理

```go
// 双向同时触发时（价格剧烈波动，窗口范围 >= 2*阈值），重置预警继续监控
if longTriggered && shortTriggered {
    e.LastAlertedLong = nil
    e.LastAlertedShort = nil
    signal.Direction = "NEUTRAL"
    signal.Reason = fmt.Sprintf("窗口双向触发 | 高%.2f 实时%.2f 低%.2f | 振幅%.2f≥2×阈值%.0f，继续监控",
        maxPrice, currentPrice, minPrice, maxPrice-minPrice, threshold)
    return signal
}
```

**处理：**
- ✅ 如果双向同时触发，返回 NEUTRAL
- ✅ 重置预警标记，继续监控

---

#### 4.2.5 单向触发处理

```go
// 单向触发判断（更新预警基准价）
if longTriggered {
    newSignal = "long"
    if e.LastAlertedLong == nil || math.Abs(minPrice-*e.LastAlertedLong) > 0.0001 {
        e.LastAlertedLong = &minPrice
    }
} else if shortTriggered {
    newSignal = "short"
    if e.LastAlertedShort == nil || math.Abs(maxPrice-*e.LastAlertedShort) > 0.0001 {
        e.LastAlertedShort = &maxPrice
    }
}
```

**处理：**
- ✅ 更新预警基准价（`LastAlertedLong` 或 `LastAlertedShort`）
- ✅ 避免重复预警（基准价变化小于 0.0001 时不更新）

---

#### 4.2.6 信号生成

```go
switch newSignal {
case "long":
    signal.Direction = "LONG"
    signal.Strength = 100        // 简化版：触发即100%
    signal.Confidence = 100
    signal.Action = "OPEN_LONG"
    signal.Reason = fmt.Sprintf("📈 做多信号 | 实时%.2f - 低%.2f = %.2f ≥ 阈值%.0f",
        currentPrice, minPrice, distanceFromMin, threshold)
    
case "short":
    signal.Direction = "SHORT"
    signal.Strength = 100        // 简化版：触发即100%
    signal.Confidence = 100
    signal.Action = "OPEN_SHORT"
    signal.Reason = fmt.Sprintf("📉 做空信号 | 高%.2f - 实时%.2f = %.2f ≥ 阈值%.0f",
        maxPrice, currentPrice, distanceFromMax, threshold)
    
default:
    signal.Direction = "NEUTRAL"
    signal.Strength = 0
    signal.Confidence = 0
    signal.Action = "HOLD"
    // 计算进度（距离触发条件的百分比）
    longProgress := (distanceFromMin / threshold) * 100
    shortProgress := (distanceFromMax / threshold) * 100
    if longProgress > shortProgress {
        signal.SignalProgress = math.Min(100, longProgress)
    } else {
        signal.SignalProgress = math.Min(100, shortProgress)
    }
    signal.Reason = fmt.Sprintf("监控中 | 高%.2f 实时%.2f 低%.2f | 做多%.0f%% 做空%.0f%%",
        maxPrice, currentPrice, minPrice, longProgress, shortProgress)
}
```

**信号属性：**
- `Direction`：方向（LONG/SHORT/NEUTRAL）
- `Action`：操作（OPEN_LONG/OPEN_SHORT/HOLD）
- `Strength`：强度（触发时100%，未触发时0%）
- `Confidence`：置信度（触发时100%，未触发时0%）
- `SignalProgress`：信号进度（未触发时显示距离触发条件的百分比）

---

## 五、预警记录保存

### 5.1 saveSignalAlert 方法

**位置：** `robot_engine.go:1316`

**调用时机：** 当信号不是 NEUTRAL 时（`newSignal != "neutral"`）

**逻辑：**

```
1. 检查是否是新方向
   - 如果是新方向 → 必须保存
   - 如果不是新方向 → 检查30秒内是否已有记录

2. 检查信号条件
   - 调用 checkSignalConditions() 检查条件
   - 返回执行结果（"准备下单"、"自动下单未开启"、"该方向已有持仓"等）

3. 保存预警记录
   - 保存到 hg_trading_signal_log 表
   - 包含信号信息、价格信息、执行结果等

4. 返回记录ID
   - 用于后续更新执行状态
```

---

### 5.2 checkSignalConditions 方法

**位置：** `robot_engine.go:1379`

**检查项：**

```
1. ✅ 自动交易开关
   - 条件：robot.AutoTradeEnabled == 1
   - 失败：返回 "自动下单未开启"

2. ✅ 信号操作类型
   - 条件：signal.Action == "OPEN_LONG" || signal.Action == "OPEN_SHORT"
   - 失败：返回 "信号类型为{Action}，不是开仓信号"

3. ✅ 本方向持仓检查
   - 条件：该方向没有持仓
   - 失败：返回 "该方向已有持仓"

4. ✅ 算力检查
   - 条件：用户算力 ≥ 1点
   - 失败：返回 "算力不足，请充值"

✅ 所有条件满足 → 返回 "准备下单"
```

---

### 5.3 预警记录字段

**保存到数据库的字段：**

```go
{
    "robot_id":         e.Robot.Id,
    "strategy_id":      0,
    "symbol":           e.Robot.Symbol,
    "signal_type":      signal.Direction,        // LONG/SHORT
    "signal_source":    "window_weighted",
    "signal_strength":  signal.Strength,         // 100
    "current_price":    signal.CurrentPrice,
    "window_min_price": signal.WindowMinPrice,
    "window_max_price": signal.WindowMaxPrice,
    "threshold":        signal.SignalThreshold,
    "market_state":     marketState,
    "risk_preference":  e.Robot.RiskPreference,
    "target_price":     0,
    "stop_loss":        0,
    "take_profit":      0,
    "executed":         0,                       // 0=未执行, 1=已执行
    "execute_result":   executeResult,           // "准备下单"、"自动下单未开启"等
    "reason":           signal.Reason,
    "indicators":       "{}",
}
```

---

## 六、信号触发开仓

### 6.1 TryAutoTradeAndUpdate 方法

**位置：** `robot_engine.go:2238`

**调用时机：** 信号生成后异步调用（`go func()`）

**逻辑：**

```
1. 提前过滤：只处理开仓信号
   - 如果不是 OPEN_LONG 或 OPEN_SHORT → 直接返回

2. 检查自动交易开关
   - 如果未开启 → 更新预警记录为 "自动下单未开启"

3. 检查下单条件
   - 调用 checkTradingConditions()
   - 如果条件不满足 → 更新预警记录为失败原因

4. 执行开仓
   - 调用 executeOpen()
   - 如果成功 → 更新预警记录为 "下单成功"
   - 如果失败 → 更新预警记录为 "下单失败: {错误信息}"
```

---

### 6.2 预警记录更新

**方法：** `updateSignalLog()`

**位置：** `robot_engine.go:2298`

**更新字段：**
- `executed`：执行状态（0=未执行, 1=已执行）
- `execute_result`：执行结果（"下单成功"、"下单失败: {错误}"等）

---

## 七、完整流程示例

### 7.1 示例：做多信号生成

**场景：**
- 时间窗口：60秒
- 波动阈值：50 USDT
- 窗口内价格：96000, 96100, 96200, 96300, 96400, 96500, 96600, 96700, 96800, 96900
- 当前价格：97000

**计算过程：**

```
1. 计算窗口内最高价和最低价
   minPrice = 96000
   maxPrice = 96900
   currentPrice = 97000

2. 计算距离
   distanceFromMax = 96900 - 97000 = -100（负数，说明当前价格高于窗口最高价）
   distanceFromMin = 97000 - 96000 = 1000

3. 判断触发条件
   shortTriggered = (-100 >= 50) = false
   longTriggered = (1000 >= 50) = true ✅

4. 生成信号
   Direction = "LONG"
   Action = "OPEN_LONG"
   Strength = 100
   Confidence = 100
   Reason = "📈 做多信号 | 实时97000 - 低96000 = 1000 ≥ 阈值50"

5. 保存预警记录
   - 检查条件 → "准备下单"
   - 保存到数据库 → logId = 123

6. 尝试下单
   - 检查条件 → 通过
   - 执行开仓 → 成功
   - 更新预警记录 → "下单成功: order_12345"
```

---

### 7.2 示例：做空信号生成

**场景：**
- 时间窗口：60秒
- 波动阈值：50 USDT
- 窗口内价格：97000, 96900, 96800, 96700, 96600, 96500, 96400, 96300, 96200, 96100
- 当前价格：96000

**计算过程：**

```
1. 计算窗口内最高价和最低价
   minPrice = 96000
   maxPrice = 97000
   currentPrice = 96000

2. 计算距离
   distanceFromMax = 97000 - 96000 = 1000
   distanceFromMin = 96000 - 96000 = 0

3. 判断触发条件
   shortTriggered = (1000 >= 50) = true ✅
   longTriggered = (0 >= 50) = false

4. 生成信号
   Direction = "SHORT"
   Action = "OPEN_SHORT"
   Strength = 100
   Confidence = 100
   Reason = "📉 做空信号 | 高97000 - 实时96000 = 1000 ≥ 阈值50"

5. 保存预警记录
   - 检查条件 → "准备下单"
   - 保存到数据库 → logId = 124

6. 尝试下单
   - 检查条件 → 通过
   - 执行开仓 → 成功
   - 更新预警记录 → "下单成功: order_12346"
```

---

### 7.3 示例：未触发信号（显示进度）

**场景：**
- 时间窗口：60秒
- 波动阈值：50 USDT
- 窗口内价格：96000, 96100, 96200, 96300, 96400, 96500
- 当前价格：96500

**计算过程：**

```
1. 计算窗口内最高价和最低价
   minPrice = 96000
   maxPrice = 96500
   currentPrice = 96500

2. 计算距离
   distanceFromMax = 96500 - 96500 = 0
   distanceFromMin = 96500 - 96000 = 500

3. 判断触发条件
   shortTriggered = (0 >= 50) = false
   longTriggered = (500 >= 50) = true ✅

4. 生成信号
   Direction = "LONG"
   Action = "OPEN_LONG"
   Strength = 100
   Confidence = 100
   Reason = "📈 做多信号 | 实时96500 - 低96000 = 500 ≥ 阈值50"

5. 保存预警记录
   - 检查条件 → "准备下单"
   - 保存到数据库 → logId = 125

6. 尝试下单
   - 检查条件 → 通过
   - 执行开仓 → 成功
   - 更新预警记录 → "下单成功: order_12347"
```

**注意：** 这个例子中，`distanceFromMin = 500` 已经大于阈值 50，所以会触发做多信号。

---

### 7.4 示例：未触发信号（显示进度）

**场景：**
- 时间窗口：60秒
- 波动阈值：50 USDT
- 窗口内价格：96000, 96100, 96200, 96300, 96400, 96500
- 当前价格：96200

**计算过程：**

```
1. 计算窗口内最高价和最低价
   minPrice = 96000
   maxPrice = 96500
   currentPrice = 96200

2. 计算距离
   distanceFromMax = 96500 - 96200 = 300
   distanceFromMin = 96200 - 96000 = 200

3. 判断触发条件
   shortTriggered = (300 >= 50) = true ✅
   longTriggered = (200 >= 50) = true ✅

4. 双向触发处理
   - 返回 NEUTRAL
   - 重置预警标记
   - Reason = "窗口双向触发 | 高96500 实时96200 低96000 | 振幅500≥2×阈值50，继续监控"

5. 不保存预警记录（因为返回 NEUTRAL）
```

---

## 八、关键数据结构

### 8.1 RobotSignal 结构

```go
type RobotSignal struct {
    Timestamp       time.Time  // 时间戳
    Direction       string     // 方向：LONG/SHORT/NEUTRAL
    SignalType      string     // 信号类型：window/analysis
    Action          string     // 操作：OPEN_LONG/OPEN_SHORT/HOLD
    Strength        float64    // 信号强度：0-100
    Confidence      float64    // 置信度：0-100
    CurrentPrice    float64    // 当前价格
    WindowMinPrice  float64    // 窗口最低价
    WindowMaxPrice  float64    // 窗口最高价
    DistanceFromMin float64    // 距离最低价的距离
    DistanceFromMax float64    // 距离最高价的距离
    SignalThreshold float64    // 信号阈值
    SignalProgress  float64    // 信号进度：0-100
    Reason          string     // 信号原因
}
```

---

### 8.2 PricePoint 结构

```go
type PricePoint struct {
    Timestamp int64   // 时间戳（毫秒）
    Price     float64 // 价格
}
```

---

## 九、关键配置

### 9.1 MonitorConfig 配置

```go
type MonitorConfig struct {
    Window    int     // 时间窗口（秒）
    Threshold float64 // 波动阈值（USDT）
    Symbol    string  // 交易对
}
```

**来源：**
- 从策略模板加载（`StrategyParams.Window` 和 `StrategyParams.Threshold`）
- 可通过 `UpdateMonitorConfig()` 更新

---

## 十、总结

### 10.1 信号生成流程

1. **价格数据收集**
   - WebSocket 实时推送价格
   - 添加到价格窗口（`AddPricePoint`）
   - 自动清理过期数据

2. **信号评估（每1秒）**
   - 计算窗口内最高价和最低价
   - 计算距离（`distanceFromMax`, `distanceFromMin`）
   - 判断是否触发（`>= threshold`）

3. **信号生成**
   - 做多信号：`distanceFromMin >= threshold`
   - 做空信号：`distanceFromMax >= threshold`
   - 双向触发：返回 NEUTRAL，继续监控

4. **预警记录保存**
   - 检查信号条件（`checkSignalConditions`）
   - 保存到数据库（`saveSignalAlert`）
   - 返回记录ID

5. **尝试下单**
   - 异步调用 `TryAutoTradeAndUpdate`
   - 检查下单条件
   - 执行开仓
   - 更新预警记录

---

### 10.2 核心算法

**做多信号：**
```
distanceFromMin = currentPrice - minPrice
if distanceFromMin >= threshold:
    生成 OPEN_LONG 信号
```

**做空信号：**
```
distanceFromMax = maxPrice - currentPrice
if distanceFromMax >= threshold:
    生成 OPEN_SHORT 信号
```

**信号进度（未触发时）：**
```
longProgress = (distanceFromMin / threshold) * 100
shortProgress = (distanceFromMax / threshold) * 100
SignalProgress = max(longProgress, shortProgress)
```

---

### 10.3 关键特点

- ✅ **纯窗口逻辑**：只使用窗口价格，不做技术分析
- ✅ **实时监控**：每1秒评估一次信号
- ✅ **自动清理**：过期价格数据自动清理
- ✅ **预警机制**：每个信号都会保存预警记录
- ✅ **条件检查**：保存预警时检查条件，返回执行结果
- ✅ **异步下单**：信号生成后异步尝试下单

