# 市场状态统一性和映射关系唯一性调整方案

## 一、问题分析

### 1.1 市场状态统一性问题

**当前状态：**
- 代码内部使用：`trend`, `volatile`, `high_vol`, `low_vol`
- 数据库可能存储：`trend`, `volatile`, `range`, `high-volatility`, `low-volatility`
- 存在多处兼容性处理，导致代码复杂且容易出错

**问题：**
- 市场状态格式不统一，需要多处兼容处理
- `mapMarketStateToDb` 函数只处理了 `range → volatile`，没有处理 `high-volatility` 和 `low-volatility`
- `loadFullStrategyParams` 中有大量兼容性代码

### 1.2 映射关系唯一性问题

**当前状态：**
- `robot_engine.go` 中的 `loadRiskConfigFromRobot` 函数已废弃，但代码还在
- `checkAndUpdateStrategyConfig` 直接使用 `e.Robot.RiskPreference`，没有使用映射关系
- `GetStatus()` 方法中有从 `CurrentStrategy` 读取映射关系的代码
- `engine/trader.go` 和 `engine/signal_gen.go` 使用了 `MarketRiskMapping`，但 `robot_engine.go` 中没有这个字段

**问题：**
- 映射关系读取逻辑分散，没有统一入口
- `checkAndUpdateStrategyConfig` 没有使用映射关系，导致市场状态变化时风险偏好不会自动切换
- 存在废弃代码，需要清理

## 二、调整方案

### 2.1 市场状态统一性调整

#### 2.1.1 统一市场状态格式

**标准格式：** `trend`, `volatile`, `high_vol`, `low_vol`

**映射规则：**
- `range` → `volatile`
- `high-volatility` → `high_vol`
- `low-volatility` → `low_vol`

#### 2.1.2 创建统一的市场状态规范化函数

```go
// normalizeMarketState 规范化市场状态格式
// 统一格式: trend, volatile, high_vol, low_vol
func normalizeMarketState(marketState string) string {
    switch marketState {
    case "range":
        return "volatile"
    case "high-volatility":
        return "high_vol"
    case "low-volatility":
        return "low_vol"
    case "trend", "volatile", "high_vol", "low_vol":
        return marketState
    default:
        // 未知格式，返回默认值
        g.Log().Warningf(ctx, "[RobotEngine] 未知市场状态格式: %s，使用默认值 trend", marketState)
        return "trend"
    }
}
```

#### 2.1.3 在所有市场状态输入点使用规范化函数

- `doAnalysis()` 中分析结果的市场状态
- `loadFullStrategyParams()` 中查询策略模板时的市场状态
- `checkAndUpdateStrategyConfig()` 中检测到的市场状态
- `GetStatus()` 中返回的市场状态

### 2.2 映射关系唯一性调整

#### 2.2.1 在 RobotEngine 中添加 MarketRiskMapping 字段

```go
type RobotEngine struct {
    // ... 其他字段 ...
    
    // ============ 市场状态与策略配置 ============
    LastMarketState       string            // 上次检测到的市场状态
    MarketRiskMapping     map[string]string // 市场状态 → 风险偏好映射（从机器人CurrentStrategy加载）
    CurrentStrategyParams *StrategyParams   // 当前使用的策略参数
    VolatilityConfig      *VolatilityConfig // 波动率配置
}
```

#### 2.2.2 统一映射关系读取逻辑

**修改 `loadRiskConfigFromRobot` 函数：**

```go
// loadRiskConfigFromRobot 从机器人配置加载风险映射
// 映射关系存储在 Robot.CurrentStrategy JSON 中的 riskConfig.marketRiskMapping
func (e *RobotEngine) loadRiskConfigFromRobot(ctx context.Context) {
    // 初始化默认映射
    e.MarketRiskMapping = map[string]string{
        "trend":    "balanced",
        "volatile": "balanced",
        "high_vol": "aggressive",
        "low_vol":  "conservative",
    }
    
    // 从机器人配置加载映射关系
    if e.Robot.CurrentStrategy == "" {
        g.Log().Debugf(ctx, "[RobotEngine] robotId=%d 未配置映射关系，使用默认映射", e.Robot.Id)
        return
    }
    
    var configData map[string]interface{}
    if err := json.Unmarshal([]byte(e.Robot.CurrentStrategy), &configData); err != nil {
        g.Log().Warningf(ctx, "[RobotEngine] robotId=%d 解析CurrentStrategy失败: %v，使用默认映射", e.Robot.Id, err)
        return
    }
    
    if riskConfig, ok := configData["riskConfig"].(map[string]interface{}); ok {
        if mapping, ok := riskConfig["marketRiskMapping"].(map[string]interface{}); ok {
            for k, v := range mapping {
                if vs, ok := v.(string); ok {
                    // 规范化市场状态键
                    normalizedKey := normalizeMarketState(k)
                    e.MarketRiskMapping[normalizedKey] = vs
                }
            }
            g.Log().Infof(ctx, "[RobotEngine] robotId=%d 加载风险配置映射: %v", e.Robot.Id, e.MarketRiskMapping)
        }
    }
}
```

#### 2.2.3 修改 checkAndUpdateStrategyConfig 使用映射关系

```go
// checkAndUpdateStrategyConfig 检测市场状态变化并更新策略配置
func (e *RobotEngine) checkAndUpdateStrategyConfig(ctx context.Context, currentMarketState string) {
    // 规范化市场状态
    currentMarketState = normalizeMarketState(currentMarketState)
    
    // 如果市场状态为空，不更新
    if currentMarketState == "" {
        return
    }
    
    // 检查是否需要更新：首次初始化（LastMarketState为空）或市场状态变化
    e.mu.RLock()
    needUpdate := e.LastMarketState == "" || currentMarketState != e.LastMarketState
    e.mu.RUnlock()
    
    if !needUpdate {
        return
    }
    
    // 市场状态变化或首次初始化
    e.mu.Lock()
    oldState := e.LastMarketState
    e.LastMarketState = currentMarketState
    e.mu.Unlock()
    
    // 从映射关系获取风险偏好（核心改进）
    e.mu.RLock()
    riskPreference := e.MarketRiskMapping[currentMarketState]
    e.mu.RUnlock()
    
    // 降级策略：如果映射关系中没有，使用机器人配置的风险偏好
    if riskPreference == "" {
        riskPreference = e.Robot.RiskPreference
        if riskPreference == "" {
            riskPreference = "balanced" // 默认平衡
        }
        g.Log().Warningf(ctx, "[RobotEngine] robotId=%d 市场状态 %s 未找到映射关系，使用机器人配置的风险偏好: %s", 
            e.Robot.Id, currentMarketState, riskPreference)
    }
    
    // 从策略模板加载完整策略参数
    strategyParams, err := e.loadFullStrategyParams(ctx, currentMarketState, riskPreference)
    if err != nil {
        g.Log().Errorf(ctx, "[RobotEngine] robotId=%d 加载策略参数失败: %v", e.Robot.Id, err)
        return
    }
    
    // 更新当前策略参数
    e.mu.Lock()
    e.CurrentStrategyParams = strategyParams
    e.mu.Unlock()
    
    // 更新监控配置
    if strategyParams.Window > 0 && strategyParams.Threshold > 0 {
        e.UpdateMonitorConfig(strategyParams.Window, strategyParams.Threshold)
        g.Log().Infof(ctx, "[RobotEngine] robotId=%d 市场状态变化: %s → %s, 风险偏好(映射): %s, 策略参数: 窗口=%ds, 波动=%.2f, 杠杆=%d-%d, 保证金=%.1f-%.1f%%",
            e.Robot.Id, oldState, currentMarketState, riskPreference,
            strategyParams.Window, strategyParams.Threshold,
            strategyParams.LeverageMin, strategyParams.LeverageMax,
            strategyParams.MarginPercentMin, strategyParams.MarginPercentMax)
    }
}
```

#### 2.2.4 简化 loadFullStrategyParams 中的市场状态兼容性处理

```go
// loadFullStrategyParams 从策略模板加载完整参数
func (e *RobotEngine) loadFullStrategyParams(ctx context.Context, marketState, riskPreference string) (*StrategyParams, error) {
    params := &StrategyParams{}
    
    // 规范化市场状态（统一格式）
    normalizedMarketState := normalizeMarketState(marketState)
    
    // 1. 获取策略组ID
    // ... 现有逻辑 ...
    
    // 2. 从策略模板表中查询对应的策略
    // 尝试多种格式（兼容旧数据）
    marketStatesToTry := []string{
        normalizedMarketState,                    // 标准格式
        marketState,                               // 原始格式（如果不同）
    }
    
    // 添加兼容格式（仅当与标准格式不同时）
    if normalizedMarketState == "volatile" && marketState != "volatile" {
        marketStatesToTry = append(marketStatesToTry, "range") // 兼容旧格式
    }
    if normalizedMarketState == "high_vol" && marketState != "high_vol" {
        marketStatesToTry = append(marketStatesToTry, "high-volatility") // 兼容数据库格式
    }
    if normalizedMarketState == "low_vol" && marketState != "low_vol" {
        marketStatesToTry = append(marketStatesToTry, "low-volatility") // 兼容数据库格式
    }
    
    // 查询策略模板
    for _, ms := range marketStatesToTry {
        var strategy *entity.TradingStrategyTemplate
        err := dao.TradingStrategyTemplate.Ctx(ctx).
            Where("group_id", groupId).
            Where(dao.TradingStrategyTemplate.Columns().MarketState, ms).
            Where(dao.TradingStrategyTemplate.Columns().RiskPreference, riskPreference).
            Scan(&strategy)
        
        if err == nil && strategy != nil {
            // 加载策略参数
            // ... 现有逻辑 ...
            return params, nil
        }
    }
    
    // 未找到策略模板
    // ... 错误处理 ...
}
```

#### 2.2.5 修改 GetStatus 使用统一的映射关系

```go
// GetStatus 获取引擎状态
func (e *RobotEngine) GetStatus() *RobotEngineStatus {
    e.mu.RLock()
    defer e.mu.RUnlock()
    
    // ... 其他状态字段 ...
    
    // 当前市场状态
    currentState := e.LastMarketState
    if currentState == "" && e.LastAnalysis != nil {
        currentState = normalizeMarketState(e.LastAnalysis.MarketState)
    }
    status.CurrentMarketState = currentState
    
    // 当前风险偏好：从映射关系获取
    currentRiskPref := ""
    if currentState != "" {
        currentRiskPref = e.MarketRiskMapping[currentState]
    }
    
    // 降级策略
    if currentRiskPref == "" {
        currentRiskPref = e.Robot.RiskPreference
        if currentRiskPref == "" {
            currentRiskPref = "balanced"
        }
    }
    status.CurrentRiskPref = currentRiskPref
    
    // ... 其他状态字段 ...
    
    return status
}
```

### 2.3 清理废弃代码

#### 2.3.1 移除 engine/ 目录下的重复实现（如果不再使用）

如果 `engine/` 目录下的代码不再使用，可以考虑移除或标记为废弃。

#### 2.3.2 统一使用 robot_engine.go 中的实现

确保所有地方都使用 `robot_engine.go` 中的 `RobotEngine` 实现。

## 三、实施步骤

### 步骤1：添加 MarketRiskMapping 字段
1. 在 `RobotEngine` 结构体中添加 `MarketRiskMapping map[string]string` 字段
2. 在 `NewRobotEngine` 中初始化默认映射

### 步骤2：创建 normalizeMarketState 函数
1. 创建统一的市场状态规范化函数
2. 在所有市场状态输入点使用此函数

### 步骤3：修改 loadRiskConfigFromRobot
1. 实现从 `CurrentStrategy` JSON 加载映射关系的逻辑
2. 规范化市场状态键

### 步骤4：修改 checkAndUpdateStrategyConfig
1. 使用映射关系获取风险偏好
2. 添加降级策略

### 步骤5：简化 loadFullStrategyParams
1. 使用规范化函数统一市场状态格式
2. 简化兼容性处理逻辑

### 步骤6：修改 GetStatus
1. 使用统一的映射关系获取当前风险偏好
2. 规范化市场状态

### 步骤7：测试验证
1. 测试市场状态规范化功能
2. 测试映射关系加载和使用
3. 测试市场状态变化时风险偏好的自动切换

## 四、预期效果

1. **市场状态统一性**：所有市场状态统一为 `trend`, `volatile`, `high_vol`, `low_vol` 格式
2. **映射关系唯一性**：映射关系只在一个地方读取（`loadRiskConfigFromRobot`），在所有需要的地方使用
3. **代码简洁性**：减少兼容性处理代码，提高代码可维护性
4. **功能正确性**：市场状态变化时，风险偏好会根据映射关系自动切换

