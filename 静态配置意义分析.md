# 静态配置（CurrentStrategy JSON）在机器人独立运行场景下的意义分析

## 一、机器人运行机制

### 1.1 独立运行特性
- ✅ 机器人是**后端服务**，可以独立运行
- ✅ 即使**前端不打开**，机器人也会继续运行
- ✅ 引擎启动时从**数据库加载配置**，运行时从**策略模板动态加载参数**

### 1.2 数据流向

```
创建时：
  前端配置 → 保存到数据库（CurrentStrategy JSON + 静态字段）
  ↓
引擎启动时：
  从数据库加载 Robot 实体 → 从 CurrentStrategy JSON 加载映射关系 → 初始化引擎
  ↓
运行时：
  市场分析 → 使用映射关系选择风险偏好 → 从策略模板动态加载参数 → 更新缓存
```

---

## 二、静态配置（CurrentStrategy JSON）的内容

### 2.1 当前保存的内容

```json
{
  "strategyKey": "...",
  "strategyName": "...",
  "description": "...",
  "monitorWindow": 60,
  "volatilityThreshold": 50,
  "leverageMin": 10,
  "leverageMax": 10,
  "marginPercentMin": 10,
  "marginPercentMax": 10,
  "stopLossPercent": 10,
  "profitRetreatPercent": 10,
  "autoStartRetreatPercent": 5,
  "groupId": 18,
  "riskConfig": {
    "marketRiskMapping": {
      "trend": "balanced",
      "volatile": "balanced",
      "high_vol": "aggressive",
      "low_vol": "conservative"
    }
  }
}
```

### 2.2 各部分的作用

| 字段 | 是否必需 | 运行时使用 | 说明 |
|------|---------|-----------|------|
| **riskConfig.marketRiskMapping** | ✅ **必需** | ✅ 是 | 映射关系持久化，引擎启动时加载 |
| **groupId** | ✅ **必需** | ✅ 是 | 用于查询策略模板 |
| **策略参数快照** | ⚠️ **可选** | ❌ 否 | 运行时从策略模板动态加载 |

---

## 三、静态配置的意义分析

### 3.1 ✅ **必需部分：映射关系和策略组ID**

#### 3.1.1 映射关系（marketRiskMapping）

**为什么必需？**
- 映射关系是**用户配置**的，需要持久化保存
- 引擎启动时，需要从数据库加载映射关系
- 如果 `CurrentStrategy` 为空，使用默认映射（可能不符合用户意图）

**使用场景：**
```go
// 引擎初始化时
engine.loadRiskConfigFromRobot(ctx)  // 从 CurrentStrategy JSON 加载映射关系

// 运行时
riskPreference := e.MarketRiskMapping[currentMarketState]  // 使用映射关系选择风险偏好
```

**结论：** ✅ **必需保留**

---

#### 3.1.2 策略组ID（groupId）

**为什么必需？**
- 用于查询策略模板（`loadFullStrategyParams`）
- 优先级：`Robot.StrategyGroupId` > `CurrentStrategy.groupId`
- 如果 `Robot.StrategyGroupId` 为空，从 `CurrentStrategy.groupId` 获取

**使用场景：**
```go
// 查询策略模板时
if e.Robot.StrategyGroupId > 0 {
    groupId = e.Robot.StrategyGroupId  // 优先使用机器人绑定的策略组ID
} else if e.Robot.CurrentStrategy != "" {
    // 从 CurrentStrategy JSON 中获取
    groupId = strategyData["groupId"]
}
```

**结论：** ✅ **必需保留**（但优先级低于 `Robot.StrategyGroupId`）

---

### 3.2 ⚠️ **可选部分：策略参数快照**

#### 3.2.1 策略参数快照的作用

**当前实现：**
- 运行时**不使用**策略参数快照
- 总是从策略模板动态加载参数
- 策略参数快照只是"历史记录"

**潜在用途：**
1. **降级策略**：如果策略模板查询失败，可以使用快照（但当前代码不使用）
2. **历史记录**：记录创建时的配置，便于追溯
3. **前端显示**：前端可以显示创建时的配置（但实际运行时使用的是动态配置）

**问题：**
- ❌ 如果策略模板被修改，快照会**过时**
- ❌ 如果策略模板被删除，快照**无法使用**（因为代码要求必须找到策略模板）
- ❌ 快照占用存储空间，但**不被使用**

---

## 四、优化建议

### 4.1 方案一：精简静态配置（推荐）✅

**只保存必需的数据：**
```json
{
  "groupId": 18,
  "riskConfig": {
    "marketRiskMapping": {
      "trend": "balanced",
      "volatile": "balanced",
      "high_vol": "aggressive",
      "low_vol": "conservative"
    }
  }
}
```

**优点：**
- ✅ 减少存储空间
- ✅ 避免数据不一致（快照过时）
- ✅ 明确静态配置的作用（只保存用户配置）

**缺点：**
- ⚠️ 前端无法显示创建时的策略参数（但可以实时查询策略模板）

---

### 4.2 方案二：保留策略参数快照（当前方案）

**保留完整配置：**
```json
{
  "strategyKey": "...",
  "strategyName": "...",
  // ... 所有策略参数
  "groupId": 18,
  "riskConfig": {
    "marketRiskMapping": {...}
  }
}
```

**优点：**
- ✅ 前端可以显示创建时的配置
- ✅ 可以作为降级策略（需要修改代码）

**缺点：**
- ❌ 占用更多存储空间
- ❌ 数据可能过时
- ❌ 增加维护成本

---

### 4.3 方案三：分离存储（最佳方案）⭐

**将静态配置分为两部分：**

1. **用户配置**（保存到 `CurrentStrategy` JSON）：
   ```json
   {
     "groupId": 18,
     "riskConfig": {
       "marketRiskMapping": {...}
     }
   }
   ```

2. **策略参数快照**（保存到单独的字段或表）：
   - 创建时保存到 `hg_trading_robot` 的 `strategy_snapshot` 字段
   - 或者保存到 `hg_trading_robot_strategy_history` 表（历史记录）

**优点：**
- ✅ 职责清晰：用户配置 vs 历史记录
- ✅ 运行时只加载用户配置
- ✅ 历史记录可以独立管理

**缺点：**
- ⚠️ 需要数据库迁移

---

## 五、结论

### 5.1 静态配置的核心意义

1. **✅ 映射关系持久化**（必需）
   - 用户配置的映射关系需要保存到数据库
   - 引擎启动时加载，运行时使用

2. **✅ 策略组ID**（必需）
   - 用于查询策略模板
   - 优先级低于 `Robot.StrategyGroupId`

3. **⚠️ 策略参数快照**（可选）
   - 当前**不被运行时使用**
   - 主要用于历史记录和前端显示
   - 可以考虑精简或分离存储

### 5.2 推荐方案

**短期（当前）：**
- ✅ 保留映射关系和策略组ID（必需）
- ⚠️ 策略参数快照可以保留（用于前端显示），但不作为运行时数据

**长期（优化）：**
- ✅ 精简静态配置，只保存用户配置
- ✅ 策略参数快照可以保存到单独的字段或表（历史记录）

---

## 六、代码修改建议

### 6.1 精简静态配置（可选）

如果采用方案一，可以修改创建机器人的代码：

```go
// 构建精简的策略配置JSON（只保存用户配置）
strategyConfig := map[string]interface{}{
    // 策略组ID（优先使用前端传递的，否则使用推荐策略的）
    "groupId": in.StrategyGroupId,
}

if in.StrategyGroupId == 0 && strategy.GroupId > 0 {
    strategyConfig["groupId"] = strategy.GroupId
}

// 风险配置（包含映射关系）
if in.MarketRiskMapping != nil && len(in.MarketRiskMapping) > 0 {
    strategyConfig["riskConfig"] = map[string]interface{}{
        "marketRiskMapping": in.MarketRiskMapping,
    }
}
```

### 6.2 保持当前方案（推荐）

如果采用当前方案，不需要修改代码，只需要：
- ✅ 明确静态配置的作用（用户配置 + 历史记录）
- ✅ 运行时只使用映射关系和策略组ID
- ✅ 策略参数快照仅用于前端显示和历史记录

---

## 七、总结

**静态配置在机器人独立运行场景下的意义：**

1. **✅ 必需部分**：
   - 映射关系：用户配置的持久化
   - 策略组ID：用于查询策略模板

2. **⚠️ 可选部分**：
   - 策略参数快照：历史记录和前端显示（当前不被运行时使用）

3. **核心价值**：
   - 静态配置是**用户配置的持久化存储**
   - 运行时使用**动态配置**（从策略模板加载）
   - 静态配置和动态配置**职责分离**，确保数据一致性

