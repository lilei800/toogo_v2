# 反方向下单策略逻辑分析

## 一、策略概述

**反方向下单策略**：当机器人已有某个方向的持仓（如 LONG），如果市场出现反方向信号（如 SHORT），是否允许开反方向单的逻辑。

**目的：**
- 防止频繁反向开仓
- 控制风险，避免过度交易
- 根据持仓的回撤情况决定是否允许反向开仓

---

## 二、触发条件

### 2.1 基本条件

**位置：** `checkTradingConditions()` 和 `CheckAndOpenPositionWithSignal()`

```go
// 检查是否已有反方向持仓
hasOppositePosition := t.engine.HasActivePosition(oppositeSide)

if hasOppositePosition {
    // 1. 必须开启反向下单开关
    if robot.EnableReverseOrder != 1 {
        return false, "反向下单未开启"
    }
    
    // 2. 检查反向下单的回撤条件
    reason := t.checkReverseCondition(ctx, oppositeSide)
    if reason != "" {
        return false, reason
    }
}
```

**触发条件：**
1. ✅ 已有反方向持仓（`hasOppositePosition == true`）
2. ✅ 必须开启反向下单开关（`EnableReverseOrder == 1`）
3. ✅ 必须满足反向下单的回撤条件

---

## 三、回撤条件检查逻辑

### 3.1 checkReverseCondition 方法

**位置：** `robot_engine.go:2516`

**完整代码：**
```go
func (t *RobotTrader) checkReverseCondition(ctx context.Context, oppositeSide string) string {
    positions := t.engine.CurrentPositions
    if positions == nil {
        return ""  // 没有持仓，允许下单
    }
    
    // 获取反向下单阈值
    thresholds := GetReverseThresholds(t.engine.LastMarketState)
    
    // 遍历所有持仓，找到反方向持仓
    for _, pos := range positions {
        if pos.PositionAmt == 0 {
            continue
        }
        
        // 确定持仓方向
        positionSide := "LONG"
        if pos.PositionAmt < 0 {
            positionSide = "SHORT"
        }
        
        // 只处理反方向持仓
        if positionSide != oppositeSide {
            continue
        }
        
        // 获取持仓跟踪器
        t.engine.mu.RLock()
        tracker := t.engine.PositionTrackers[positionSide]
        t.engine.mu.RUnlock()
        
        if tracker == nil {
            continue
        }
        
        // 计算回撤百分比
        retreatPercent := float64(0)
        
        if pos.UnrealizedPnl < 0 {
            // ============ 亏损订单 ============
            // 从最低盈利（最大亏损）计算回撤
            // LowestProfit 存储的是最低盈利（负数表示亏损）
            if tracker.LowestProfit < 0 {
                retreatPercent = (pos.UnrealizedPnl - tracker.LowestProfit) / (-tracker.LowestProfit) * 100
            }
            
            // 检查亏损单回撤阈值
            if retreatPercent < thresholds.LossRetreat {
                return fmt.Sprintf("反向订单回撤不足，等待亏损回撤达到%.0f%%后允许(当前%.1f%%)",
                    thresholds.LossRetreat, retreatPercent)
            }
        } else {
            // ============ 盈利订单 ============
            // 从最高盈利计算回撤
            if tracker.HighestProfit > 0 {
                retreatPercent = (tracker.HighestProfit - pos.UnrealizedPnl) / tracker.HighestProfit * 100
            }
            
            // 检查盈利单回撤阈值
            if retreatPercent < thresholds.ProfitRetreat {
                return fmt.Sprintf("反向订单回撤不足，盈利部分回撤达到%.0f%%后允许(当前%.1f%%)",
                    thresholds.ProfitRetreat, retreatPercent)
            }
        }
    }
    
    return ""  // 条件满足，允许下单
}
```

---

### 3.2 回撤计算逻辑

#### 3.2.1 亏损订单的回撤计算

**公式：**
```go
retreatPercent = (pos.UnrealizedPnl - tracker.LowestProfit) / (-tracker.LowestProfit) * 100
```

**说明：**
- `pos.UnrealizedPnl` = 当前未实现盈亏（负数表示亏损）
- `tracker.LowestProfit` = 最低盈利（负数表示最大亏损）
- `-tracker.LowestProfit` = 最大亏损的绝对值

**示例：**
```
初始亏损：-100 USDT（LowestProfit = -100）
当前亏损：-50 USDT（UnrealizedPnl = -50）

回撤百分比 = (-50 - (-100)) / (-(-100)) × 100%
          = 50 / 100 × 100%
          = 50%

含义：从最大亏损 -100 回撤到 -50，回撤了 50%
```

**判断条件：**
```go
if retreatPercent < thresholds.LossRetreat {
    return "反向订单回撤不足，等待亏损回撤达到X%后允许(当前Y%)"
}
```

**含义：**
- ✅ 如果回撤百分比 ≥ `LossRetreat`，允许开反方向单
- ❌ 如果回撤百分比 < `LossRetreat`，不允许开反方向单

---

#### 3.2.2 盈利订单的回撤计算

**公式：**
```go
retreatPercent = (tracker.HighestProfit - pos.UnrealizedPnl) / tracker.HighestProfit * 100
```

**说明：**
- `tracker.HighestProfit` = 最高盈利（正数）
- `pos.UnrealizedPnl` = 当前未实现盈亏（正数表示盈利）

**示例：**
```
最高盈利：100 USDT（HighestProfit = 100）
当前盈利：60 USDT（UnrealizedPnl = 60）

回撤百分比 = (100 - 60) / 100 × 100%
          = 40 / 100 × 100%
          = 40%

含义：从最高盈利 100 回撤到 60，回撤了 40%
```

**判断条件：**
```go
if retreatPercent < thresholds.ProfitRetreat {
    return "反向订单回撤不足，盈利部分回撤达到X%后允许(当前Y%)"
}
```

**含义：**
- ✅ 如果回撤百分比 ≥ `ProfitRetreat`，允许开反方向单
- ❌ 如果回撤百分比 < `ProfitRetreat`，不允许开反方向单

---

## 四、反向下单阈值获取

### 4.1 GetReverseThresholds 函数

**位置：** `robot_engine.go:154`

**代码：**
```go
// ReverseThresholds 反向下单阈值
type ReverseThresholds struct {
    LossRetreat   float64 // 亏损订单回撤百分比
    ProfitRetreat float64 // 盈利订单回撤百分比
}

// GetReverseThresholds 根据市场状态获取反向下单阈值
func GetReverseThresholds(marketState string) *ReverseThresholds {
    switch marketState {
    case "trend":
        return &ReverseThresholds{LossRetreat: 50.0, ProfitRetreat: 100.0}
    case "volatile", "range":
        return &ReverseThresholds{LossRetreat: 0.0, ProfitRetreat: 0.0}
    case "high_vol", "high-volatility":
        return &ReverseThresholds{LossRetreat: 100.0, ProfitRetreat: 100.0}
    case "low_vol", "low-volatility":
        return &ReverseThresholds{LossRetreat: 0.0, ProfitRetreat: 0.0}
    default:
        return &ReverseThresholds{LossRetreat: 50.0, ProfitRetreat: 50.0}
    }
}
```

**阈值表：**

| 市场状态 | LossRetreat（亏损单回撤阈值） | ProfitRetreat（盈利单回撤阈值） | 说明 |
|---------|---------------------------|---------------------------|------|
| **trend**（趋势） | 50% | 100% | 亏损回撤50%或盈利回撤100%才允许反向开仓 |
| **volatile/range**（震荡） | 0% | 0% | 不限制反向开仓（回撤阈值=0表示不限制） |
| **high_vol**（高波动） | 100% | 100% | 亏损回撤100%或盈利回撤100%才允许反向开仓 |
| **low_vol**（低波动） | 0% | 0% | 不限制反向开仓 |
| **default**（默认） | 50% | 50% | 默认值 |

**关键点：**
- ✅ `LossRetreat = 0` 或 `ProfitRetreat = 0` 表示不限制（允许立即反向开仓）
- ✅ `LossRetreat > 0` 或 `ProfitRetreat > 0` 表示需要达到回撤阈值才允许反向开仓

---

### 4.2 策略模板配置（优先级更高）

**位置：** `robot_engine.go:626-657`

**方法：** `loadReverseThresholdsFromStrategy()`

**代码逻辑：**
```go
// 从策略模板的 config_json 中获取反向下单阈值
if strategy.ConfigJson != "" {
    var config map[string]interface{}
    if err := json.Unmarshal([]byte(strategy.ConfigJson), &config); err == nil {
        // 直接读取 reverse_loss_retreat 和 reverse_profit_retreat 字段
        if lr, ok := config["reverse_loss_retreat"].(float64); ok {
            result.LossRetreat = lr
        }
        if pr, ok := config["reverse_profit_retreat"].(float64); ok {
            result.ProfitRetreat = pr
        }
        // 如果配置了任一阈值，直接返回
        if result.LossRetreat > 0 || result.ProfitRetreat > 0 {
            return result
        }
    }
}

// 如果策略模板中没有配置，使用默认值
defaults := GetReverseThresholds(marketState)
result.LossRetreat = defaults.LossRetreat
result.ProfitRetreat = defaults.ProfitRetreat
return result
```

**优先级：**
1. ✅ **策略模板配置**（`config_json.reverse_loss_retreat` 和 `config_json.reverse_profit_retreat`）
2. ✅ **市场状态默认值**（`GetReverseThresholds(marketState)`）

**注意：** 
- ✅ 代码中实际使用的字段名是 `reverse_loss_retreat` 和 `reverse_profit_retreat`（下划线命名），位于 `config_json` 的根级别
- ⚠️ **重要发现**：`checkReverseCondition()` 方法中**未使用策略模板配置**，直接使用 `GetReverseThresholds()` 获取默认值
- ⚠️ **不一致**：`loadReverseThresholdsFromStrategy()` 方法存在但未被 `checkReverseCondition()` 调用

**策略模板配置格式：**
```json
{
  "reverse_loss_retreat": 50.0,
  "reverse_profit_retreat": 100.0
}
```

**注意：** 代码中实际使用的字段名是 `reverse_loss_retreat` 和 `reverse_profit_retreat`（下划线命名），而不是 `reverseThresholds.lossRetreat`（驼峰命名）。

---

## 五、完整流程

```
检查反方向下单策略
  ↓
1. 检查是否有反方向持仓
   ❌ 没有 → 允许下单
   ✅ 有 → 继续
  ↓
2. 检查反向下单开关
   ❌ EnableReverseOrder != 1 → 返回 "反向下单未开启"
   ✅ 继续
  ↓
3. 获取反向下单阈值
   优先级1：策略模板配置（config_json.reverseThresholds）
   优先级2：市场状态默认值（GetReverseThresholds）
  ↓
4. 获取持仓跟踪器
   tracker = PositionTrackers[oppositeSide]
  ↓
5. 判断持仓盈亏状态
   ↓
   5.1 亏损订单（UnrealizedPnl < 0）
       计算回撤：retreatPercent = (UnrealizedPnl - LowestProfit) / (-LowestProfit) × 100%
       判断：retreatPercent < LossRetreat？
         ❌ 是 → 返回 "反向订单回撤不足，等待亏损回撤达到X%后允许(当前Y%)"
         ✅ 否 → 允许下单
   ↓
   5.2 盈利订单（UnrealizedPnl >= 0）
       计算回撤：retreatPercent = (HighestProfit - UnrealizedPnl) / HighestProfit × 100%
       判断：retreatPercent < ProfitRetreat？
         ❌ 是 → 返回 "反向订单回撤不足，盈利部分回撤达到X%后允许(当前Y%)"
         ✅ 否 → 允许下单
  ↓
✅ 返回 ""（条件满足，允许下单）
```

---

## 六、代码与文档对比

### 6.1 文档中的描述

**文档位置：** `下单检查条件详细分析.md`

**文档描述：**
```
反向下单回撤条件（checkReverseCondition）：

亏损订单：
  最低亏损：-100 USDT
  当前亏损：-50 USDT
  回撤百分比 = (-50 - (-100)) / 100 × 100% = 50%
  
  如果 LossRetreat = 50%，则允许开反方向单
  如果 LossRetreat = 60%，则不允许（回撤不足）

盈利订单：
  最高盈利：100 USDT
  当前盈利：60 USDT
  回撤百分比 = (100 - 60) / 100 × 100% = 40%
  
  如果 ProfitRetreat = 40%，则允许开反方向单
  如果 ProfitRetreat = 50%，则不允许（回撤不足）
```

### 6.2 代码实际实现

**代码位置：** `robot_engine.go:2516-2572`

**实际逻辑：**

1. **亏损订单回撤计算：**
   ```go
   if tracker.LowestProfit < 0 {
       retreatPercent = (pos.UnrealizedPnl - tracker.LowestProfit) / (-tracker.LowestProfit) * 100
   }
   ```
   ✅ **与文档一致**

2. **盈利订单回撤计算：**
   ```go
   if tracker.HighestProfit > 0 {
       retreatPercent = (tracker.HighestProfit - pos.UnrealizedPnl) / tracker.HighestProfit * 100
   }
   ```
   ✅ **与文档一致**

3. **判断条件：**
   ```go
   // 亏损订单
   if retreatPercent < thresholds.LossRetreat {
       return "反向订单回撤不足..."
   }
   
   // 盈利订单
   if retreatPercent < thresholds.ProfitRetreat {
       return "反向订单回撤不足..."
   }
   ```
   ✅ **与文档一致**

### 6.3 差异点

**文档中未提及但代码中存在的逻辑：**

1. **策略模板配置优先级**
   - ✅ 代码中存在 `loadReverseThresholdsFromStrategy()` 方法，可以从策略模板获取阈值
   - ⚠️ **重要发现**：`checkReverseCondition()` 方法中**未使用策略模板配置**，直接使用 `GetReverseThresholds()` 获取默认值
   - ⚠️ **不一致**：`loadReverseThresholdsFromStrategy()` 方法存在但未被 `checkReverseCondition()` 调用
   - ❌ 文档中只提到了市场状态默认值
   - ⚠️ **字段名差异**：代码中使用 `reverse_loss_retreat`（下划线），文档中误写为 `reverseThresholds.lossRetreat`（驼峰）

2. **阈值 = 0 的特殊处理**
   - ✅ 代码中 `LossRetreat = 0` 或 `ProfitRetreat = 0` 表示不限制（立即允许反向开仓）
   - ❌ 文档中未明确说明

3. **持仓跟踪器为空的处理**
   - ✅ 代码中如果 `tracker == nil`，跳过检查（`continue`），不阻止下单
   - ❌ 文档中未提及

4. **两个相似方法的差异**
   - ✅ 代码中有两个方法：`checkReverseCondition()` 和 `shouldOpenReversePosition()`
   - ✅ `checkReverseCondition()` 用于下单条件检查，返回错误原因字符串
   - ✅ `shouldOpenReversePosition()` 用于判断是否应该开反方向持仓，返回布尔值
   - ⚠️ 两个方法的逻辑基本相同，但实现细节略有不同
   - ⚠️ **重要差异**：`shouldOpenReversePosition()` 中明确处理了 `阈值 = 0` 的情况，而 `checkReverseCondition()` 中没有

---

## 七、实际示例

### 7.1 示例1：亏损订单

**场景：**
- 市场状态：`trend`
- 反向下单阈值：`LossRetreat = 50%`
- 持仓：LONG（做多）
- 信号：SHORT（做空）

**持仓状态：**
- 初始亏损：-100 USDT（`LowestProfit = -100`）
- 当前亏损：-30 USDT（`UnrealizedPnl = -30`）

**计算：**
```
回撤百分比 = (-30 - (-100)) / (-(-100)) × 100%
          = 70 / 100 × 100%
          = 70%
```

**判断：**
```
70% >= 50% ✅
```

**结果：** ✅ **允许开反方向单**（回撤已达到50%）

---

### 7.2 示例2：盈利订单

**场景：**
- 市场状态：`trend`
- 反向下单阈值：`ProfitRetreat = 100%`
- 持仓：LONG（做多）
- 信号：SHORT（做空）

**持仓状态：**
- 最高盈利：100 USDT（`HighestProfit = 100`）
- 当前盈利：80 USDT（`UnrealizedPnl = 80`）

**计算：**
```
回撤百分比 = (100 - 80) / 100 × 100%
          = 20 / 100 × 100%
          = 20%
```

**判断：**
```
20% < 100% ❌
```

**结果：** ❌ **不允许开反方向单**（回撤未达到100%）

---

### 7.3 示例3：震荡市场（不限制）

**场景：**
- 市场状态：`volatile`
- 反向下单阈值：`LossRetreat = 0%`, `ProfitRetreat = 0%`
- 持仓：LONG（做多）
- 信号：SHORT（做空）

**持仓状态：**
- 当前亏损：-50 USDT（`UnrealizedPnl = -50`）

**判断：**
```
LossRetreat = 0% → 不限制
```

**结果：** ✅ **允许立即开反方向单**（震荡市场不限制）

---

## 八、关键代码位置

### 8.1 核心方法

1. **checkReverseCondition()** - 检查反向下单条件
   - 位置：`robot_engine.go:2516`
   - 作用：计算回撤并判断是否允许反向开仓

2. **GetReverseThresholds()** - 获取反向下单阈值
   - 位置：`robot_engine.go:154`
   - 作用：根据市场状态返回默认阈值

3. **策略模板配置解析** - 从策略模板获取阈值
   - 位置：`robot_engine.go:600-650`
   - 作用：优先使用策略模板配置的阈值

---

### 8.2 调用位置

1. **checkTradingConditions()** - 下单条件检查
   - 位置：`robot_engine.go:2397`
   - 调用：`checkReverseCondition(ctx, oppositeSide)`

2. **CheckAndOpenPositionWithSignal()** - 信号驱动下单
   - 位置：`robot_engine.go:2482`
   - 调用：`checkReverseCondition(ctx, oppositeSide)`

---

## 九、总结

### 9.1 策略逻辑

1. **触发条件：**
   - ✅ 已有反方向持仓
   - ✅ 开启反向下单开关
   - ✅ 满足回撤条件

2. **回撤计算：**
   - **亏损订单**：`(当前亏损 - 最低亏损) / |最低亏损| × 100%`
   - **盈利订单**：`(最高盈利 - 当前盈利) / 最高盈利 × 100%`

3. **阈值获取：**
   - 优先级1：策略模板配置（`config_json.reverseThresholds`）
   - 优先级2：市场状态默认值（`GetReverseThresholds(marketState)`）

4. **判断条件：**
   - 亏损订单：`回撤百分比 >= LossRetreat`
   - 盈利订单：`回撤百分比 >= ProfitRetreat`
   - 特殊值：`阈值 = 0` 表示不限制

### 9.2 代码与文档一致性

- ✅ **回撤计算公式**：代码与文档一致
- ✅ **判断逻辑**：代码与文档一致
- ⚠️ **阈值获取**：代码中有策略模板配置优先级，文档中未提及
- ⚠️ **特殊处理**：代码中有 `阈值 = 0` 的特殊处理，文档中未明确说明

### 9.3 代码与文档不一致的问题

**问题1：策略模板配置未被使用**
- ⚠️ `checkReverseCondition()` 方法中直接使用 `GetReverseThresholds()` 获取默认值
- ⚠️ 未调用 `loadReverseThresholdsFromStrategy()` 方法获取策略模板配置
- ⚠️ 导致策略模板中配置的反向下单阈值无法生效

**问题2：阈值 = 0 的处理不一致**
- ✅ `shouldOpenReversePosition()` 中明确处理了 `阈值 = 0` 的情况（立即允许）
- ❌ `checkReverseCondition()` 中没有处理 `阈值 = 0` 的情况

**问题3：两个方法的逻辑重复**
- ⚠️ `checkReverseCondition()` 和 `shouldOpenReversePosition()` 逻辑基本相同
- ⚠️ 建议统一为一个方法，避免代码重复

### 9.4 建议

1. **修复代码**：
   - ✅ 在 `checkReverseCondition()` 中使用 `loadReverseThresholdsFromStrategy()` 获取策略模板配置
   - ✅ 在 `checkReverseCondition()` 中添加 `阈值 = 0` 的特殊处理
   - ✅ 统一 `checkReverseCondition()` 和 `shouldOpenReversePosition()` 的逻辑

2. **更新文档**：
   - ✅ 补充策略模板配置优先级和 `阈值 = 0` 的特殊处理说明
   - ✅ 说明代码中实际使用的字段名（`reverse_loss_retreat`）

3. **代码注释**：
   - ✅ 在 `checkReverseCondition` 方法中添加更详细的注释，说明回撤计算逻辑
   - ✅ 说明策略模板配置的优先级

4. **日志优化**：
   - ✅ 在回撤计算时添加调试日志，方便排查问题
   - ✅ 记录使用的阈值来源（策略模板或默认值）

