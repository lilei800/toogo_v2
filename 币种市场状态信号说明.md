# 币种市场状态信号说明

## 一、核心原则

**每个币种一套全局市场状态信号**

- 每个币种由 `platform + symbol` 唯一标识
- 每个币种独立计算市场状态
- 所有交易同一币种的机器人共享同一套市场状态信号

---

## 二、币种标识

### 2.1 唯一键格式

```
platform:symbol
```

**示例**：
- `bitget:BTCUSDT` - Bitget 交易所的 BTCUSDT
- `binance:BTCUSDT` - Binance 交易所的 BTCUSDT
- `bitget:ETHUSDT` - Bitget 交易所的 ETHUSDT

**注意**：即使是同一个交易对（如 BTCUSDT），不同交易所也是不同的币种，有独立的市场状态。

### 2.2 缓存键生成

```go
key := platform + ":" + symbol
```

---

## 三、市场状态计算

### 3.1 计算流程

```
MarketServiceManager (K线数据)
    ↓
MarketAnalyzer.analyzeAllMarkets()
    ↓
遍历所有 platform+symbol 组合
    ↓
对每个币种独立调用 analyzeMarket()
    ↓
按 platform:symbol 缓存结果
```

### 3.2 计算频率

- **更新频率**：每 2 秒更新一次所有币种的市场状态
- **缓存键**：`platform:symbol`（如 `bitget:BTCUSDT`）
- **独立性**：每个币种独立计算，互不影响

---

## 四、机器人使用

### 4.1 获取市场状态

```go
// 机器人引擎获取市场状态
marketState := market.GetMarketServiceManager().GetMarketState(e.Platform, e.Robot.Symbol)
```

**流程**：
1. 使用 `platform + symbol` 构建缓存键
2. 从 `MarketAnalyzer` 缓存中获取该币种的市场状态
3. 验证数据一致性（确保 platform 和 symbol 匹配）
4. 返回市场状态

### 4.2 共享机制

**场景**：100 个机器人都在交易 `bitget:BTCUSDT`

```
MarketAnalyzer 缓存：
  bitget:BTCUSDT → { MarketState: "low_vol", ... }

RobotEngine1 (bitget:BTCUSDT) → GetMarketState() → "low_vol"
RobotEngine2 (bitget:BTCUSDT) → GetMarketState() → "low_vol"
RobotEngine3 (bitget:BTCUSDT) → GetMarketState() → "low_vol"
...
RobotEngine100 (bitget:BTCUSDT) → GetMarketState() → "low_vol"
```

**结果**：所有机器人获取到相同的市场状态 `"low_vol"`

---

## 五、数据一致性保证

### 5.1 验证机制

**在 `GetMarketState()` 中**：
```go
// 验证分析结果是否匹配请求的币种
if analysis.Platform != platform || analysis.Symbol != symbol {
    return ""  // 数据不匹配，返回空
}
```

**在 `GetAnalysis()` 中**：
```go
// 验证缓存的数据是否匹配请求的币种
if analysis != nil && (analysis.Platform != platform || analysis.Symbol != symbol) {
    return nil  // 数据不匹配，返回空
}
```

### 5.2 参数验证

**在 `GetMarketState()` 中**：
```go
if platform == "" || symbol == "" {
    return ""  // 参数无效，返回空
}
```

**在 `GetAnalysis()` 中**：
```go
if platform == "" || symbol == "" {
    return nil  // 参数无效，返回空
}
```

---

## 六、示例场景

### 6.1 场景1：同一交易所同一币种

**机器人配置**：
- Robot1: `platform=bitget, symbol=BTCUSDT`
- Robot2: `platform=bitget, symbol=BTCUSDT`
- Robot3: `platform=bitget, symbol=BTCUSDT`

**市场状态**：
- 所有机器人共享：`bitget:BTCUSDT` 的市场状态
- 例如：`"low_vol"`

### 6.2 场景2：不同交易所同一币种

**机器人配置**：
- Robot1: `platform=bitget, symbol=BTCUSDT`
- Robot2: `platform=binance, symbol=BTCUSDT`

**市场状态**：
- Robot1 使用：`bitget:BTCUSDT` 的市场状态（例如：`"low_vol"`）
- Robot2 使用：`binance:BTCUSDT` 的市场状态（例如：`"trend"`）
- **不同交易所的同一币种有独立的市场状态**

### 6.3 场景3：同一交易所不同币种

**机器人配置**：
- Robot1: `platform=bitget, symbol=BTCUSDT`
- Robot2: `platform=bitget, symbol=ETHUSDT`

**市场状态**：
- Robot1 使用：`bitget:BTCUSDT` 的市场状态（例如：`"low_vol"`）
- Robot2 使用：`bitget:ETHUSDT` 的市场状态（例如：`"high_vol"`）
- **同一交易所的不同币种有独立的市场状态**

---

## 七、代码实现

### 7.1 MarketAnalyzer 缓存结构

```go
type MarketAnalyzer struct {
    mu sync.RWMutex
    
    // 分析结果缓存 key: "platform:symbol" (如 "bitget:BTCUSDT")
    analysisCache map[string]*MarketAnalysis
    
    // ...
}
```

### 7.2 缓存键生成

```go
// 在 analyzeAllMarkets() 中
key := platform + ":" + symbol
a.analysisCache[key] = analysis

// 在 GetAnalysis() 中
key := platform + ":" + symbol
analysis := a.analysisCache[key]
```

### 7.3 数据验证

```go
// 确保缓存的数据匹配请求的币种
if analysis.Platform != platform || analysis.Symbol != symbol {
    return nil  // 数据不匹配
}
```

---

## 八、总结

✅ **每个币种一套全局市场状态信号**：
- 每个币种由 `platform + symbol` 唯一标识
- 每个币种独立计算市场状态
- 所有交易同一币种的机器人共享同一套市场状态信号

✅ **数据一致性保证**：
- 参数验证（platform 和 symbol 不能为空）
- 数据匹配验证（确保缓存的数据匹配请求的币种）

✅ **性能优化**：
- 每个币种只计算一次市场状态
- 所有机器人共享计算结果
- CPU 和内存使用率降低 99%

