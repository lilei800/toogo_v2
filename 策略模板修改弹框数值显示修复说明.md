# 策略模板修改弹框数值显示修复说明

## 问题描述

在"我的策略模板"页面点击"查看策略"后，再点击铅笔图标（编辑按钮）打开修改策略弹框时，弹框中显示的数值不正确，所有字段都显示为默认值而不是实际保存的值。

## 问题原因

### 根本原因
问题出在**前后端数据流转**上，涉及两个环节：

#### 1. 后端问题（主要原因）
在 `server/internal/controller/admin/trading/strategy_template.go` 文件中：

- **创建策略**（Create 函数）：
  - 前端提交的完整 `configJson`（包含 leverage、marginPercent 等所有参数）被后端忽略
  - 后端只保存了 `leverage_min/max`、`margin_percent_min/max`
  - 后端自己重新构建了只包含反向策略的 `configJson`，覆盖了前端提交的完整配置
  - 数据库的 `leverage` 和 `margin_percent` 字段没有被填充

- **更新策略**（Update 函数）：
  - 同样的问题，忽略前端提交的完整 `configJson`
  - 每次更新都会丢失 leverage、marginPercent 等推荐值

#### 2. 前端问题（次要原因）
在 `web/src/views/toogo/strategy/list.vue` 文件的 `editStrategy` 函数中：

- 数据读取优先级不合理
- 当 `configJson` 为空或不包含某些字段时，会回退到默认值而不是从 strategy 对象读取

### 数据流转说明

```
前端提交
  ↓
configJson (包含完整配置: leverage, marginPercent, 所有参数)
  ↓
后端接收 ← 问题1：后端忽略了前端的 configJson
  ↓
后端重新构建 configJson (只有反向策略配置)
  ↓
数据库保存 (leverage 和 marginPercent 字段为空)
  ↓
前端读取 ← 问题2：字段为空，回退到默认值
  ↓
显示错误的数值
```

## 修复方案

### 1. 修复后端（关键修复）

**文件**：`server/internal/controller/admin/trading/strategy_template.go`

#### 修复 Create 函数

**修改位置**：第 50-89 行

**修复内容**：
```go
// Create 创建策略模板
func (c *cStrategyTemplate) Create(ctx context.Context, req *trading.StrategyTemplateCreateReq) (res *trading.StrategyTemplateCreateRes, err error) {
	// 使用前端提交的完整 configJson（包含所有手动配置参数）
	configJsonStr := req.ConfigJson
	if configJsonStr == "" {
		// 如果前端没有提供 configJson，则构建一个基础的
		configJson := map[string]interface{}{
			"reverseEnabled":     req.ReverseEnabled,
			"reverseLossRatio":   req.ReverseLossRatio,
			"reverseProfitRatio": req.ReverseProfitRatio,
		}
		configJsonBytes, _ := json.Marshal(configJson)
		configJsonStr = string(configJsonBytes)
	}

	// 从 configJson 中解析出 leverage 和 marginPercent（用于直接字段）
	var configData map[string]interface{}
	leverage := req.LeverageMin // 默认使用 Min 值
	marginPercent := req.MarginPercentMin
	if err := json.Unmarshal([]byte(configJsonStr), &configData); err == nil {
		if lev, ok := configData["leverage"].(float64); ok {
			leverage = int(lev)
		}
		if margin, ok := configData["marginPercent"].(float64); ok {
			marginPercent = margin
		}
	}

	data := g.Map{
		"group_id":                   req.GroupId,
		"strategy_key":               req.StrategyKey,
		"strategy_name":              req.StrategyName,
		"risk_preference":            req.RiskPreference,
		"market_state":               req.MarketState,
		"monitor_window":             req.MonitorWindow,
		"volatility_threshold":       req.VolatilityThreshold,
		"leverage":                   leverage,           // ← 新增：保存推荐值
		"margin_percent":             marginPercent,      // ← 新增：保存推荐值
		"stop_loss_percent":          req.StopLossPercent,
		"profit_retreat_percent":     req.ProfitRetreatPercent,
		"auto_start_retreat_percent": req.AutoStartRetreatPercent,
		"config_json":                configJsonStr,      // ← 修改：使用前端提交的完整 JSON
		"description":                req.Description,
		"is_active":                  req.IsActive,
		"sort":                       req.Sort,
		"created_at":                 gtime.Now(),
		"updated_at":                 gtime.Now(),
	}
	// ... 后续代码
}
```

**关键改进**：
- ✅ 使用前端提交的完整 `configJson`，不再覆盖
- ✅ 从 `configJson` 中提取 `leverage` 和 `marginPercent` 保存到数据库直接字段
- ✅ 确保数据库的 `leverage` 和 `margin_percent` 字段有值

#### 修复 Update 函数

**修改位置**：第 95-131 行

**修复内容**：类似 Create 函数的修复

### 2. 修复前端（辅助修复）

**文件**：`web/src/views/toogo/strategy/list.vue`

#### 修复 editStrategy 函数

**修改位置**：第 505-545 行

**修复内容**：
```typescript
// 编辑策略
function editStrategy(strategy: any) {
  editingStrategy.value = strategy;
  
  console.log('编辑策略 - 原始数据:', strategy);
  
  // 解析 config_json
  let configJson: any = {};
  try {
    configJson = strategy.configJson ? (typeof strategy.configJson === 'string' ? JSON.parse(strategy.configJson) : strategy.configJson) : {};
  } catch (error) {
    console.warn('解析 configJson 失败:', error);
  }

  console.log('编辑策略 - configJson:', configJson);

  // 多层级读取策略：优先 strategy 直接字段 → configJson → 默认值
  formData.value = {
    strategyName: strategy.strategyName || '',
    marketState: strategy.marketState || 'trend',
    riskPreference: strategy.riskPreference || 'balanced',
    tradeType: strategy.tradeType || configJson.tradeType || 'perpetual',
    orderType: strategy.orderType || configJson.orderType || 'market',
    marginMode: strategy.marginMode || configJson.marginMode || 'isolated',
    monitorWindow: strategy.monitorWindow || configJson.monitorWindow || 300,
    volatilityThreshold: parseFloat(strategy.volatilityThreshold) || configJson.volatilityThreshold || 100,
    // 杠杆和保证金：优先从 strategy 直接字段读取，然后 configJson，最后默认值
    leverage: strategy.leverage || configJson.leverage || strategy.leverageMin || 8,
    marginPercent: strategy.marginPercent || configJson.marginPercent || parseFloat(strategy.marginPercentMin) || 12,
    // 止损止盈：优先从 strategy 直接字段读取
    stopLossPercent: parseFloat(strategy.stopLossPercent) || configJson.stopLossPercent || 5,
    autoStartRetreatPercent: parseFloat(strategy.autoStartRetreatPercent) || configJson.autoStartRetreatPercent || 3,
    profitRetreatPercent: parseFloat(strategy.profitRetreatPercent) || configJson.profitRetreatPercent || 25,
    // 反向策略
    reverseEnabled: configJson.reverseEnabled !== undefined ? configJson.reverseEnabled : true,
    reverseLossRatio: configJson.reverseLossRatio || 50,
    reverseProfitRatio: configJson.reverseProfitRatio || 100,
    description: strategy.description || '',
  };
  
  console.log('编辑策略 - formData:', formData.value);
  
  showDrawer.value = true;
}
```

**关键改进**：
- ✅ 添加了原始数据的日志输出，便于调试
- ✅ 优先从 `strategy` 对象直接字段读取（后端修复后会有值）
- ✅ 增加了多层级回退机制：直接字段 → configJson → 默认值
- ✅ 添加了详细的调试日志

## 测试验证

### 测试步骤

#### 步骤 1：重启后端服务
```bash
# 后端已重新编译，需要重启服务
cd server
./main.exe
```

#### 步骤 2：创建新策略测试
1. 导航到：我的策略模板 → 点击"查看策略"
2. 点击"添加策略"按钮
3. 填写策略信息，特别注意设置：
   - 杠杆倍数：例如 10x
   - 保证金比例：例如 15%
   - 其他参数
4. 点击"保存"

#### 步骤 3：验证编辑功能
1. 找到刚创建的策略卡片
2. 点击铅笔图标（编辑按钮）
3. **关键验证**：检查弹框中的数值是否与创建时填写的一致
4. 查看浏览器控制台日志：
   ```
   编辑策略 - 原始数据: {...}
   编辑策略 - configJson: {...}
   编辑策略 - formData: {...}
   ```

#### 步骤 4：修改并再次验证
1. 修改某些数值（如杠杆从 10 改为 12）
2. 点击"保存"
3. 再次点击编辑按钮
4. 验证新修改的值是否正确显示

#### 步骤 5：验证已有策略
对于之前创建的策略（数据库中 leverage 和 margin_percent 字段为空的）：
1. 编辑时会从 configJson 读取
2. 保存后会更新数据库字段
3. 之后编辑就能正确显示了

### 验证字段清单

需要验证的字段：
- ✅ 杠杆倍数（leverage）- **核心字段**
- ✅ 保证金比例（marginPercent）- **核心字段**
- ✅ 交易类型（tradeType）
- ✅ 订单类型（orderType）
- ✅ 保证金模式（marginMode）
- ✅ 监控窗口（monitorWindow）
- ✅ 波动阈值（volatilityThreshold）
- ✅ 止损百分比（stopLossPercent）
- ✅ 启动止盈（autoStartRetreatPercent）
- ✅ 止盈回撤（profitRetreatPercent）
- ✅ 反向策略配置（reverseEnabled, reverseLossRatio, reverseProfitRatio）

## 预期效果

修复后：
1. ✅ **新建策略**：所有字段正确保存到数据库（leverage 和 margin_percent 字段有值）
2. ✅ **编辑策略**：弹框显示的数值与之前保存的数值一致
3. ✅ **已有策略**：通过多层级读取机制，从 configJson 读取数值
4. ✅ **再次保存**：已有策略保存后会更新数据库字段
5. ✅ **调试日志**：控制台清晰显示数据流转过程

## 修复的文件

### 后端文件
- `server/internal/controller/admin/trading/strategy_template.go`
  - Create 函数（创建策略）
  - Update 函数（更新策略）

### 前端文件
- `web/src/views/toogo/strategy/list.vue`
  - editStrategy 函数（编辑策略时的数据加载）

## 技术细节

### 数据库表结构

```sql
-- trading_strategy_template 表
CREATE TABLE `hg_trading_strategy_template` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `group_id` bigint DEFAULT NULL COMMENT '策略组ID',
  `strategy_key` varchar(100) DEFAULT NULL COMMENT '策略KEY',
  `strategy_name` varchar(100) DEFAULT NULL COMMENT '策略名称',
  `risk_preference` varchar(50) DEFAULT NULL COMMENT '风险偏好',
  `market_state` varchar(50) DEFAULT NULL COMMENT '市场状态',
  
  -- 新增字段（修复后会有值）
  `leverage` int DEFAULT NULL COMMENT '杠杆倍数（推荐值）',
  `margin_percent` decimal(10,2) DEFAULT NULL COMMENT '保证金比例（推荐值）',
  
  -- 其他字段
  `stop_loss_percent` decimal(10,2) DEFAULT NULL,
  `profit_retreat_percent` decimal(10,2) DEFAULT NULL,
  `auto_start_retreat_percent` decimal(10,2) DEFAULT NULL,
  
  -- 完整配置（JSON格式）
  `config_json` text COMMENT '完整配置JSON',
  
  PRIMARY KEY (`id`)
);
```

### configJson 结构

修复后，`config_json` 字段包含完整的策略配置：

```json
{
  "tradeType": "perpetual",
  "orderType": "market",
  "marginMode": "isolated",
  "leverage": 10,                    // 实际使用的杠杆
  "marginPercent": 15,               // 实际使用的保证金比例
  "stopLossPercent": 5,
  "autoStartRetreatPercent": 3,
  "profitRetreatPercent": 25,
  "monitorWindow": 300,
  "volatilityThreshold": 100,
  "reverseEnabled": true,
  "reverseLossRatio": 50,
  "reverseProfitRatio": 100,
  "trailingStop": false
}
```

### 数据读取优先级

修复后的前端读取逻辑：

```
1. strategy.leverage (数据库直接字段) ← 优先
2. configJson.leverage (JSON配置) ← 备用
3. strategy.leverageMin (范围最小值) ← 兜底
4. 8 (硬编码默认值) ← 最后
```

这样确保了：
- 新策略：直接从数据库字段读取（最快）
- 旧策略：从 configJson 读取（兼容性）
- 异常情况：有合理的默认值

## 注意事项

1. **向后兼容**：
   - 旧数据（leverage 和 margin_percent 字段为空）仍能正常工作
   - 通过 configJson 读取
   - 重新保存后会更新数据库字段

2. **数据一致性**：
   - `leverage` 字段 = `configJson.leverage`
   - `margin_percent` 字段 = `configJson.marginPercent`
   - 后端自动保持同步

3. **前端提交**：
   - 前端必须提交完整的 `configJson`
   - 后端会从中提取关键字段保存到数据库

4. **调试支持**：
   - 添加了详细的 console.log 便于排查问题
   - 生产环境可以注释掉

## 常见问题

### Q1: 为什么既要保存到 configJson 又要保存到数据库字段？
**A**: 
- configJson：保存完整配置，便于扩展和版本管理
- 数据库字段：便于查询、统计和快速读取
- 两者互为备份，提高系统稳健性

### Q2: 旧数据会自动迁移吗？
**A**: 
- 不会自动迁移
- 但读取时有多层级回退机制，旧数据仍能正常显示
- 用户下次编辑保存后，会自动更新数据库字段

### Q3: 如果 configJson 解析失败怎么办？
**A**: 
- 前端有 try-catch 保护，会回退到数据库字段
- 后端在提取字段时也有错误处理
- 最坏情况下使用默认值，不会崩溃

## 修复日期

2025年12月5日

---

**状态**: ✅ 已完成修复（前后端）
**后端编译**: ✅ 成功
**需要重启**: ⚠️ 需要重启后端服务才能生效
