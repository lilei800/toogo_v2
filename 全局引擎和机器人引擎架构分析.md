# 全局引擎和机器人引擎架构分析

## 一、架构概览

### 1.1 整体架构图

```
┌─────────────────────────────────────────────────────────────┐
│                    全局引擎层 (Global Layer)                  │
├─────────────────────────────────────────────────────────────┤
│                                                               │
│  ┌─────────────────────────────────────────────────────┐   │
│  │      RobotTaskManager (全局任务管理器 - 单例)        │   │
│  │  - 管理所有机器人引擎的生命周期                        │   │
│  │  - 同步机器人状态（每5秒）                            │   │
│  │  - 健康检查（每30秒）                                  │   │
│  │  - 定时启停机器人                                      │   │
│  └─────────────────────────────────────────────────────┘   │
│                          │                                   │
│                          │ 管理                              │
│                          ▼                                   │
│  ┌─────────────────────────────────────────────────────┐   │
│  │      MarketServiceManager (行情服务管理器 - 单例)      │   │
│  │  - 管理所有交易所的行情服务                            │   │
│  │  - WebSocket/HTTP轮询                                 │   │
│  │  - 订阅管理（引用计数）                                │   │
│  └─────────────────────────────────────────────────────┘   │
│                          │                                   │
│                          │ 提供数据                           │
│                          ▼                                   │
│  ┌─────────────────────────────────────────────────────┐   │
│  │      MarketDataService (行情数据服务 - 单例)         │   │
│  │  - K线数据缓存（多周期）                              │   │
│  │  - Ticker数据缓存                                     │   │
│  │  - 订单簿缓存                                         │   │
│  └─────────────────────────────────────────────────────┘   │
│                          │                                   │
│                          │ 同步                               │
│                          ▼                                   │
│  ┌─────────────────────────────────────────────────────┐   │
│  │   OrderStatusSyncService (订单状态同步服务 - 单例)    │   │
│  │  - 同步交易所订单状态到本地数据库                      │   │
│  │  - 智能同步（有持仓3秒，无持仓30秒）                   │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                               │
└─────────────────────────────────────────────────────────────┘
                          │
                          │ 创建和管理
                          ▼
┌─────────────────────────────────────────────────────────────┐
│                   机器人引擎层 (Robot Layer)                  │
├─────────────────────────────────────────────────────────────┤
│                                                               │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐   │
│  │ RobotEngine1 │  │ RobotEngine2 │  │ RobotEngineN  │   │
│  │              │  │              │  │              │   │
│  │ - Analyzer   │  │ - Analyzer   │  │ - Analyzer   │   │
│  │ - SignalGen  │  │ - SignalGen  │  │ - SignalGen  │   │
│  │ - Trader     │  │ - Trader     │  │ - Trader     │   │
│  │              │  │              │  │              │   │
│  │ 主循环:       │  │ 主循环:       │  │ 主循环:       │   │
│  │ - 交易检查    │  │ - 交易检查    │  │ - 交易检查    │   │
│  │ - 市场分析    │  │ - 市场分析    │  │ - 市场分析    │   │
│  │ - 信号生成    │  │ - 信号生成    │  │ - 信号生成    │   │
│  │ - 账户同步    │  │ - 账户同步    │  │ - 账户同步    │   │
│  └──────────────┘  └──────────────┘  └──────────────┘   │
│                                                               │
└─────────────────────────────────────────────────────────────┘
```

---

## 二、全局引擎架构（RobotTaskManager）

### 2.1 设计模式

**单例模式** + **管理器模式** + **观察者模式**

- **单例模式**：确保全局只有一个 `RobotTaskManager` 实例
- **管理器模式**：统一管理所有机器人引擎的生命周期
- **观察者模式**：监听数据库状态变化，自动创建/销毁引擎

---

### 2.2 核心组件

#### 2.2.1 RobotTaskManager

**职责**：
- 管理所有机器人引擎的生命周期（创建、启动、停止、更新）
- 同步机器人状态（每5秒从数据库查询）
- 健康检查（每30秒检查所有引擎）
- 定时启停机器人（根据 `schedule_start` 和 `schedule_stop`）

**关键数据结构**：
```go
type RobotTaskManager struct {
    mu sync.RWMutex
    
    // 运行中的机器人引擎 key: robotId
    engines map[int64]*RobotEngine
    
    // 运行状态
    running bool
    stopCh  chan struct{}
}
```

**核心方法**：
- `Start(ctx)` - 启动任务管理器
- `Stop()` - 停止任务管理器
- `syncRobots(ctx)` - 同步机器人状态（每5秒）
- `checkEnginesHealth(ctx)` - 健康检查（每30秒）
- `initRobotEngine(ctx, robot)` - 初始化机器人引擎
- `GetEngine(robotId)` - 获取机器人引擎
- `UpdateRobot(robot)` - 更新机器人配置

---

#### 2.2.2 依赖的全局服务

**1. MarketServiceManager（行情服务管理器）**
- **职责**：管理所有交易所的行情服务
- **设计**：每个交易所一个 `ExchangeMarketService` 实例
- **功能**：
  - WebSocket/HTTP轮询行情数据
  - 订阅管理（引用计数，多个机器人共享同一交易对）
  - 自动重连机制

**2. MarketDataService（行情数据服务）**
- **职责**：缓存和管理行情数据
- **数据结构**：
  ```go
  type MarketDataService struct {
      tickers     map[string]*TickerData      // key: platform:symbol
      klines      map[string]*KlineCache      // key: platform:symbol
      orderBooks  map[string]*OrderBookData   // key: platform:symbol
  }
  ```
- **功能**：
  - K线数据缓存（1m, 5m, 15m, 30m, 1h, 1d）
  - Ticker数据缓存
  - 订单簿缓存

**3. OrderStatusSyncService（订单状态同步服务）**
- **职责**：同步交易所订单状态到本地数据库
- **智能同步策略**：
  - 有持仓的机器人：每3秒同步（需要实时监控止损止盈）
  - 无持仓的机器人：每30秒同步（不重要，可以延迟）

**4. VolatilityConfigManager（波动率配置管理器）**
- **职责**：管理市场波动率配置
- **功能**：提供波动率阈值和权重配置

---

### 2.3 工作流程

#### 2.3.1 启动流程

```
1. RobotTaskManager.Start()
   ├─> 启动 VolatilityConfigManager
   ├─> 启动 MarketServiceManager
   ├─> 启动 OrderStatusSyncService
   └─> 启动 runSyncTask goroutine
       ├─> 每5秒执行 syncRobots()
       └─> 每30秒执行 checkEnginesHealth()
```

---

#### 2.3.2 同步流程（每5秒）

```
syncRobots()
├─> 处理定时启停机器人
│   ├─> 查找需要启动的机器人（status=1 且 schedule_start <= now）
│   └─> 查找需要停止的机器人（status=2 且 schedule_stop <= now）
│
├─> 查询数据库（status=2 的机器人）
│
├─> 构建活跃ID映射
│
├─> 更新已存在的机器人
│   └─> engine.UpdateRobot(robot)
│
├─> 创建新机器人引擎
│   ├─> initRobotEngine() - 初始化引擎
│   ├─> engine.Start() - 启动引擎
│   └─> 添加到 engines map
│
└─> 停止已删除的机器人
    ├─> engine.Stop() - 停止引擎
    └─> 从 engines map 删除
```

---

#### 2.3.3 健康检查流程（每30秒）

```
checkEnginesHealth()
├─> 获取所有引擎
├─> 并发检查（限制并发数10）
│   └─> engine.HealthCheck()
│       ├─> 检查运行状态
│       ├─> 检查最后更新时间
│       └─> 检查错误计数
└─> 记录不健康的引擎（不自动重启，由管理员决定）
```

---

### 2.4 优化特性

#### 2.4.1 效率优化

1. **减少锁持有时间**
   - 数据库查询在锁外执行
   - 引擎创建/停止在锁外执行
   - 只在更新 `engines` map 时持有锁

2. **并发健康检查**
   - 使用信号量限制并发数（最多10个）
   - 避免同时检查过多引擎导致API请求过载

3. **智能同步**
   - 只同步有持仓的机器人（每3秒）
   - 无持仓的机器人延迟同步（每30秒）

---

#### 2.4.2 健壮性优化

1. **Panic恢复**
   - `runSyncTask` 添加 panic 恢复机制
   - 确保单个引擎异常不影响全局引擎

2. **优雅停止**
   - 停止时先停止所有机器人引擎
   - 再停止全局服务
   - 确保资源正确释放

---

## 三、机器人引擎架构（RobotEngine）

### 3.1 设计模式

**独立引擎模式** + **模块化设计** + **事件驱动**

- **独立引擎模式**：每个机器人一个独立的引擎实例
- **模块化设计**：Analyzer、SignalGen、Trader 三个独立模块
- **事件驱动**：基于定时器的事件驱动主循环

---

### 3.2 核心组件

#### 3.2.1 RobotEngine 结构

**基础配置**：
```go
type RobotEngine struct {
    Robot     *entity.TradingRobot      // 机器人配置
    APIConfig *entity.TradingApiConfig  // API配置
    Platform  string                    // 交易所平台
    Exchange  exchange.Exchange          // 交易所API实例
}
```

**核心模块**：
```go
Analyzer  *RobotAnalyzer   // 市场分析模块
SignalGen *RobotSignalGen  // 信号生成模块
Trader    *RobotTrader     // 交易执行模块
```

**状态缓存**：
```go
LastTicker       *exchange.Ticker        // 最新行情
LastKlines       *market.KlineCache       // 最新K线（引用全局缓存）
LastAnalysis     *RobotMarketAnalysis    // 最新分析结果
LastSignal       *RobotSignal            // 最新方向信号
CurrentPositions []*exchange.Position    // 当前持仓
AccountBalance   *exchange.Balance       // 账户余额
```

**持仓跟踪**：
```go
PositionTrackers map[string]*PositionTracker  // key: PositionSide
```

**价格窗口监控**：
```go
PriceWindow      []PricePoint        // 窗口内价格序列（最多10000个）
SignalHistory    []SignalHistoryItem // 信号历史（最多100条）
MonitorConfig    *MonitorConfig      // 监控配置
```

**市场状态与策略配置**：
```go
LastMarketState       string            // 上次检测到的市场状态
MarketRiskMapping     map[string]string // 市场状态 → 风险偏好映射
CurrentStrategyParams *StrategyParams   // 当前使用的策略参数
VolatilityConfig      *VolatilityConfig // 波动率配置
```

**运行状态**：
```go
running bool
stopCh  chan struct{}
```

**锁机制**：
```go
mu        sync.RWMutex  // 主锁（保护大部分状态）
orderLock sync.Mutex    // 订单锁（保护订单操作）
closeLock sync.Mutex    // 平仓锁（保护平仓操作）
priceLock sync.RWMutex  // 价格窗口锁（保护价格窗口数据）
```

---

#### 3.2.2 核心模块

**1. RobotAnalyzer（市场分析模块）**

**职责**：
- 多周期K线分析（1m, 5m, 15m, 1h, 1d）
- 技术指标计算（MACD, EMA, RSI等）
- 市场状态判断（trend/volatile/high_vol/low_vol）
- 趋势强度计算

**关键方法**：
- `Analyze(ctx)` - 执行市场分析
- `analyzeTimeframe(timeframe)` - 分析单个周期
- `determineMarketState()` - 判断市场状态
- `calculateBaselineVolatility()` - 计算基准波动率

---

**2. RobotSignalGen（信号生成模块）**

**职责**：
- 基于市场分析结果生成交易信号
- 窗口价格监控（toogo实时信号逻辑）
- 信号强度计算
- 信号置信度评估

**关键方法**：
- `GenerateSignal(ctx)` - 生成交易信号
- `checkWindowSignal()` - 检查窗口信号
- `checkAnalysisSignal()` - 检查分析信号

---

**3. RobotTrader（交易执行模块）**

**职责**：
- 执行开仓操作
- 执行平仓操作（止损/止盈）
- 检查交易条件
- 订单状态同步

**关键方法**：
- `TryAutoTrade(ctx, signal)` - 尝试自动交易
- `executeOpen(ctx, signal)` - 执行开仓
- `executeClose(ctx, pos)` - 执行平仓
- `checkTradingConditions(ctx)` - 检查交易条件

---

### 3.3 工作流程

#### 3.3.1 启动流程

```
RobotEngine.Start()
├─> 订阅行情（MarketServiceManager.Subscribe）
├─> 主动获取历史K线数据（MarketDataService.RefreshKlines）
└─> 启动主循环（runMainLoop goroutine）
```

---

#### 3.3.2 主循环流程（每500ms）

```
runMainLoop()
├─> 每500ms执行一次
│
├─> doTradingCheck() - 交易检查
│   ├─> 检查持仓是否需要平仓（止损/止盈）
│   └─> 执行平仓操作
│
├─> 每1秒执行一次（tickCount % 2 == 0）
│   ├─> doAnalysis() - 市场分析
│   │   ├─> 获取Ticker数据（从全局缓存）
│   │   ├─> 获取K线数据（从全局缓存）
│   │   ├─> 加载波动率配置
│   │   └─> Analyzer.Analyze() - 执行分析
│   │
│   └─> doSignalGeneration() - 信号生成
│       ├─> SignalGen.GenerateSignal() - 生成信号
│       ├─> 检查交易条件
│       └─> Trader.TryAutoTrade() - 尝试自动交易
│
└─> 每10秒执行一次（tickCount % 20 == 0）
    └─> syncAccountDataIfNeeded() - 账户数据同步
        ├─> 同步持仓数据
        ├─> 同步账户余额
        └─> 更新 PositionTrackers
```

---

#### 3.3.3 市场分析流程

```
doAnalysis()
├─> 获取Ticker数据（MarketServiceManager.GetTicker）
├─> 获取K线数据（MarketServiceManager.GetMultiTimeframeKlines）
├─> 加载波动率配置（VolatilityConfigManager）
└─> Analyzer.Analyze()
    ├─> 多周期分析
    │   ├─> analyzeTimeframe("1m")
    │   ├─> analyzeTimeframe("5m")
    │   ├─> analyzeTimeframe("15m")
    │   ├─> analyzeTimeframe("1h")
    │   └─> analyzeTimeframe("1d")
    │
    ├─> 计算基准波动率
    │   └─> calculateBaselineVolatilityMultiTimeframe()
    │
    ├─> 判断市场状态
    │   └─> determineMarketState() - 加权投票机制
    │
    └─> 更新策略参数
        └─> updateStrategyParams() - 根据市场状态加载策略参数
```

---

#### 3.3.4 信号生成流程

```
doSignalGeneration()
├─> SignalGen.GenerateSignal()
│   ├─> 检查窗口信号（checkWindowSignal）
│   │   ├─> 分析价格窗口（PriceWindow）
│   │   ├─> 计算窗口内最高/最低价
│   │   └─> 判断信号方向（long/short）
│   │
│   └─> 检查分析信号（checkAnalysisSignal）
│       ├─> 基于市场分析结果
│       └─> 判断信号方向（LONG/SHORT/NEUTRAL）
│
├─> 保存信号预警记录（saveSignalAlertSimple）
│   └─> 无论是否自动下单，都保存预警记录
│
└─> Trader.TryAutoTrade()
    ├─> 检查交易条件（checkTradingConditions）
    │   ├─> 同步订单状态（OrderStatusSyncService.SyncSingleRobot）
    │   ├─> 检查自动下单是否开启
    │   ├─> 检查账户余额
    │   └─> 检查同一方向是否已有订单
    │
    └─> 执行开仓（executeOpen）
        ├─> 计算下单数量
        ├─> 调用交易所API下单
        ├─> 创建 PositionTracker
        └─> 异步同步订单状态
```

---

#### 3.3.5 交易检查流程（每500ms）

```
doTradingCheck()
├─> 遍历当前持仓（CurrentPositions）
│
└─> 对每个持仓执行检查
    ├─> 获取 PositionTracker
    ├─> 检查是否需要平仓（shouldClose）
    │   ├─> 检查止损条件
    │   │   └─> |未实现盈亏| / 保证金 >= 止损百分比
    │   │
    │   ├─> 检查止盈条件
    │   │   ├─> 启动止盈：未实现盈亏 / 保证金 >= 启动止盈百分比
    │   │   └─> 止盈回撤：(最高盈利 - 当前盈亏) / 最高盈利 >= 止盈回撤百分比
    │   │
    │   └─> 更新最高盈利（HighestProfit）
    │
    └─> 执行平仓（executeClose）
        ├─> 调用交易所API平仓
        ├─> 清理 PositionTracker
        └─> 异步同步订单状态
```

---

### 3.4 数据流

#### 3.4.1 行情数据流

```
交易所API
    │
    ▼
MarketServiceManager (WebSocket/HTTP轮询)
    │
    ▼
MarketDataService (缓存)
    │
    ├─> Ticker数据 ──> RobotEngine.LastTicker
    │
    └─> K线数据 ──> RobotEngine.LastKlines (引用)
        │
        └─> Analyzer.Analyze() ──> LastAnalysis
```

---

#### 3.4.2 交易信号流

```
LastAnalysis (市场分析结果)
    │
    ▼
SignalGen.GenerateSignal()
    │
    ├─> 窗口信号（PriceWindow）
    │
    └─> 分析信号（LastAnalysis）
        │
        ▼
LastSignal (交易信号)
    │
    ▼
Trader.TryAutoTrade()
    │
    ├─> 检查交易条件
    │
    └─> executeOpen() ──> 交易所API下单
```

---

#### 3.4.3 订单状态流

```
交易所API
    │
    ▼
OrderStatusSyncService.SyncSingleRobot()
    │
    ├─> 查询交易所订单状态
    │
    └─> 更新本地数据库
        │
        └─> RobotEngine.CurrentPositions (同步)
```

---

### 3.5 优化特性

#### 3.5.1 效率优化

1. **统一主循环**
   - 将4个独立循环合并为1个主循环
   - 减少75%的goroutine数量
   - 降低goroutine切换开销

2. **价格窗口优化**
   - 限制价格窗口大小（最多10000个点）
   - 使用二分查找修剪过期数据（O(log n)）
   - 快速返回优化（无需修剪时O(1)）

3. **信号历史优化**
   - 限制信号历史大小（最多100条）
   - 自动清理过期数据

4. **K线数据共享**
   - 引用全局缓存，不重复存储
   - 减少内存占用

---

#### 3.5.2 健壮性优化

1. **Panic恢复**
   - `runMainLoop` 添加 panic 恢复机制
   - `doAnalysis` 添加 panic 恢复机制
   - 确保单个模块异常不影响整个引擎

2. **锁机制**
   - 细粒度锁（orderLock, closeLock, priceLock）
   - 读写锁（priceLock）提高并发性能
   - 避免死锁（锁顺序一致）

3. **错误处理**
   - 记录同步错误（LastSyncError, SyncErrorCount）
   - 健康检查机制（HealthCheck）

---

## 四、架构优势

### 4.1 全局引擎优势

1. **统一管理**
   - 单例模式，全局统一管理
   - 集中式生命周期管理
   - 易于监控和调试

2. **资源共享**
   - 行情数据共享（MarketDataService）
   - 减少API调用次数
   - 降低内存占用

3. **智能同步**
   - 有持仓的机器人快速同步（3秒）
   - 无持仓的机器人延迟同步（30秒）
   - 平衡实时性和性能

---

### 4.2 机器人引擎优势

1. **独立运行**
   - 每个机器人独立引擎实例
   - 互不干扰，故障隔离
   - 易于扩展和维护

2. **模块化设计**
   - Analyzer、SignalGen、Trader 三个独立模块
   - 职责清晰，易于测试
   - 便于功能扩展

3. **高效主循环**
   - 统一主循环，减少goroutine开销
   - 定时任务合并，提高效率
   - 优化数据结构和算法

---

## 五、架构改进建议

### 5.1 短期优化（高优先级）

1. **API调用频率限制器**
   - 防止超过交易所限制
   - 实现令牌桶算法

2. **批量数据库查询**
   - 减少数据库交互
   - 提高数据库性能

3. **异步执行市场分析**
   - 不阻塞主循环
   - 提高响应速度

---

### 5.2 中期优化（中优先级）

1. **压缩历史数据**
   - 减少内存占用
   - 支持更多机器人

2. **连接池优化**
   - 数据库连接池配置
   - 交易所API连接池

3. **性能监控系统**
   - 实时监控指标
   - 告警机制

---

### 5.3 长期优化（低优先级）

1. **分布式架构**
   - 多服务器部署
   - 负载均衡
   - 状态同步（Redis/etcd）

2. **微服务架构**
   - 市场分析服务
   - 信号生成服务
   - 交易执行服务

3. **事件驱动架构**
   - 消息队列（RabbitMQ/Kafka）
   - 事件总线
   - 异步处理

---

## 六、总结

### 6.1 架构特点

- **分层架构**：全局引擎层 + 机器人引擎层
- **单例模式**：全局服务使用单例模式
- **独立引擎**：每个机器人独立引擎实例
- **模块化设计**：Analyzer、SignalGen、Trader 三个模块
- **事件驱动**：基于定时器的事件驱动主循环
- **资源共享**：行情数据共享，减少API调用

### 6.2 性能指标

- **单机支持**：1000-3000个机器人
- **内存占用**：单个机器人 ~810KB
- **Goroutine数量**：单个机器人 1个常驻 + 0-4个临时
- **CPU占用**：单个机器人 ~0.5-1%单核

### 6.3 优化状态

- ✅ **已完成**：统一主循环、价格窗口限制、信号历史限制、panic恢复、健康检查
- 🔄 **待实施**：API频率限制、批量查询、异步分析、分布式架构

