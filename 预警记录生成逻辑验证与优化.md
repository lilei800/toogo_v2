# 预警记录生成逻辑验证与优化

## 一、当前逻辑分析

### 1.1 信号检测流程

**调用频率**：
- `doAnalysis()` 每500毫秒执行一次
- `EvaluateWindowSignal()` 在 `doAnalysis()` 中被调用
- 每次调用都会检测信号

**当前保存逻辑**：
```go
// 只在信号方向变化时保存预警记录
isNewDirection := newSignal != e.LastWindowSignal
if isNewDirection {
    logId := e.saveSignalAlertSimple(&signalCopy)
}
```

**问题**：
- ❌ 只有当信号方向变化时才保存（如：neutral → LONG）
- ❌ 如果信号持续存在（如：一直是LONG），不会重复保存
- ❌ 不符合"每次预警信号产生，都产生一条预警记录"的需求

---

## 二、用户需求分析

**用户需求**：
> 验证出现下单信号后，根据每次预警信号产生，也产生一条预警记录

**理解**：
- ✅ 每次检测到预警信号（非neutral），都应该保存一条预警记录
- ✅ 即使信号方向不变，只要信号存在，也应该保存
- ✅ 但需要避免重复保存（如：同一秒内多次保存）

---

## 三、优化方案

### 3.1 方案A：每次信号检测都保存（不推荐）

**问题**：
- ❌ 如果每500ms检测一次，信号持续存在，会每秒保存2条记录
- ❌ 可能产生大量重复记录

### 3.2 方案B：基于时间间隔保存（推荐）

**核心思想**：
- ✅ 每次检测到信号（非neutral）时，检查上次保存时间
- ✅ 如果距离上次保存超过一定时间（如1秒），才保存新记录
- ✅ 避免重复保存，同时确保每次信号产生都有记录

**实现**：
```go
// 添加字段：上次保存预警记录的时间
LastAlertSaveTime time.Time

// 检查逻辑
if newSignal != "neutral" {
    // 检查是否需要保存（距离上次保存超过1秒，或信号方向变化）
    shouldSave := false
    if newSignal != e.LastWindowSignal {
        // 信号方向变化，必须保存
        shouldSave = true
    } else if time.Since(e.LastAlertSaveTime) >= 1*time.Second {
        // 信号方向不变，但距离上次保存超过1秒，也保存
        shouldSave = true
    }
    
    if shouldSave {
        logId := e.saveSignalAlertSimple(&signalCopy)
        e.LastAlertSaveTime = time.Now()
        e.LastWindowSignal = newSignal
    }
}
```

### 3.3 方案C：基于信号触发保存（最推荐）

**核心思想**：
- ✅ 使用 `LastAlertedLong` 和 `LastAlertedShort` 标记
- ✅ 当信号触发时（`longTriggered` 或 `shortTriggered`），检查是否需要保存
- ✅ 如果基准价变化或首次触发，保存预警记录

**当前逻辑**：
```go
if longTriggered {
    newSignal = "long"
    if e.LastAlertedLong == nil || math.Abs(minPrice-*e.LastAlertedLong) > 0.0001 {
        e.LastAlertedLong = &minPrice
        // 这里应该保存预警记录
    }
}
```

**问题**：
- ❌ 当前逻辑中，`LastAlertedLong` 更新了，但没有保存预警记录
- ❌ 预警记录的保存是在后面的 `isNewDirection` 判断中

---

## 四、推荐优化方案

### 4.1 方案：基于信号触发 + 时间间隔

**核心思想**：
1. ✅ 信号方向变化时，必须保存
2. ✅ 信号持续存在时，如果距离上次保存超过一定时间（如1秒），也保存
3. ✅ 避免重复保存，同时确保每次信号产生都有记录

**实现**：
```go
// 添加字段
LastAlertSaveTime time.Time  // 上次保存预警记录的时间

// 修改保存逻辑
if newSignal != "neutral" {
    signalCopy := *signal
    isNewDirection := newSignal != e.LastWindowSignal
    
    // 判断是否需要保存
    shouldSave := false
    if isNewDirection {
        // 信号方向变化，必须保存
        shouldSave = true
    } else if time.Since(e.LastAlertSaveTime) >= 1*time.Second {
        // 信号方向不变，但距离上次保存超过1秒，也保存（确保每次信号产生都有记录）
        shouldSave = true
    }
    
    if shouldSave {
        logId := e.saveSignalAlertSimple(&signalCopy)
        if logId > 0 {
            e.LastAlertSaveTime = time.Now()
            e.LastWindowSignal = newSignal
        }
    }
}
```

---

## 五、验证要点

### 5.1 验证场景

**场景1：信号方向变化**
- neutral → LONG：应该保存1条记录 ✅
- LONG → SHORT：应该保存1条记录 ✅
- SHORT → neutral：不保存（neutral不保存）✅

**场景2：信号持续存在**
- LONG信号持续2秒：应该保存2条记录（每1秒1条）✅
- LONG信号持续5秒：应该保存5条记录（每1秒1条）✅

**场景3：避免重复保存**
- 500ms内多次检测到LONG：只保存1条（时间间隔限制）✅
- 1秒内多次检测到LONG：只保存1条 ✅

---

## 六、总结

### 6.1 当前问题

❌ **只在信号方向变化时保存**：
- 如果信号持续存在，不会重复保存
- 不符合"每次预警信号产生，都产生一条预警记录"的需求

### 6.2 优化方案

✅ **基于信号触发 + 时间间隔**：
- 信号方向变化时，必须保存
- 信号持续存在时，每1秒保存一次
- 避免重复保存，同时确保每次信号产生都有记录

### 6.3 实现建议

1. ✅ 添加 `LastAlertSaveTime` 字段
2. ✅ 修改保存逻辑：方向变化或时间间隔超过1秒时保存
3. ✅ 确保每次预警信号产生都有记录

