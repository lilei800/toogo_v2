# 自动止损逻辑检查报告

## 需求回顾

**需求**：单个订单最大止损百分比
- 当 `|未实现盈亏| / (保证金 × 设置的百分比) ≥ 100%` 时，自动执行平仓（止损）

**公式等价性验证**：
- 需求公式：`|未实现盈亏| / (保证金 × 止损百分比) ≥ 100%`
- 等价于：`|未实现盈亏| / 保证金 ≥ 止损百分比 × 100%`
- 等价于：`|未实现盈亏| / 保证金 × 100% ≥ 止损百分比`
- 当前实现：`lossPercent = |未实现盈亏| / 保证金 × 100%`，当 `lossPercent >= stopLossPercent` 时触发
- ✅ **公式等价，实现正确**

---

## 当前实现分析

### 代码位置
- **文件**：`server/internal/logic/toogo/robot_engine.go`
- **方法**：`shouldClose()` (2855-3017行)
- **止损检查**：2943-2951行

---

## 逻辑流程检查

### ✅ 1. 参数获取（2891-2941行）

```go
// 【重要】只使用订单创建时的策略参数，确保策略一致性
// 查询订单创建时的策略参数
var stopLossPercent, takeProfitStart, profitRetreatPercent float64
orderData, err := dao.TradingOrder.Ctx(ctx).
    Fields("stop_loss_percent", "auto_start_retreat_percent", "profit_retreat_percent").
    Where("robot_id", robot.Id).
    Where("symbol", pos.Symbol).
    Where("direction", func() string {
        if pos.PositionSide == "LONG" {
            return "long"
        }
        return "short"
    }()).
    Where("status", 1). // 持仓中
    OrderDesc("created_at").
    One()

if err == nil && !orderData.IsEmpty() {
    // 从订单中获取策略参数
    if val := orderData["stop_loss_percent"]; val != nil {
        if v := val.Float64(); v > 0 {
            stopLossPercent = v
        }
    }
    // ...
}

// 如果订单中没有策略参数，记录错误并使用默认值（不应该发生）
if stopLossPercent <= 0 {
    g.Log().Errorf(ctx, "[RobotTrader] 订单缺少策略参数: ...")
    stopLossPercent = 10 // 默认止损10%
}
```

**检查结果**：✅ **正确**
- ✅ 只使用订单创建时的策略参数（符合需求）
- ✅ 如果订单中没有参数，使用默认值并记录错误（兜底机制）
- ✅ 参数来源正确：从订单表查询 `stop_loss_percent`

---

### ✅ 2. 保证金获取（2882-2889行）

```go
margin := tracker.EntryMargin
if margin <= 0 {
    margin = pos.IsolatedMargin
}
// 优先使用计算的保证金
if pos.Margin > 0 {
    margin = pos.Margin
}
```

**优先级顺序**：
1. `pos.Margin`（交易所返回的保证金，最准确）
2. `pos.IsolatedMargin`（交易所返回的逐仓保证金）
3. `tracker.EntryMargin`（开仓时记录的保证金）

**检查结果**：✅ **正确**
- ✅ 优先使用交易所返回的最新保证金数据
- ✅ 有降级方案，确保总能获取到保证金值

---

### ✅ 3. 止损检查（2943-2951行）

```go
// 止损检查
if margin > 0 && pos.UnrealizedPnl < 0 {
    lossPercent := math.Abs(pos.UnrealizedPnl) / margin * 100
    if lossPercent >= stopLossPercent {
        g.Log().Infof(ctx, "[RobotTrader] 触发止损: robotId=%d, side=%s, 亏损=%.4f, 保证金=%.4f, 亏损比例=%.2f%% >= %.2f%% (参数来源: 订单创建时)",
            robot.Id, pos.PositionSide, pos.UnrealizedPnl, margin, lossPercent, stopLossPercent)
        return true
    }
}
```

**检查结果**：✅ **正确**

**逻辑验证**：
1. ✅ 检查保证金 > 0（避免除零错误）
2. ✅ 检查未实现盈亏 < 0（只有亏损才触发止损）
3. ✅ 计算亏损比例：`|未实现盈亏| / 保证金 × 100%`
4. ✅ 判断：`亏损比例 >= 止损百分比` → 触发平仓
5. ✅ 日志记录详细，包含所有关键信息

**公式验证**：
- 需求：`|未实现盈亏| / (保证金 × 止损百分比) ≥ 100%`
- 当前：`|未实现盈亏| / 保证金 × 100% ≥ 止损百分比`
- ✅ **公式等价**

---

## 示例验证

### 示例1：正常止损触发

**假设条件**：
- 保证金：100 USDT
- 止损百分比：10%（订单创建时的策略参数）
- 未实现盈亏：-12 USDT（亏损）

**计算过程**：
```
亏损比例 = |(-12)| / 100 × 100% = 12%
判断：12% >= 10% → ✅ 触发止损
```

**代码执行**：
```go
lossPercent := math.Abs(-12) / 100 * 100  // = 12
if 12 >= 10 {  // ✅ true
    return true  // 触发平仓
}
```

**结果**：✅ **正确触发止损**

---

### 示例2：未达到止损阈值

**假设条件**：
- 保证金：100 USDT
- 止损百分比：10%
- 未实现盈亏：-8 USDT（亏损）

**计算过程**：
```
亏损比例 = |(-8)| / 100 × 100% = 8%
判断：8% < 10% → ❌ 不触发止损
```

**代码执行**：
```go
lossPercent := math.Abs(-8) / 100 * 100  // = 8
if 8 >= 10 {  // ❌ false
    // 不触发，继续监控
}
```

**结果**：✅ **正确，未触发止损**

---

### 示例3：盈利状态不触发止损

**假设条件**：
- 保证金：100 USDT
- 止损百分比：10%
- 未实现盈亏：+5 USDT（盈利）

**代码执行**：
```go
if margin > 0 && pos.UnrealizedPnl < 0 {  // +5 < 0 → false
    // 不执行止损检查
}
```

**结果**：✅ **正确，盈利状态不触发止损**

---

### 示例4：保证金为0的情况

**假设条件**：
- 保证金：0 USDT（异常情况）
- 未实现盈亏：-10 USDT

**代码执行**：
```go
if margin > 0 && pos.UnrealizedPnl < 0 {  // 0 > 0 → false
    // 不执行止损检查，避免除零错误
}
```

**结果**：✅ **正确，避免除零错误**

---

## 潜在问题检查

### ⚠️ 问题1：保证金获取的准确性

**当前逻辑**：
```go
margin := tracker.EntryMargin  // 优先级3
if margin <= 0 {
    margin = pos.IsolatedMargin  // 优先级2
}
if pos.Margin > 0 {
    margin = pos.Margin  // 优先级1
}
```

**潜在问题**：
- `pos.Margin` 可能为 0（某些交易所不返回）
- `pos.IsolatedMargin` 可能为 0（非逐仓模式）
- `tracker.EntryMargin` 可能为 0（旧数据或异常情况）

**建议**：
- 如果所有保证金来源都为 0，应该记录错误并跳过止损检查
- 或者使用订单表中的保证金记录作为最后兜底

**当前处理**：✅ **已有降级方案，但可以优化**

---

### ✅ 问题2：止损检查频率

**当前实现**：每500ms检查一次（在主循环中）

**检查结果**：✅ **合理**
- 频率足够高，能及时响应止损
- 不会过度消耗资源

---

### ✅ 问题3：止损与止盈的优先级

**当前实现**：
1. 先检查止损（2943-2951行）
2. 再检查启动止盈（2953-2965行）
3. 最后检查止盈回撤（2967-2978行）

**检查结果**：✅ **正确**
- 止损优先级最高（保护资金安全）
- 逻辑顺序合理

---

## 代码优化建议

### 建议1：增强保证金获取的健壮性

**当前代码**（2882-2889行）：
```go
margin := tracker.EntryMargin
if margin <= 0 {
    margin = pos.IsolatedMargin
}
if pos.Margin > 0 {
    margin = pos.Margin
}
```

**建议优化**：
```go
// 获取保证金（优先级：交易所返回 > 开仓时记录 > 订单表记录）
margin := 0.0
if pos.Margin > 0 {
    margin = pos.Margin  // 优先级1：交易所返回的保证金
} else if pos.IsolatedMargin > 0 {
    margin = pos.IsolatedMargin  // 优先级2：逐仓保证金
} else if tracker.EntryMargin > 0 {
    margin = tracker.EntryMargin  // 优先级3：开仓时记录的保证金
} else {
    // 优先级4：从订单表查询（最后兜底）
    // 如果仍然为0，记录错误并跳过止损检查
    g.Log().Warningf(ctx, "[RobotTrader] 无法获取保证金: robotId=%d, side=%s，跳过止损检查",
        robot.Id, pos.PositionSide)
    // 可以尝试从订单表查询保证金
    // ...
}

if margin <= 0 {
    // 无法获取保证金，跳过止损检查
    g.Log().Warningf(ctx, "[RobotTrader] 保证金为0，跳过止损检查: robotId=%d, side=%s",
        robot.Id, pos.PositionSide)
    // 不执行止损检查，但继续执行其他检查（如止盈）
}
```

---

### 建议2：添加止损前的最后确认

**当前实现**：直接触发平仓

**建议**：可以添加一个小的缓冲（如0.1%），避免因价格微小波动导致频繁触发

```go
// 止损检查（添加0.1%的缓冲，避免频繁触发）
if margin > 0 && pos.UnrealizedPnl < 0 {
    lossPercent := math.Abs(pos.UnrealizedPnl) / margin * 100
    // 添加0.1%的缓冲，确保真正达到阈值才触发
    if lossPercent >= stopLossPercent && lossPercent >= stopLossPercent+0.1 {
        g.Log().Infof(ctx, "[RobotTrader] 触发止损: robotId=%d, side=%s, 亏损=%.4f, 保证金=%.4f, 亏损比例=%.2f%% >= %.2f%%",
            robot.Id, pos.PositionSide, pos.UnrealizedPnl, margin, lossPercent, stopLossPercent)
        return true
    }
}
```

**注意**：这个建议是可选的，当前实现已经足够准确。

---

## 总结

| 检查项 | 状态 | 说明 |
|--------|------|------|
| 公式正确性 | ✅ | 公式等价，实现正确 |
| 参数来源 | ✅ | 使用订单创建时的策略参数 |
| 保证金获取 | ✅ | 有优先级和降级方案 |
| 止损条件 | ✅ | 逻辑正确，包含安全检查 |
| 日志记录 | ✅ | 详细完整 |
| 检查频率 | ✅ | 每500ms检查一次，合理 |
| 优先级顺序 | ✅ | 止损优先级最高 |

---

## 结论

**当前止损逻辑实现正确，符合需求。**

**主要优点**：
1. ✅ 公式等价，计算正确
2. ✅ 参数来源正确（订单创建时的策略参数）
3. ✅ 有完善的错误处理和日志记录
4. ✅ 安全检查完善（避免除零错误）

**可选优化**：
1. 增强保证金获取的健壮性（添加订单表查询作为最后兜底）
2. 添加止损缓冲（可选，避免频繁触发）

**建议**：当前实现已经足够，可以保持现状。如果需要更高的健壮性，可以考虑优化保证金获取逻辑。

