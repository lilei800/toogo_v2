# 自动下单计算逻辑分析

## 一、整体流程

```
主循环（每500ms）：
  doTradingCheck()
    ↓
检查开仓：
  CheckAndOpenPosition()
    ↓
检查下单条件：
  checkTradingConditions()
    ↓
执行开仓：
  executeOpen()
    ↓
计算下单参数：
  - 杠杆：从策略模板获取
  - 保证金比例：从策略模板获取
  - 下单数量：根据保证金和杠杆计算
    ↓
下单：
  Exchange.CreateOrder()
```

---

## 二、触发机制

### 2.1 定时检查

**位置：** `robot_engine.go` - `runMainLoop()`

```go
// 每500ms: 交易检查（核心高频任务）
e.doTradingCheck(ctx)

// doTradingCheck 交易检查（开仓/平仓）
func (e *RobotEngine) doTradingCheck(ctx context.Context) {
    // 检查平仓
    go e.checkClosePosition(ctx)
    
    // 检查开仓
    go e.checkOpenPosition(ctx)
}
```

**频率：** 每500ms检查一次

---

### 2.2 信号驱动

**位置：** `robot_engine.go` - `doSignalGeneration()`

```go
// 每1秒: 市场分析 + 信号生成
if tickCount%2 == 0 {
    e.doAnalysis(ctx)
    e.doSignalGeneration(ctx)  // ← 生成信号
}

// doSignalGeneration 信号生成
func (e *RobotEngine) doSignalGeneration(ctx context.Context) {
    signal := e.SignalGen.GenerateSignal(ctx)
    if signal != nil {
        // 保存信号并尝试下单
        e.saveSignalAlert(ctx, signal)
    }
}
```

**频率：** 每1秒生成一次信号

---

## 三、下单条件检查

### 3.1 checkTradingConditions 方法

**位置：** `robot_engine.go` - `checkTradingConditions()`

```go
func (t *RobotTrader) checkTradingConditions(ctx context.Context, signal *RobotSignal) (bool, string) {
    robot := t.engine.Robot
    
    // 1. 检查是否开启自动交易
    if robot.AutoTradeEnabled != 1 {
        return false, "自动下单未开启"
    }
    
    // 2. 检查信号操作
    if signal.Action != "OPEN_LONG" && signal.Action != "OPEN_SHORT" {
        return false, fmt.Sprintf("信号类型为%s，不是开仓信号", signal.Action)
    }
    
    // 3. 检查是否已有该方向持仓
    positionSide := "LONG"
    oppositeSide := "SHORT"
    if signal.Direction == "SHORT" {
        positionSide = "SHORT"
        oppositeSide = "LONG"
    }
    
    hasCurrentPosition := t.engine.HasActivePosition(positionSide)
    hasOppositePosition := t.engine.HasActivePosition(oppositeSide)
    
    // 每方向最多1单
    if hasCurrentPosition {
        return false, "该方向已有持仓"
    }
    
    // 4. 反方向下单策略
    if hasOppositePosition {
        if robot.EnableReverseOrder != 1 {
            return false, "反向下单未开启"
        }
        reason := t.checkReverseCondition(ctx, oppositeSide)
        if reason != "" {
            return false, reason
        }
    }
    
    // 5. 检查算力
    if !t.checkPower(ctx) {
        return false, "算力不足，请充值"
    }
    
    // 6. 检查余额
    balance := t.engine.AccountBalance
    if balance == nil || balance.AvailableBalance <= 0 {
        return false, "保证金余额不足"
    }
    
    return true, ""
}
```

**检查项：**
1. ✅ 自动交易开关（`AutoTradeEnabled == 1`）
2. ✅ 信号类型（`OPEN_LONG` 或 `OPEN_SHORT`）
3. ✅ 是否已有该方向持仓（每方向最多1单）
4. ✅ 反方向下单策略（如果开启，检查回撤条件）
5. ✅ 算力是否充足（至少1点算力）
6. ✅ 余额是否充足（可用余额 > 0）

---

## 四、下单参数计算

### 4.1 executeOpen 方法

**位置：** `robot_engine.go` - `executeOpen()`

#### 4.1.1 获取策略参数

```go
// 1. 获取策略参数（从策略模板动态加载）
strategyParams := t.engine.CurrentStrategyParams
if strategyParams == nil {
    // 重新加载策略参数
    marketState := t.engine.LastMarketState
    if marketState == "" && t.engine.LastAnalysis != nil {
        marketState = normalizeMarketState(t.engine.LastAnalysis.MarketState)
    }
    
    // 从映射关系获取风险偏好
    riskPref := t.engine.MarketRiskMapping[marketState]
    if riskPref == "" {
        riskPref = robot.RiskPreference
    }
    
    strategyParams, err = t.engine.loadFullStrategyParams(ctx, marketState, riskPref)
}
```

**关键点：**
- ✅ 从策略模板动态加载参数
- ✅ 使用映射关系获取风险偏好
- ✅ 如果缓存中没有，重新加载

---

#### 4.1.2 计算杠杆和保证金比例

```go
// 使用杠杆范围的中值
leverage := (strategyParams.LeverageMin + strategyParams.LeverageMax) / 2
if leverage <= 0 {
    leverage = 10  // 默认10倍
}

// 使用保证金比例范围的中值
marginPercent := (strategyParams.MarginPercentMin + strategyParams.MarginPercentMax) / 2
if marginPercent <= 0 {
    marginPercent = 10  // 默认10%
}
```

**计算公式：**
- **杠杆** = `(LeverageMin + LeverageMax) / 2`
- **保证金比例** = `(MarginPercentMin + MarginPercentMax) / 2`

---

#### 4.1.3 计算保证金和下单数量

```go
// 计算保证金：可用余额 × 保证金比例%
margin := balance.AvailableBalance * marginPercent / 100

// 检查最小订单金额：订单金额 = margin * leverage，应该至少 5 USDT
minOrderValue := 5.0
orderValue := margin * float64(leverage)
if orderValue < minOrderValue {
    return gerror.Newf("订单金额不足: 计算金额=%.2f USDT < 最小金额=%.2f USDT", orderValue, minOrderValue)
}

// 计算下单数量：订单金额 / 当前价格
quantity := margin * float64(leverage) / ticker.LastPrice

// 检查最小下单数量：至少 0.0001
minQuantity := 0.0001
if quantity < minQuantity {
    return gerror.Newf("订单数量不足: 计算数量=%.6f < 最小值=%.4f", quantity, minQuantity)
}
```

**计算公式：**
1. **保证金** = `可用余额 × 保证金比例%`
2. **订单金额** = `保证金 × 杠杆`
3. **下单数量** = `订单金额 / 当前价格`

**验证：**
- ✅ 订单金额 ≥ 5 USDT（最小订单金额）
- ✅ 下单数量 ≥ 0.0001（最小下单数量）

---

## 五、下单执行

### 5.1 设置杠杆

```go
// 设置杠杆
_ = t.engine.Exchange.SetLeverage(ctx, robot.Symbol, leverage)
```

---

### 5.2 确定方向

```go
// 确定方向
side := "BUY"
positionSide := "LONG"
if signal.Direction == "SHORT" {
    side = "SELL"
    positionSide = "SHORT"
}
```

---

### 5.3 创建订单

```go
// 下单
order, err := t.engine.Exchange.CreateOrder(ctx, &exchange.OrderRequest{
    Symbol:       robot.Symbol,
    Side:         side,           // BUY/SELL
    PositionSide: positionSide,  // LONG/SHORT
    Type:         "MARKET",       // 市价单
    Quantity:     quantity,       // 下单数量
})
```

---

### 5.4 更新内存持仓

```go
// 【重要】开仓成功后立即更新内存中的持仓信息
t.engine.mu.Lock()
// 初始化持仓跟踪器
t.engine.PositionTrackers[positionSide] = &PositionTracker{
    PositionSide: positionSide,
    EntryMargin:  margin,
    EntryTime:    time.Now(),
}
// 更新 CurrentPositions
t.engine.CurrentPositions = append(t.engine.CurrentPositions, &exchange.Position{
    Symbol:        robot.Symbol,
    PositionSide:  positionSide,
    PositionAmt:   positionAmt,
    EntryPrice:    entryPrice,
    IsolatedMargin: margin,
    UnrealizedPnl: 0,
})
t.engine.mu.Unlock()
```

**关键点：**
- ✅ 立即更新内存持仓，避免下次检查时误判
- ✅ 初始化 `PositionTracker`，用于跟踪最高盈利

---

### 5.5 记录订单

```go
// 记录订单（传递策略参数）
t.recordOrder(ctx, order, signal, currentStrategyParams, leverage, marginPercent)
```

**保存的策略参数：**
- `stop_loss_percent`
- `auto_start_retreat_percent`
- `profit_retreat_percent`
- `margin_percent`

---

## 六、完整计算示例

### 6.1 示例数据

```
可用余额：100 USDT
策略模板参数：
  - LeverageMin: 10
  - LeverageMax: 10
  - MarginPercentMin: 10%
  - MarginPercentMax: 10%
当前价格：96000 USDT
```

### 6.2 计算过程

```
1. 计算杠杆：
   leverage = (10 + 10) / 2 = 10倍

2. 计算保证金比例：
   marginPercent = (10 + 10) / 2 = 10%

3. 计算保证金：
   margin = 100 × 10% = 10 USDT

4. 计算订单金额：
   orderValue = 10 × 10 = 100 USDT

5. 验证订单金额：
   orderValue (100) ≥ minOrderValue (5) ✅

6. 计算下单数量：
   quantity = 100 / 96000 = 0.00104167 BTC

7. 验证下单数量：
   quantity (0.00104167) ≥ minQuantity (0.0001) ✅

8. 下单：
   - 方向：LONG（做多）
   - 类型：MARKET（市价单）
   - 数量：0.00104167 BTC
   - 杠杆：10倍
```

---

## 七、关键逻辑总结

### 7.1 参数来源

| 参数 | 来源 | 说明 |
|------|------|------|
| **杠杆** | 策略模板（`LeverageMin/Max`） | 使用范围的中值 |
| **保证金比例** | 策略模板（`MarginPercentMin/Max`） | 使用范围的中值 |
| **止损百分比** | 策略模板（`StopLossPercent`） | 直接使用 |
| **启动止盈百分比** | 策略模板（`AutoStartRetreatPercent`） | 直接使用 |
| **止盈回撤百分比** | 策略模板（`ProfitRetreatPercent`） | 直接使用 |

---

### 7.2 计算步骤

1. **获取策略参数**
   - 从策略模板动态加载
   - 使用映射关系获取风险偏好

2. **计算杠杆和保证金比例**
   - 杠杆 = `(LeverageMin + LeverageMax) / 2`
   - 保证金比例 = `(MarginPercentMin + MarginPercentMax) / 2`

3. **计算保证金**
   - 保证金 = `可用余额 × 保证金比例%`

4. **计算订单金额**
   - 订单金额 = `保证金 × 杠杆`

5. **验证订单金额**
   - 订单金额 ≥ 5 USDT

6. **计算下单数量**
   - 下单数量 = `订单金额 / 当前价格`

7. **验证下单数量**
   - 下单数量 ≥ 0.0001

8. **执行下单**
   - 设置杠杆
   - 创建市价单
   - 更新内存持仓
   - 记录订单

---

### 7.3 验证条件

**下单前验证：**
- ✅ 自动交易开关开启
- ✅ 信号类型正确（`OPEN_LONG` 或 `OPEN_SHORT`）
- ✅ 该方向没有持仓
- ✅ 反方向下单条件满足（如果开启）
- ✅ 算力充足
- ✅ 余额充足

**计算后验证：**
- ✅ 订单金额 ≥ 5 USDT
- ✅ 下单数量 ≥ 0.0001

---

## 八、数据流向

```
市场分析：
  实时价格 → 窗口价格监控 → 生成信号
    ↓
信号生成：
  方向信号（LONG/SHORT） → 保存信号日志
    ↓
下单检查：
  检查条件 → checkTradingConditions()
    ↓
参数计算：
  策略模板 → 杠杆、保证金比例
  可用余额 → 保证金
  保证金 × 杠杆 → 订单金额
  订单金额 / 价格 → 下单数量
    ↓
下单执行：
  设置杠杆 → 创建订单 → 更新内存持仓 → 记录订单
```

---

## 九、关键代码位置

### 9.1 核心方法

1. **doTradingCheck()** - 交易检查入口
   - 位置：`robot_engine.go:1046`
   - 频率：每500ms

2. **CheckAndOpenPosition()** - 检查并开仓
   - 位置：`robot_engine.go:2345`
   - 作用：定时检查信号并尝试下单

3. **checkTradingConditions()** - 检查下单条件
   - 位置：`robot_engine.go:2367`
   - 作用：验证是否满足下单条件

4. **executeOpen()** - 执行开仓
   - 位置：`robot_engine.go:2677`
   - 作用：计算参数并执行下单

---

### 9.2 参数计算

**杠杆和保证金比例：**
```go
leverage := (strategyParams.LeverageMin + strategyParams.LeverageMax) / 2
marginPercent := (strategyParams.MarginPercentMin + strategyParams.MarginPercentMax) / 2
```

**保证金和下单数量：**
```go
margin := balance.AvailableBalance * marginPercent / 100
orderValue := margin * float64(leverage)
quantity := margin * float64(leverage) / ticker.LastPrice
```

---

## 十、总结

### 10.1 自动下单流程

1. **触发**：每500ms检查一次，或信号生成时触发
2. **条件检查**：验证自动交易开关、持仓状态、算力、余额等
3. **参数计算**：从策略模板获取参数，计算杠杆、保证金、下单数量
4. **验证**：验证订单金额和下单数量是否满足最小值
5. **执行**：设置杠杆、创建订单、更新内存持仓、记录订单

### 10.2 关键特点

- ✅ **动态参数**：从策略模板动态加载，使用映射关系获取风险偏好
- ✅ **范围中值**：杠杆和保证金比例使用范围的中值
- ✅ **最小限制**：订单金额 ≥ 5 USDT，下单数量 ≥ 0.0001
- ✅ **立即更新**：开仓成功后立即更新内存持仓，避免误判

### 10.3 计算公式

```
保证金 = 可用余额 × 保证金比例%
订单金额 = 保证金 × 杠杆
下单数量 = 订单金额 / 当前价格
```

---

## 十一、注意事项

1. **策略参数必须加载**
   - 如果策略参数未加载，无法下单
   - 会返回错误："策略参数未加载，无法执行开仓"

2. **最小订单金额限制**
   - 订单金额必须 ≥ 5 USDT
   - 如果不足，会返回错误："订单金额不足"

3. **最小下单数量限制**
   - 下单数量必须 ≥ 0.0001
   - 如果不足，会返回错误："订单数量不足"

4. **内存持仓立即更新**
   - 开仓成功后立即更新内存持仓
   - 避免下次检查时误判为没有持仓

5. **异步同步持仓**
   - 开仓后延迟1秒异步同步持仓
   - 确保内存状态与交易所一致

