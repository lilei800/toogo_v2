# 平仓逻辑设计分析与优化建议

## 一、各判断的必要性分析

### 1. 触发频率：每500毫秒检查一次

**当前实现**：`runMainLoop()` 中每500ms调用 `doTradingCheck()`，内部直接 `go e.checkClosePosition(ctx)`，无持仓状态分支。

**现状**：
- ✅ 有持仓时能及时检查止损/止盈
- ⚠️ 无持仓时也会高频触发，存在资源浪费

**建议**：可按有无持仓或订单状态动态调频，但当前代码未实现。

---

### 2. 必须有持仓（PositionAmt != 0）判断

**当前实现**：
```go
for _, pos := range positions {
    if pos.PositionAmt == 0 {
        continue
    }
    // ... 检查平仓条件
}
```

**必要性分析**：

#### ✅ **必须保留**

**原因**：
1. **性能优化**：避免对空持仓执行不必要的计算
2. **逻辑正确性**：空持仓不需要平仓检查
3. **避免误操作**：防止对已平仓的订单重复处理

**结论**：**必须保留**，这是基本的安全检查

---

### 3. 开仓后最小持仓时间

**当前实现**：最新代码已移除“开仓后30秒内不允许平仓”的保护，`shouldCloseFromOrder` 直接按止损/止盈回撤判断。

**影响**：
- ✅ 紧急止损可即时触发
- ⚠️ 若策略需要防抖，需要由策略参数层实现最小持仓时间（当前未实现）

---

### 4. 止损/止盈参数来源优先级

**当前实现（shouldCloseFromOrder）**：
1) 首选订单表中持仓订单的参数（`stop_loss_percent`, `auto_start_retreat_percent`, `profit_retreat_percent`）
2) 如果缺失，使用默认值：止损10%、启动止盈5%、止盈回撤30%

**说明**：
- 不再回退到策略模板或机器人静态值
- 参数缺失视为异常并记录日志，然后用默认兜底
1. **策略一致性**：订单开仓时的策略参数应该贯穿整个订单生命周期
2. **避免策略变更影响**：如果策略模板或机器人配置变更，不应该影响已开仓的订单
3. **简化逻辑**：减少复杂的优先级判断，代码更清晰

**当前实现的问题**：
- 如果订单表中没有策略参数（旧数据），会降级到策略模板
- 策略模板可能已经变更，导致平仓条件与开仓时不一致

**建议实现**：
```go
// 【简化】只使用订单创建时的策略参数
var stopLossPercent, takeProfitStart, profitRetreatPercent float64

orderData, err := dao.TradingOrder.Ctx(ctx).
    Fields("stop_loss_percent", "auto_start_retreat_percent", "profit_retreat_percent").
    Where("robot_id", robot.Id).
    Where("symbol", pos.Symbol).
    Where("direction", func() string {
        if pos.PositionSide == "LONG" {
            return "long"
        }
        return "short"
    }()).
    Where("status", 1). // 持仓中
    OrderDesc("created_at").
    One()

if err == nil && !orderData.IsEmpty() {
    // 从订单中获取策略参数
    if val := orderData["stop_loss_percent"]; val != nil {
        if v := val.Float64(); v > 0 {
            stopLossPercent = v
        }
    }
    if val := orderData["auto_start_retreat_percent"]; val != nil {
        if v := val.Float64(); v > 0 {
            takeProfitStart = v
        }
    }
    if val := orderData["profit_retreat_percent"]; val != nil {
        if v := val.Float64(); v > 0 {
            profitRetreatPercent = v
        }
    }
}

// 如果订单中没有策略参数，记录错误并使用默认值（不应该发生）
if stopLossPercent <= 0 || takeProfitStart <= 0 || profitRetreatPercent <= 0 {
    g.Log().Errorf(ctx, "[RobotTrader] 订单缺少策略参数: robotId=%d, side=%s, 使用默认值",
        robot.Id, pos.PositionSide)
    // 使用默认值（仅作为兜底）
    if stopLossPercent <= 0 {
        stopLossPercent = 10 // 默认止损10%
    }
    if takeProfitStart <= 0 {
        takeProfitStart = 5 // 默认启动止盈5%
    }
    if profitRetreatPercent <= 0 {
        profitRetreatPercent = 30 // 默认止盈回撤30%
    }
}
```

**结论**：**建议简化**，只使用订单创建时的策略参数，如果没有则使用默认值并记录错误

---

### 5. 止盈回撤机制优化

**用户需求改动**：

**阶段1：启动止盈**
- 当 `未实现盈亏 / 保证金 ≥ 设置的百分比` 时，自动开启止盈回撤按钮
- **达到100%后启动止盈功能**（一旦开启后无法关闭，直到本订单平仓）

**阶段2：盈利回撤止盈**
- 公式：`(实时最高盈利金额 - 实时未实现盈亏) / 最高盈利金额 ≥ 设置的百分比`
- 特性：不存在默认值，订单未实现盈亏实时最高点就是最高盈利额（只增加不减少，直到平仓）

**当前实现分析**：

**当前问题**：
1. 启动止盈条件：`profitPercent >= takeProfitStart`（如5%），立即启动
2. 用户需求：需要达到100%才启动止盈功能

**用户需求的理解**：
- "达到100%后启动止盈功能" 可能有两种理解：
  1. **理解1**：`未实现盈亏 / 保证金 ≥ 100%`（盈利达到保证金的100%，即翻倍）
  2. **理解2**：`未实现盈亏 / 保证金 ≥ 启动止盈百分比` 且进度达到100%（即完全满足启动条件）

**建议实现**（按理解1）：
```go
// 阶段1：启动止盈（需要达到100%盈利，即翻倍）
if !tracker.TakeProfitEnabled && margin > 0 {
    profitPercent := pos.UnrealizedPnl / margin * 100
    // 需要达到100%盈利（翻倍）才启动止盈
    if profitPercent >= 100 {
        tracker.TakeProfitEnabled = true
        g.Log().Infof(ctx, "[RobotTrader] 启动止盈回撤: robotId=%d, side=%s, 盈利比例=%.2f%% >= 100%% (翻倍)",
            robot.Id, pos.PositionSide, profitPercent)
    }
}

// 阶段2：止盈回撤触发
if tracker.TakeProfitEnabled && tracker.HighestProfit > 0 {
    retreat := (tracker.HighestProfit - pos.UnrealizedPnl) / tracker.HighestProfit * 100
    if retreat >= profitRetreatPercent {
        g.Log().Infof(ctx, "[RobotTrader] 触发止盈回撤: robotId=%d, side=%s, 最高盈利=%.4f, 当前盈亏=%.4f, 回撤=%.2f%% >= %.2f%%",
            robot.Id, pos.PositionSide, tracker.HighestProfit, pos.UnrealizedPnl, retreat, profitRetreatPercent)
        return true
    }
}
```

**但如果用户需求是理解2**（保留启动止盈百分比，但需要达到100%进度）：
```go
// 阶段1：启动止盈（需要达到启动止盈百分比，且进度100%）
if !tracker.TakeProfitEnabled && margin > 0 {
    profitPercent := pos.UnrealizedPnl / margin * 100
    // 计算进度：当前盈利比例 / 启动止盈百分比
    progress := (profitPercent / takeProfitStart) * 100
    if progress >= 100 { // 达到100%进度
        tracker.TakeProfitEnabled = true
        g.Log().Infof(ctx, "[RobotTrader] 启动止盈回撤: robotId=%d, side=%s, 盈利比例=%.2f%%, 进度=%.2f%% >= 100%%",
            robot.Id, pos.PositionSide, profitPercent, progress)
    }
}
```

**建议**：**需要用户确认**是哪种理解，然后实现对应的逻辑

---

## 二、优化建议总结

| 判断项 | 当前状态 | 建议 | 优先级 |
|--------|---------|------|--------|
| 1. 触发频率500ms | 固定500ms | 根据持仓状态动态调整 | 中 |
| 2. 持仓判断 | 必须 | 保留 | 必须 |
| 3. 30秒最小持仓 | 固定30秒 | 配置化 + 紧急止损例外 | 高 |
| 4. 止损百分比优先级 | 4级优先级 | 简化为只用订单参数 | 高 |
| 5. 止盈回撤机制 | 达到启动百分比即启动 | 需要确认用户需求 | 高 |

---

## 三、代码修改建议

### 修改1：简化止损百分比获取逻辑

**文件**：`robot_engine.go`
**位置**：`shouldClose()` 方法（2899-2982行）

**修改内容**：移除策略模板和机器人静态值的降级逻辑，只使用订单参数

### 修改2：优化止盈启动条件

**文件**：`robot_engine.go`
**位置**：`shouldClose()` 方法（2994-3002行）

**修改内容**：根据用户需求修改启动条件（需要确认是100%盈利还是100%进度）

### 修改3：配置化最小持仓时间

**文件**：`robot_engine.go`
**位置**：`shouldClose()` 方法（2877-2883行）

**修改内容**：从策略参数读取最小持仓时间，添加紧急止损例外

### 修改4：优化检查频率

**文件**：`robot_engine.go`
**位置**：`doTradingCheck()` 方法（981-989行）

**修改内容**：根据持仓状态动态调整检查频率

---

## 四、需要用户确认的问题

1. **止盈启动条件**：是要求盈利达到保证金的100%（翻倍），还是达到启动止盈百分比且进度100%？
2. **最小持仓时间**：是否同意配置化，并添加紧急止损例外？
3. **检查频率优化**：是否同意根据持仓状态动态调整检查频率？

