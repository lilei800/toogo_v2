# 血条、最高盈利和自动下单逻辑分析

## 一、血条工作逻辑

### 1. 止损血条（红色/橙色）

**触发条件：**
- 当 `|未实现盈亏| / (保证金 × 止损百分比) ≥ 100%` 时，自动执行平仓（止损）

**血条计算逻辑：**
```javascript
// 前端：web/src/views/toogo/robot/index.vue
const calcStopLossProgress = (pos, robot) => {
  const unrealizedPL = pos.unrealizedPnl || 0;  // 未实现盈亏
  const margin = pos.margin || 0;                // 保证金
  
  // 优先使用订单创建时的参数，找不到时使用实时策略配置
  const stopLossPercent = getOrderStrategyParam(pos, 'stopLossPercent', robot.id, getRobotStopLossPercent);
  
  // 只有亏损时才显示止损进度
  if (margin <= 0 || unrealizedPL >= 0) return 0;
  
  // 计算止损触发阈值：保证金 × 止损百分比%
  const stopLossThreshold = margin * (stopLossPercent / 100);
  
  // 血条进度 = |未实现盈亏| / 止损阈值 × 100%
  const progress = (absLoss / stopLossThreshold) * 100;
  
  return Math.min(100, progress);
}
```

**后端检查逻辑：**
```go
// server/internal/logic/toogo/robot_engine.go:2724-2737
stopLossPercent := robot.StopLossPercent
if stopLossPercent <= 0 {
    stopLossPercent = 10  // 默认10%
}

if margin > 0 && pos.UnrealizedPnl < 0 {
    lossPercent := math.Abs(pos.UnrealizedPnl) / margin * 100
    if lossPercent >= stopLossPercent {
        // 触发止损平仓
        return true
    }
}
```

**显示规则：**
- 0-80%：橙色（警告）
- 80-100%：红色（危险）
- ≥100%：触发止损，自动平仓

---

### 2. 启动止盈血条（绿色）

**触发条件：**
- 当 `未实现盈亏 / 保证金 ≥ 设置的百分比` 时，自动开启止盈按钮
- 一旦开启后无法关闭，直到平仓

**血条计算逻辑：**
```javascript
const calcStartProfitProgress = (pos, robot) => {
  // 如果后端返回了 takeProfitEnabled=true，说明止盈已启动，返回100%
  if (pos.takeProfitEnabled) {
    return 100;
  }

  const unrealizedPL = pos.unrealizedPnl || 0;
  const margin = pos.margin || 0;
  
  // 优先使用订单创建时的参数
  const autoStartPercent = getOrderStrategyParam(pos, 'autoStartRetreatPercent', robot.id, getRobotAutoStartRetreat);
  
  // 只有盈利时才显示启动止盈进度
  if (margin <= 0 || unrealizedPL <= 0) return 0;
  
  // 计算当前盈利占保证金的百分比
  const currentProfitPercent = (unrealizedPL / margin) * 100;
  
  // 血条进度 = (当前盈利百分比 / 设定百分比) × 100%
  const progress = (currentProfitPercent / autoStartPercent) * 100;
  
  return Math.min(100, progress);
}
```

**后端检查逻辑：**
```go
// server/internal/logic/toogo/robot_engine.go:2749-2757
takeProfitStart := robot.AutoStartRetreatPercent
if takeProfitStart <= 0 {
    takeProfitStart = 5  // 默认5%
}

// 启动止盈回撤
if !tracker.TakeProfitEnabled && margin > 0 {
    profitPercent := pos.UnrealizedPnl / margin * 100
    if profitPercent >= takeProfitStart {
        tracker.TakeProfitEnabled = true  // 一旦开启，永久开启
    }
}
```

**显示规则：**
- 0-100%：显示进度条
- =100%：止盈已启动，止盈回撤血条开始生效

---

### 3. 止盈回撤血条（绿色/红色）

**触发条件：**
- 当止盈按钮开启后，如果 `(实时最高盈利金额 - 实时未实现盈亏) / 最高盈利金额 ≥ 设置的百分比`，则自动执行平仓（止盈）

**血条计算逻辑：**
```javascript
const calcProfitRetreatProgress = (pos, robot) => {
  const unrealizedPL = pos.unrealizedPnl || 0;
  const maxProfitReached = pos.maxProfitReached || 0;  // 最高盈利金额
  
  // 优先使用订单创建时的参数
  const profitRetreatPercent = getOrderStrategyParam(pos, 'profitRetreatPercent', robot.id, getRobotProfitRetreat);
  
  // 如果没有最高盈利记录或止盈未启用，返回100%（满条）
  if (maxProfitReached <= 0) return 100;
  
  // 计算当前回撤百分比：(最高盈利 - 当前盈利) / 最高盈利 × 100%
  const currentRetreatPercent = ((maxProfitReached - unrealizedPL) / maxProfitReached) * 100;
  
  // 血条进度 = 100% - (当前回撤百分比 / 设定回撤百分比) × 100%
  // 当回撤达到设定值时，血条为0%，触发止盈
  const progress = 100 - (currentRetreatPercent / profitRetreatPercent) * 100;
  
  return Math.max(0, Math.min(100, progress));
}
```

**后端检查逻辑：**
```go
// server/internal/logic/toogo/robot_engine.go:2759-2767
profitRetreatPercent := robot.ProfitRetreatPercent
if profitRetreatPercent <= 0 {
    profitRetreatPercent = 30  // 默认30%
}

// 止盈回撤触发
if tracker.TakeProfitEnabled && tracker.HighestProfit > 0 {
    retreat := (tracker.HighestProfit - pos.UnrealizedPnl) / tracker.HighestProfit * 100
    if retreat >= profitRetreatPercent {
        // 触发止盈平仓
        return true
    }
}
```

**显示规则：**
- 100%：安全状态（无回撤）
- 20%-100%：绿色（安全）
- 0-20%：红色（危险）
- =0%：触发止盈，自动平仓

**重要：** 只有启动止盈血条达到100%后，止盈回撤血条才会生效。

---

## 二、最高盈利逻辑

### 1. 后端维护（PositionTracker）

**位置：** `server/internal/logic/toogo/robot_engine.go:2710-2713`

```go
// 【重要】只有正盈利才更新最高盈利
if pos.UnrealizedPnl > 0 && pos.UnrealizedPnl > tracker.HighestProfit {
    tracker.HighestProfit = pos.UnrealizedPnl
}
```

**关键点：**
- 只有**正盈利**（`UnrealizedPnl > 0`）才会更新最高盈利
- 亏损时不会更新最高盈利
- 最高盈利一旦记录，只会增加，不会减少（直到平仓）

**初始化逻辑：**
```go
// 新建 tracker 时，只有盈利才记录为最高盈利
initialHighestProfit := 0.0
if pos.UnrealizedPnl > 0 {
    initialHighestProfit = pos.UnrealizedPnl
}
tracker = &PositionTracker{
    PositionSide:  pos.PositionSide,
    HighestProfit: initialHighestProfit,  // 初始值
    EntryMargin:   pos.IsolatedMargin,
    EntryTime:     time.Now(),
}
```

### 2. 前端缓存机制

**位置：** `web/src/views/toogo/robot/index.vue:2508-2577`

**三层缓存策略：**

1. **后端返回值（优先级最高）**
   ```javascript
   const backendMaxProfit = newPos.maxProfitReached || 0;
   ```

2. **内存缓存（页面刷新前）**
   ```javascript
   const memoryMaxProfit = oldPos?.maxProfitReached || 0;
   ```

3. **localStorage持久化缓存（页面刷新后）**
   ```javascript
   const storageMaxProfit = maxProfitCache[cacheKey] || 0;
   ```

**合并逻辑：**
```javascript
// 只有后端已启动止盈时，才从本地取更大值（防止页面刷新丢失）
if (newPos.takeProfitEnabled) {
    finalMaxProfit = Math.max(backendMaxProfit, memoryMaxProfit, storageMaxProfit);
} else {
    finalMaxProfit = backendMaxProfit;  // 未启动止盈时，只使用后端值
}

// 当前盈利大于最高盈利时更新
const currentProfit = newPos.unrealizedPnl || 0;
if (currentProfit > finalMaxProfit) {
    finalMaxProfit = currentProfit;
}
```

**新订单检测：**
```javascript
// 【重要】后端返回 maxProfitReached=0 表示新订单，清除本地缓存
if (backendMaxProfit === 0 && !newPos.takeProfitEnabled) {
    // 新订单，清除本地缓存的旧值
    if (maxProfitCache[cacheKey]) {
        delete maxProfitCache[cacheKey];
    }
}
```

**缓存Key格式：**
```javascript
const cacheKey = `${robot.id}_${newPos.symbol}_${newPos.positionSide}`;
// 例如：18_BTC-USDT_LONG
```

---

## 三、自动下单逻辑

### 1. 信号生成（窗口价格算法）

**位置：** `server/internal/logic/toogo/robot_engine.go:925-1111`

**核心算法：**
```go
// 在时间窗口内维护最高价(maxPrice)和最低价(minPrice)
// - 做空信号：最高价 - 实时价格 >= 波动值 (价格从高点回落)
// - 做多信号：实时价格 - 最低价 >= 波动值 (价格从低点反弹)

minPrice := e.PriceWindow[0].Price
maxPrice := e.PriceWindow[0].Price
for _, p := range e.PriceWindow {
    if p.Price < minPrice {
        minPrice = p.Price
    }
    if p.Price > maxPrice {
        maxPrice = p.Price
    }
}

currentPrice := e.PriceWindow[dataCount-1].Price
threshold := e.MonitorConfig.Threshold

// 计算距离
distanceFromMax := maxPrice - currentPrice  // 最高价 - 实时价格
distanceFromMin := currentPrice - minPrice  // 实时价格 - 最低价

// 触发条件
shortTriggered := distanceFromMax >= threshold  // 做空：价格从高点回落
longTriggered := distanceFromMin >= threshold   // 做多：价格从低点反弹
```

**价格窗口管理：**
```go
// 添加价格数据点
func (e *RobotEngine) AddPricePoint(price float64) {
    now := time.Now().UnixMilli()
    e.PriceWindow = append(e.PriceWindow, PricePoint{
        Timestamp: now,
        Price:     price,
    })
    
    // 修剪窗口期外的数据
    e.pruneWindowData(now)
}

// 修剪窗口期外的价格数据
func (e *RobotEngine) pruneWindowData(now int64) {
    cutoff := now - int64(e.MonitorConfig.Window)*1000  // Window单位：秒
    // 只保留窗口期内的数据
}
```

### 2. 信号检测流程

**位置：** `server/internal/logic/toogo/robot_engine.go:1050-1111`

**流程：**
1. **价格更新** → `AddPricePoint(price)`
2. **信号评估** → `EvaluateWindowSignal()`
3. **信号变化检测** → `isNewDirection := newSignal != e.LastWindowSignal`
4. **保存预警记录** → `saveSignalAlert(signal, isNewDirection)`
5. **异步尝试下单** → `TryAutoTradeAndUpdate(signal, logId)`

**信号保存逻辑：**
```go
// 如果不是新方向，检查30秒内是否已有记录（避免持续信号重复记录）
if !isNewDirection {
    count, _ := g.DB().Model("hg_trading_signal_log").Ctx(ctx).
        Where("robot_id", e.Robot.Id).
        Where("signal_type", signal.Direction).
        Where("created_at > ?", time.Now().Add(-30*time.Second)).
        Count()
    if count > 0 {
        return 0  // 30秒内已有同方向记录，跳过
    }
}
```

### 3. 下单条件检查

**位置：** `server/internal/logic/toogo/robot_engine.go:2098-2151`

**检查项：**

1. **自动交易开关**
   ```go
   if robot.AutoTradeEnabled != 1 {
       return false, "自动下单未开启"
   }
   ```

2. **信号类型**
   ```go
   if signal.Action != "OPEN_LONG" && signal.Action != "OPEN_SHORT" {
       return false, fmt.Sprintf("信号类型为%s，不是开仓信号", signal.Action)
   }
   ```

3. **持仓状态**
   ```go
   // 每方向最多1单
   if hasCurrentPosition {
       return false, "该方向已有持仓"
   }
   ```

4. **反向下单策略**
   ```go
   if hasOppositePosition {
       if robot.EnableReverseOrder != 1 {
           return false, "反向下单未开启"
       }
       reason := t.checkReverseCondition(ctx, oppositeSide)
       if reason != "" {
           return false, reason
       }
   }
   ```

5. **算力检查**
   ```go
   if !t.checkPower(ctx) {
       return false, "算力不足，请充值"
   }
   ```

6. **余额检查**
   ```go
   balance := t.engine.AccountBalance
   if balance == nil || balance.AvailableBalance <= 0 {
       return false, "保证金余额不足"
   }
   ```

### 4. 反向下单条件

**位置：** `server/internal/logic/toogo/robot_engine.go:2582-2686`

**市场状态阈值：**
```go
// 趋势市场: 亏损50%回撤, 盈利100%回撤 → 允许反向开仓
// 震荡市场: 0%, 0% → 立即允许反向开仓
// 低波动市场: 0%, 0% → 立即允许反向开仓

thresholds := GetReverseThresholds(marketState)
```

**亏损订单回撤计算：**
```go
if currentPnl < 0 {
    // 计算从最低点的回撤比例
    // 回撤 = (当前盈亏 - 最低盈亏) / |最低盈亏| * 100
    lowestPnl := currentPnl
    if highestPnl < currentPnl {
        lowestPnl = highestPnl
    }
    
    retreatPercent := (currentPnl - lowestPnl) / math.Abs(lowestPnl) * 100
    
    if retreatPercent >= thresholds.LossRetreat {
        return true  // 允许反向开单
    }
}
```

**盈利订单回撤计算：**
```go
if currentPnl >= 0 {
    // 计算从最高点的回撤比例
    // 回撤 = (最高盈亏 - 当前盈亏) / 最高盈亏 * 100
    retreatPercent := (highestPnl - currentPnl) / highestPnl * 100
    
    if retreatPercent >= thresholds.ProfitRetreat {
        return true  // 允许反向开单
    }
}
```

### 5. 下单执行

**位置：** `server/internal/logic/toogo/robot_engine.go:2399-2546`

**策略参数获取：**
```go
// 优先使用已缓存的策略参数
strategyParams := t.engine.CurrentStrategyParams

// 如果没有缓存的策略参数，根据当前市场状态和风险偏好重新加载
if strategyParams == nil {
    strategyParams, err = t.engine.loadFullStrategyParams(ctx, marketState, riskPref)
    if err != nil {
        return gerror.Wrap(err, "策略参数加载失败，无法执行开仓")
    }
}
```

**杠杆和保证金计算：**
```go
// 使用杠杆范围的中值
leverage := (strategyParams.LeverageMin + strategyParams.LeverageMax) / 2
if leverage <= 0 {
    leverage = 10
}

// 使用保证金比例范围的中值
marginPercent := (strategyParams.MarginPercentMin + strategyParams.MarginPercentMax) / 2
if marginPercent <= 0 {
    marginPercent = 10
}

margin := balance.AvailableBalance * marginPercent / 100
quantity := margin * float64(leverage) / ticker.LastPrice
```

**订单记录：**
```go
// 记录订单（传递策略参数）
t.recordOrder(ctx, order, signal, currentStrategyParams, leverage, marginPercent)

// 保存策略参数到数据库（用于血条计算）
orderData["stop_loss_percent"] = strategyParams.StopLossPercent
orderData["auto_start_retreat_percent"] = strategyParams.AutoStartRetreatPercent
orderData["profit_retreat_percent"] = strategyParams.ProfitRetreatPercent
orderData["margin_percent"] = marginPercent
```

**持仓跟踪器初始化：**
```go
t.engine.PositionTrackers[positionSide] = &PositionTracker{
    PositionSide: positionSide,
    EntryMargin:  margin,
    EntryTime:    time.Now(),
    HighestProfit: 0.0,  // 初始为0，只有盈利时才会更新
}
```

---

## 四、关键问题与优化建议

### 1. 血条参数优先级

**当前实现：**
1. 订单创建时的参数（最准确）
2. 实时策略配置参数（找不到时使用数据库静态值）

**优势：**
- 订单创建时的参数是下单时实际使用的参数，最准确
- 即使策略模板变更，已开订单的血条计算不受影响

### 2. 最高盈利更新时机

**当前实现：**
- 后端：只有正盈利时才更新最高盈利
- 前端：结合后端值、内存缓存、localStorage缓存

**潜在问题：**
- 如果订单从盈利转为亏损，最高盈利不会更新（这是正确的，因为止盈回撤是基于最高盈利计算的）
- 页面刷新后，如果后端未启动止盈，最高盈利可能丢失（已通过localStorage解决）

### 3. 自动下单并发控制

**当前实现：**
```go
// 使用锁机制防止并发下单
if !e.orderLock.TryLock() {
    return
}
defer e.orderLock.Unlock()
```

**优化建议：**
- 已实现锁机制，避免重复下单
- 建议增加下单频率限制（如：同一方向30秒内最多1次）

### 4. 信号持续但未下单的处理

**当前实现：**
```go
// CheckAndOpenPosition 定时检查并开仓（用于处理信号持续但未下单的情况）
func (t *RobotTrader) CheckAndOpenPosition(ctx context.Context) {
    signal := t.engine.LastSignal
    // 定时检查时不保存预警记录（避免重复），只尝试下单
    canTrade, _ := t.checkTradingConditions(ctx, signal)
    if canTrade {
        err := t.executeOpen(ctx, signal)
    }
}
```

**说明：**
- 定时检查机制确保信号持续时能够下单
- 避免重复保存预警记录

---

## 五、总结

### 血条逻辑
- ✅ 三个血条独立工作，互不干扰
- ✅ 优先使用订单创建时的参数，确保准确性
- ✅ 找不到参数时使用实时策略配置，确保血条不停止

### 最高盈利逻辑
- ✅ 只有正盈利才更新最高盈利
- ✅ 前端三层缓存机制，防止页面刷新丢失
- ✅ 新订单自动清除旧缓存

### 自动下单逻辑
- ✅ 窗口价格算法，基于最高价和最低价判断方向
- ✅ 完整的条件检查机制
- ✅ 反向下单策略，基于市场状态和回撤比例
- ✅ 并发控制，避免重复下单

