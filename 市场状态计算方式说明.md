# 市场状态计算方式说明

## ⚠️ 重要说明

**实际使用的是 `MarketAnalyzer`（全局引擎），不是 `RobotAnalyzer`（本地计算，已废弃）**

---

## 一、核心确认

✅ **是的，每个币种市场状态的计算方式是相同的，都基于历史K线数据计算**

**但需要注意**：
- 实际使用3个周期（5m, 15m, 1h），**不包括1m和1d**
- 使用**固定阈值**（highVol=2.0, lowVol=0.5），不是自适应阈值

---

## 二、计算流程

### 2.1 统一计算逻辑

**所有币种使用相同的计算流程**：

```
1. 获取历史K线数据（多周期）
   ↓
2. 分析每个周期的技术指标（EMA12, EMA26, MACD, ATR）
   ↓
3. 计算综合趋势强度和波动率（加权平均）
   ↓
4. 判定市场状态（trend/volatile/high_vol/low_vol）
```

### 2.2 数据来源

**所有币种都基于历史K线数据**：

- **K线数据来源**：`MarketServiceManager.GetMultiTimeframeKlines(platform, symbol)`
- **多周期K线**（实际使用）：
  - **5分钟周期（5m）**：权重 0.20（短期）
  - **15分钟周期（15m）**：权重 0.35（中期，主要）
  - **1小时周期（1h）**：权重 0.45（长期，最重要）
- **最小K线要求**：每个周期至少需要 **26根K线**

**⚠️ 注意**：只使用3个周期，**不包括1m和1d周期**

---

## 三、技术指标计算

### 3.1 统一的技术指标

**所有币种使用相同的技术指标**：

| 指标 | 说明 | 参数 |
|------|------|------|
| EMA12 | 12周期指数移动平均 | 基于收盘价 |
| EMA26 | 26周期指数移动平均 | 基于收盘价 |
| MACD | MACD指标 | EMA12 - EMA26 |
| ATR | 平均真实波动范围 | 14周期 |

### 3.2 计算代码

```go
// 提取收盘价、最高价、最低价
closes := make([]float64, len(klines))
highs := make([]float64, len(klines))
lows := make([]float64, len(klines))

// 计算技术指标
result.EMA12 = calculateEMA(closes, 12)
result.EMA26 = calculateEMA(closes, 26)
result.MACD = result.EMA12 - result.EMA26
result.ATR = calculateATR(highs, lows, closes, 14)
```

---

## 四、市场状态判定

### 4.1 判定逻辑

**所有币种使用相同的判定逻辑**：

```go
// 1. 优先判断波动率
if analysis.Volatility > highVolThreshold {
    return MarketStateHighVol  // 高波动
}
if analysis.Volatility < lowVolThreshold {
    return MarketStateLowVol  // 低波动
}

// 2. 判断趋势一致性
trendConsistency := calculateTrendConsistency(...)
if trendConsistency > 0.6 {
    return MarketStateTrend  // 趋势市场
}

// 3. 默认震荡
return MarketStateVolatile  // 震荡市场
```

### 4.2 阈值设置

**当前使用固定阈值**（所有币种相同）：

| 阈值 | 值 | 说明 |
|------|-----|------|
| highVolThreshold | **2.0** | 高波动阈值（**固定值**） |
| lowVolThreshold | **0.5** | 低波动阈值（**固定值**） |
| trendConsistencyThreshold | **0.6** | 趋势一致性阈值 |

**⚠️ 重要**：这些是**固定阈值**，不是自适应阈值！

**代码位置**：`server/internal/library/market/market_analyzer.go:determineMarketState()`（第338行）

```go
// 波动率阈值（固定值）
highVolThreshold := 2.0
lowVolThreshold := 0.5
```

---

## 五、计算示例

### 5.1 Bitget BTCUSDT

```
1. 获取K线数据：
   - 5m: 100根K线
   - 15m: 100根K线
   - 1h: 50根K线

2. 计算技术指标：
   - EMA12, EMA26, MACD, ATR

3. 计算综合指标：
   - TrendStrength = 加权平均趋势强度
   - Volatility = 加权平均波动率

4. 判定市场状态：
   - 如果 Volatility > 2.0 → "high_vol"
   - 如果 Volatility < 0.5 → "low_vol"
   - 如果 TrendConsistency > 0.6 → "trend"
   - 否则 → "volatile"
```

### 5.2 Binance ETHUSDT

```
1. 获取K线数据：
   - 5m: 100根K线
   - 15m: 100根K线
   - 1h: 50根K线

2. 计算技术指标：
   - EMA12, EMA26, MACD, ATR
   （使用相同的计算逻辑）

3. 计算综合指标：
   - TrendStrength = 加权平均趋势强度
   - Volatility = 加权平均波动率

4. 判定市场状态：
   - 如果 Volatility > 2.0 → "high_vol"
   - 如果 Volatility < 0.5 → "low_vol"
   - 如果 TrendConsistency > 0.6 → "trend"
   - 否则 → "volatile"
```

**结论**：两个币种使用完全相同的计算逻辑，只是输入数据（K线）不同。

---

## 六、代码实现

### 6.1 统一的计算入口

```go
// analyzeMarket 分析单个市场（所有币种使用相同的逻辑）
func (a *MarketAnalyzer) analyzeMarket(ctx context.Context, platform, symbol string, ticker *exchange.Ticker, klineCache *KlineCache) *MarketAnalysis {
    // 1. 初始化分析结果
    analysis := &MarketAnalysis{
        Platform:          platform,
        Symbol:            symbol,
        UpdatedAt:         time.Now(),
        CurrentPrice:      ticker.LastPrice,
        TimeframeAnalysis: make(map[string]*TimeframeResult),
    }

    // 2. 多周期分析（所有币种使用相同的周期和权重）
    timeframes := []struct {
        interval string
        klines   []*exchange.Kline
        weight   float64
    }{
        {"5m", klineCache.Klines5m, 0.20},   // 短期
        {"15m", klineCache.Klines15m, 0.35}, // 中期（主要）
        {"1h", klineCache.Klines1h, 0.45},   // 长期（最重要）
    }

    // 3. 分析每个周期（使用相同的分析逻辑）
    for _, tf := range timeframes {
        if len(tf.klines) < 26 {
            continue
        }
        result := a.analyzeTimeframe(tf.interval, tf.klines, tf.weight)
        // ...
    }

    // 4. 计算综合指标（所有币种使用相同的计算方式）
    analysis.Indicators = a.calculateIndicators(analysis.TimeframeAnalysis)

    // 5. 判定市场状态（所有币种使用相同的判定逻辑）
    analysis.MarketState, analysis.MarketStateConf = a.determineMarketState(analysis)

    return analysis
}
```

### 6.2 数据输入

**所有币种都从相同的数据源获取K线**：

```go
// analyzeAllMarkets 分析所有市场
for platform, svc := range allServices {
    for symbol := range subscriptions {
        // 每个币种获取自己的K线数据
        klineCache := svc.GetMultiTimeframeKlines(symbol)
        ticker := svc.GetTicker(symbol)

        // 使用相同的分析逻辑
        analysis := a.analyzeMarket(ctx, platform, symbol, ticker, klineCache)
    }
}
```

---

## 七、总结

### 7.1 确认

✅ **每个币种市场状态的计算方式是相同的**
- 使用相同的技术指标（EMA12, EMA26, MACD, ATR）
- 使用相同的判定逻辑（波动率阈值、趋势一致性）
- 使用相同的周期和权重（5m:0.20, 15m:0.35, 1h:0.45）

✅ **都基于历史K线数据计算**
- 从 `MarketServiceManager` 获取多周期K线数据
- 使用 5m、15m、1h 三个周期的历史K线
- 需要至少 26 根K线才能计算

### 7.2 唯一差异

**唯一差异是输入数据（K线数据）不同**：
- `bitget:BTCUSDT` 使用 Bitget 交易所的 BTCUSDT K线数据
- `binance:BTCUSDT` 使用 Binance 交易所的 BTCUSDT K线数据
- `bitget:ETHUSDT` 使用 Bitget 交易所的 ETHUSDT K线数据

**但计算逻辑完全相同**。

### 7.3 注意事项

**实际使用的计算方式**（`MarketAnalyzer`）：
- **周期**：只使用3个周期（5m, 15m, 1h）
- **阈值**：固定阈值（highVol=2.0, lowVol=0.5）
- **判定逻辑**：先判断波动率，再判断趋势一致性

**已废弃的计算方式**（`RobotAnalyzer`，不再使用）：
- **周期**：5个周期（1m, 5m, 15m, 1h, 1d）
- **阈值**：自适应阈值（基于基准波动率动态计算）
- **判定逻辑**：加权投票机制

**代码位置**：
- 实际使用：`server/internal/library/market/market_analyzer.go`
- 已废弃：`server/internal/logic/toogo/robot_engine.go:RobotAnalyzer`（不再调用）

**建议**：后续可以将 `RobotAnalyzer` 的自适应阈值逻辑迁移到 `MarketAnalyzer`，以保持一致性。

