# è®¢å•è·å–é€»è¾‘å’Œä¸šåŠ¡æµç¨‹åˆ†ææŠ¥å‘Š

> **ç”Ÿæˆæ—¶é—´**: 2025-12-26  
> **é¡¹ç›®**: HotGo V2 è‡ªåŠ¨äº¤æ˜“ç³»ç»Ÿ  
> **ç‰ˆæœ¬**: v2.18.6

---

## ğŸ“‹ ç›®å½•

1. [æ¦‚è§ˆ](#æ¦‚è§ˆ)
2. [æ•°æ®æ¨¡å‹ä¸è¡¨ç»“æ„](#æ•°æ®æ¨¡å‹ä¸è¡¨ç»“æ„)
3. [è®¢å•è·å–çš„æ ¸å¿ƒæµç¨‹](#è®¢å•è·å–çš„æ ¸å¿ƒæµç¨‹)
4. [ç¼“å­˜æœºåˆ¶](#ç¼“å­˜æœºåˆ¶)
5. [è®¢å•åŒæ­¥æœºåˆ¶](#è®¢å•åŒæ­¥æœºåˆ¶)
6. [è®¢å•çŠ¶æ€åŒæ­¥æœåŠ¡](#è®¢å•çŠ¶æ€åŒæ­¥æœåŠ¡)
7. [äº¤æ˜“æ‰€æ¥å£å®ç°](#äº¤æ˜“æ‰€æ¥å£å®ç°)
8. [æ€§èƒ½ä¼˜åŒ–ç­–ç•¥](#æ€§èƒ½ä¼˜åŒ–ç­–ç•¥)
9. [æ—¶åºå›¾](#æ—¶åºå›¾)
10. [é—®é¢˜ä¸å»ºè®®](#é—®é¢˜ä¸å»ºè®®)

---

## æ¦‚è§ˆ

HotGo V2 ç³»ç»Ÿçš„è®¢å•è·å–é€»è¾‘è®¾è®¡ä¸º**å¤šå±‚ç¼“å­˜ + æ™ºèƒ½åŒæ­¥**çš„æ¶æ„ï¼Œæ ¸å¿ƒç›®æ ‡æ˜¯ï¼š
- âœ… å‡å°‘å¯¹äº¤æ˜“æ‰€ API çš„ç›´æ¥è°ƒç”¨
- âœ… ç¡®ä¿è®¢å•æ•°æ®çš„å‡†ç¡®æ€§å’Œå®æ—¶æ€§
- âœ… æ”¯æŒå†å²è®¢å•æŸ¥è¯¢å’Œå®æ—¶è®¢å•ç›‘æ§
- âœ… é€šè¿‡ WebSocket å¢é‡æ›´æ–° + REST å®šæœŸåŒæ­¥å®ç°æœ€ç»ˆä¸€è‡´æ€§

---

## æ•°æ®æ¨¡å‹ä¸è¡¨ç»“æ„

### æ ¸å¿ƒè¡¨ç»“æ„

#### 1. `hg_trading_order` - è®¢å•ä¸»è¡¨
```sql
CREATE TABLE hg_trading_order (
    id BIGSERIAL PRIMARY KEY,
    tenant_id BIGINT NOT NULL DEFAULT 0,
    user_id BIGINT NOT NULL,
    robot_id BIGINT NOT NULL,
    exchange VARCHAR(50) NOT NULL,
    symbol VARCHAR(50) NOT NULL,
    order_sn VARCHAR(50) NOT NULL,
    exchange_order_id VARCHAR(100),
    client_order_id VARCHAR(100),
    close_order_id VARCHAR(100),
    direction VARCHAR(10) NOT NULL,
    open_price DECIMAL(20,8),
    close_price DECIMAL(20,8),
    quantity DECIMAL(20,8),
    leverage INT,
    margin DECIMAL(20,8),
    open_fee DECIMAL(20,8),
    open_fee_coin VARCHAR(20),
    close_fee DECIMAL(20,8),
    close_fee_coin VARCHAR(20),
    realized_profit DECIMAL(20,8),
    status INT NOT NULL DEFAULT 1,
    close_reason VARCHAR(50),
    open_time TIMESTAMP,
    close_time TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

**å…³é”®ç´¢å¼•**ï¼ˆå·²ä¼˜åŒ–ï¼‰ï¼š
```sql
-- è®¢å•å†å²æŸ¥è¯¢ä¼˜åŒ–
CREATE INDEX idx_user_status_closetime ON hg_trading_order(user_id, status, close_time);
CREATE INDEX idx_robot_status ON hg_trading_order(robot_id, status);
CREATE INDEX idx_exchange_order_id ON hg_trading_order(exchange_order_id);
CREATE INDEX idx_close_time ON hg_trading_order(close_time);
```

#### 2. `hg_trading_exchange_order` - äº¤æ˜“æ‰€è®¢å•äº‹å®è¡¨
ç”¨äºå­˜å‚¨ä» WebSocket æ¨é€çš„å®æ—¶è®¢å•äº‹ä»¶ï¼Œä¾›å‰ç«¯æŒ‚å•åˆ—è¡¨å±•ç¤ºã€‚

#### 3. `hg_trading_order_status_history` - è®¢å•çŠ¶æ€å†å²è¡¨
è®°å½•è®¢å•çŠ¶æ€å˜æ›´çš„å®Œæ•´å†å²ï¼Œç”¨äºå®¡è®¡å’Œé—®é¢˜è¿½è¸ªã€‚

#### 4. `hg_trading_trade_fill` - æˆäº¤æµæ°´è¡¨
å­˜å‚¨æ¯ç¬”è®¢å•çš„æˆäº¤æ˜ç»†ï¼ŒåŒ…å«æ‰‹ç»­è´¹ã€ç›ˆäºç­‰ç²¾ç¡®æ•°æ®ã€‚

### è®¢å•çŠ¶æ€å®šä¹‰

```go
const (
    OrderStatusPending  = 1  // æŒä»“ä¸­
    OrderStatusClosed   = 2  // å·²å¹³ä»“
    OrderStatusCanceled = 3  // å·²å–æ¶ˆ
    OrderStatusFailed   = 4  // å¤±è´¥
)
```

---

## è®¢å•è·å–çš„æ ¸å¿ƒæµç¨‹

### 1. å‰ç«¯è¯·æ±‚è®¢å•å†å²åˆ—è¡¨

**API è·¯ç”±**ï¼ˆæ¨æµ‹ï¼‰: `GET /api/toogo/wallet/order-history`

**è¾“å…¥å‚æ•°**ï¼ˆ`OrderHistoryListInp`ï¼‰:
```go
type OrderHistoryListInp struct {
    UserId    int64  // ç”¨æˆ·IDï¼ˆç®¡ç†ç«¯å¯ç­›é€‰ï¼‰
    RobotId   int64  // æœºå™¨äººID
    Exchange  string // äº¤æ˜“æ‰€
    Symbol    string // äº¤æ˜“å¯¹
    Direction string // æ–¹å‘: long/short
    Status    int    // çŠ¶æ€: 1=æŒä»“ä¸­, 2=å·²å¹³ä»“, 3=å·²å–æ¶ˆ
    StartTime string // å¼€å§‹æ—¶é—´
    EndTime   string // ç»“æŸæ—¶é—´
    Page      int    // é¡µç 
    PageSize  int    // æ¯é¡µæ•°é‡
}
```

### 2. åç«¯è®¢å•æŸ¥è¯¢é€»è¾‘

#### æ ¸å¿ƒæ–‡ä»¶ï¼š`internal/logic/toogo/wallet.go`

##### ğŸ”¹ `OrderHistoryList()` å‡½æ•°æµç¨‹

```go
func (s *sToogoWallet) OrderHistoryList(ctx context.Context, in *toogoin.OrderHistoryListInp) (
    list []*toogoin.OrderHistoryModel, totalCount int, err error) {
    
    // === ç¬¬1æ­¥ï¼šæƒé™éªŒè¯ ===
    memberId := contexts.GetUserId(ctx)
    if memberId <= 0 {
        return nil, 0, gerror.New("ç”¨æˆ·æœªç™»å½•")
    }
    
    // === ç¬¬2æ­¥ï¼šæ„å»ºæŸ¥è¯¢æ¡ä»¶ ===
    mod := dao.TradingOrder.Ctx(ctx).As("o")
    
    // ç”¨æˆ·èŒƒå›´ï¼š
    // - æ™®é€šç”¨æˆ·ï¼šåªèƒ½æŸ¥è‡ªå·±çš„
    // - ç®¡ç†ç«¯ï¼šå¯æŒ‰ userId ç­›é€‰ï¼›ä¸ä¼ åˆ™æŸ¥å…¨éƒ¨ç”¨æˆ·
    if contexts.IsUserDept(ctx) {
        mod = mod.Where("o.user_id", memberId)
    } else if in.UserId > 0 {
        mod = mod.Where("o.user_id", in.UserId)
    }
    
    // ç­›é€‰æ¡ä»¶
    if in.RobotId > 0 {
        mod = mod.Where("o.robot_id", in.RobotId)
    }
    if in.Exchange != "" {
        mod = mod.Where("o.exchange", in.Exchange)
    }
    if in.Symbol != "" {
        mod = mod.Where("o.symbol", in.Symbol)
    }
    if in.Direction != "" {
        mod = mod.Where("o.direction", in.Direction)
    }
    if in.Status > 0 {
        mod = mod.Where("o.status", in.Status)
    }
    
    // === ç¬¬3æ­¥ï¼šæ—¶é—´æ’åºä¼˜åŒ– ===
    // - å·²å¹³ä»“(status=2)ï¼šç”¨ close_time
    // - å…¶ä»–çŠ¶æ€ï¼šä½¿ç”¨ created_at
    timeCol := "o.created_at"
    if in.Status == 2 {
        // å…¼å®¹å†å²è„æ•°æ®ï¼ˆYear=2006 çš„å ä½å€¼ï¼‰
        timeCol = "CASE WHEN o.close_time IS NULL OR EXTRACT(YEAR FROM o.close_time)=2006 " +
                  "THEN o.updated_at ELSE o.close_time END"
    }
    
    if in.StartTime != "" {
        mod = mod.WhereGTE(timeCol, in.StartTime)
    }
    if in.EndTime != "" {
        mod = mod.WhereLTE(timeCol, in.EndTime)
    }
    
    // === ç¬¬4æ­¥ï¼šåˆ†é¡µæŸ¥è¯¢ ===
    totalCount, err = mod.Count()
    if err != nil || totalCount == 0 {
        return nil, 0, err
    }
    
    var orders []*orderRow
    err = mod.
        Fields("o.id", "o.user_id", "o.robot_id", "o.exchange", "o.order_sn", 
               "o.exchange_order_id", "o.symbol", "o.direction", 
               "o.open_price", "o.close_price", "o.quantity", "o.realized_profit", 
               "o.status", "o.close_reason", "o.open_time", "o.close_time", 
               "o.created_at", "o.updated_at").
        OrderDesc(timeCol).
        Page(in.Page, in.PageSize).
        Scan(&orders)
    
    // === ç¬¬5æ­¥ï¼šæ•°æ®å¢å¼ºï¼ˆæ™ºèƒ½è·å–æˆäº¤æ˜ç»†ï¼‰===
    // ç­–ç•¥ï¼šåªå¯¹"è¿‘14å¤©çš„å·²å¹³ä»“è®¢å•"è°ƒç”¨äº¤æ˜“æ‰€APIè·å–ç²¾ç¡®ç›ˆäº/æ‰‹ç»­è´¹
    list = s.enrichOrdersWithTradeHistory(ctx, orders)
    
    return list, totalCount, nil
}
```

##### ğŸ”¹ æ•°æ®å¢å¼ºé€»è¾‘ï¼š`enrichOrdersWithTradeHistory()`

**æ ¸å¿ƒç­–ç•¥**ï¼ˆå·²ä¼˜åŒ–ï¼Œå‡å°‘APIè°ƒç”¨ï¼‰:

1. **æ™ºèƒ½åˆ¤æ–­æ˜¯å¦éœ€è¦è°ƒç”¨äº¤æ˜“æ‰€API**ï¼š
   ```go
   // åªå¯¹æ»¡è¶³ä»¥ä¸‹æ¡ä»¶çš„è®¢å•è°ƒç”¨APIï¼š
   // 1. å·²å¹³ä»“è®¢å•ï¼ˆstatus=2ï¼‰
   // 2. å¹³ä»“æ—¶é—´åœ¨14å¤©å†…
   // 3. å…³é”®è´¢åŠ¡å­—æ®µç¼ºå¤±æˆ–ä¸å¯é ï¼š
   //    - realized_profit == 0
   //    - close_fee == 0
   //    - close_time ä¸ºç©ºæˆ–æ— æ•ˆ
   needExchangeQuery := (order.Status == 2) && 
                        (order.CloseTime.After(gtime.Now().Add(-14*24*time.Hour))) &&
                        (order.RealizedProfit == 0 || order.CloseFee == 0)
   ```

2. **ç¼“å­˜æœºåˆ¶ï¼ˆ5åˆ†é’ŸTTLï¼‰**ï¼š
   ```go
   cacheKey := fmt.Sprintf("toogo:orderHistory:trades:%d:%s:%d", apiId, symbol, limit)
   if v, _ := orderHistoryTradeCache.Get(ctx, cacheKey); v != nil {
       return cached, nil  // å‘½ä¸­ç¼“å­˜ï¼Œä¸è°ƒç”¨äº¤æ˜“æ‰€
   }
   
   // è°ƒç”¨äº¤æ˜“æ‰€GetTradeHistory
   trades, err := p.GetTradeHistory(ctx, symbol, 400)
   if err == nil {
       // ç¼“å­˜5åˆ†é’Ÿ
       orderHistoryTradeCache.Set(ctx, cacheKey, trades, 5*time.Minute)
   }
   ```

3. **ä½ä¼˜å…ˆçº§é™æµ**ï¼š
   ```go
   // ä¸ç­‰å¾…ï¼Œé¿å…å½±å“æŒä»“åˆ·æ–°ç­‰æ›´å…³é”®æ¥å£
   if !getTradeHistoryLimiter(apiId).Allow() {
       return nil, gerror.New("trade history rate limited")
   }
   ```

4. **å‘½ä¸­ç‡è‡ªé€‚åº”**ï¼š
   ```go
   // åˆå§‹æ‹‰å–400æ¡
   trades := fetchTrades(400)
   
   // å¦‚æœå‘½ä¸­ç‡<30%ï¼Œè‡ªåŠ¨æ‰©å¤§åˆ°1200æ¡
   hitRate := float64(hit) / float64(len(idSet))
   if hitRate < 0.30 {
       trades = fetchTrades(1200)
   }
   ```

---

## ç¼“å­˜æœºåˆ¶

### å¤šå±‚ç¼“å­˜æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     å®¢æˆ·ç«¯ï¼ˆå‰ç«¯ï¼‰                        â”‚
â”‚                    æµè§ˆå™¨å†…å­˜ç¼“å­˜                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚ HTTP Request
                       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              åç«¯ API å±‚ï¼ˆwallet.goï¼‰                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ orderHistoryTradeCache (gcache)                  â”‚   â”‚
â”‚  â”‚ TTL: 5 åˆ†é’Ÿ                                       â”‚   â”‚
â”‚  â”‚ Key: toogo:orderHistory:trades:{apiId}:{symbol}  â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
                       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          æœºå™¨äººå¼•æ“å±‚ï¼ˆRobotEngineï¼‰                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ OrderHistory []*exchange.Order                   â”‚   â”‚
â”‚  â”‚ LastOrderHistoryUpdate time.Time                 â”‚   â”‚
â”‚  â”‚ TTL: 120 ç§’ï¼ˆå¼•æ“å®šæ—¶åˆ·æ–°ï¼‰                        â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
                       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                æ•°æ®åº“ï¼ˆPostgreSQLï¼‰                       â”‚
â”‚            hg_trading_orderï¼ˆè®¢å•ä¸»è¡¨ï¼‰                   â”‚
â”‚         hg_trading_trade_fillï¼ˆæˆäº¤æµæ°´ï¼‰                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚ å®šæœŸåŒæ­¥ï¼ˆ120ç§’ï¼‰
                       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 äº¤æ˜“æ‰€ API                                â”‚
â”‚         Binance / Bitget / OKX / Gate                    â”‚
â”‚           GetOrderHistory() æ¥å£                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ç¼“å­˜å±‚çº§è¯´æ˜

#### 1ï¸âƒ£ å¼•æ“å±‚ç¼“å­˜ï¼ˆRobotEngineï¼‰

**ä½ç½®**: `internal/logic/toogo/robot_engine.go`

```go
type RobotEngine struct {
    // è®¢å•å†å²ç¼“å­˜
    OrderHistory []*exchange.Order
    LastOrderHistoryUpdate time.Time
    
    // å…¶ä»–ç¼“å­˜...
    CurrentPositions []*exchange.Position
    LastPositionUpdate time.Time
    AccountBalance *exchange.Balance
    LastBalanceUpdate time.Time
}

// GetCachedOrderHistory è·å–ç¼“å­˜çš„è®¢å•å†å²
func (e *RobotEngine) GetCachedOrderHistory() ([]*exchange.Order, time.Time) {
    e.mu.RLock()
    defer e.mu.RUnlock()
    return e.OrderHistory, e.LastOrderHistoryUpdate
}
```

**åˆ·æ–°ç­–ç•¥**ï¼š
- **å®šæ—¶åˆ·æ–°**: æ¯120ç§’è‡ªåŠ¨è°ƒç”¨äº¤æ˜“æ‰€APIåˆ·æ–°
- **è§¦å‘ç‚¹**: 
  - å¼•æ“å®šæ—¶ä»»åŠ¡ `refreshRemoteDataCacheTask()`
  - è®¢å•åŒæ­¥æœåŠ¡ `OrderStatusSyncService.syncRobotOrders()`
  - æ™ºèƒ½è·å–å‡½æ•° `GetOrderHistorySmart()`

**ä¼˜åŠ¿**ï¼š
- âœ… å‡å°‘90%ä»¥ä¸Šçš„APIè°ƒç”¨ï¼ˆ120ç§’å¤ç”¨ï¼‰
- âœ… åŒä¸€æœºå™¨äººå¤šæ¬¡æŸ¥è¯¢å…±äº«ç¼“å­˜
- âœ… çº¿ç¨‹å®‰å…¨ï¼ˆä½¿ç”¨ RWMutexï¼‰

#### 2ï¸âƒ£ APIå±‚ç¼“å­˜ï¼ˆorderHistoryTradeCacheï¼‰

**ä½ç½®**: `internal/logic/toogo/wallet.go`

```go
// TTL: 5åˆ†é’Ÿ
var orderHistoryTradeCache = gcache.New()

cacheKey := fmt.Sprintf("toogo:orderHistory:trades:%d:%s:%d", apiId, symbol, limit)
if v, _ := orderHistoryTradeCache.Get(ctx, cacheKey); v != nil {
    return cached, nil
}

trades, err := p.GetTradeHistory(ctx, symbol, limit)
if err == nil {
    // ç¼“å­˜5åˆ†é’Ÿï¼ˆä»åŸæ¥çš„10ç§’å»¶é•¿ï¼‰
    orderHistoryTradeCache.Set(ctx, cacheKey, trades, 5*time.Minute)
}
```

**é€‚ç”¨åœºæ™¯**ï¼š
- å‰ç«¯"äº¤æ˜“æ˜ç»†"é¡µé¢çš„é¢‘ç¹åˆ·æ–°
- åŒä¸€é¡µé¢å¤šæ¬¡è¯·æ±‚ç›¸åŒçš„è®¢å•åˆ—è¡¨

**ä¼˜åŠ¿**ï¼š
- âœ… 5åˆ†é’Ÿå†…åŒä¸€æŸ¥è¯¢ç›´æ¥è¿”å›ç¼“å­˜
- âœ… è¦†ç›–ç”¨æˆ·"åˆ·æ–°"ã€"åˆ‡æ¢é¡µé¢å†è¿”å›"ç­‰é«˜é¢‘åœºæ™¯
- âœ… å‡å°‘å¯¹å¼•æ“å±‚å’Œäº¤æ˜“æ‰€APIçš„å‹åŠ›

#### 3ï¸âƒ£ æ™ºèƒ½ç¼“å­˜å¤ç”¨å‡½æ•°

**ä½ç½®**: `internal/logic/toogo/robot_engine_order_history_smart.go`

```go
// GetOrderHistorySmart æ™ºèƒ½è·å–è®¢å•å†å²ï¼ˆç»Ÿä¸€å…¥å£ï¼‰
func (e *RobotEngine) GetOrderHistorySmart(ctx context.Context, startId int64, limit int) ([]*exchange.Order, error) {
    // 120s å†…ä¼˜å…ˆè¿”å›ç¼“å­˜
    e.mu.RLock()
    cached := e.OrderHistory
    last := e.LastOrderHistoryUpdate
    e.mu.RUnlock()
    
    if cached != nil && time.Since(last) < 120*time.Second {
        return cached, nil  // å¤ç”¨ç¼“å­˜
    }
    
    // ç¼“å­˜è¿‡æœŸï¼Œè°ƒç”¨äº¤æ˜“æ‰€API
    orders, err := ex.GetOrderHistory(ctx, robot.Symbol, limit)
    if err != nil {
        // APIå¤±è´¥åˆ™å›é€€ç¼“å­˜ï¼ˆé™çº§å¤„ç†ï¼‰
        if cached != nil {
            return cached, nil
        }
        return nil, err
    }
    
    // æ›´æ–°ç¼“å­˜
    e.mu.Lock()
    e.OrderHistory = orders
    e.LastOrderHistoryUpdate = time.Now()
    e.mu.Unlock()
    
    return orders, nil
}
```

**ç‰¹ç‚¹**ï¼š
- âœ… ç»Ÿä¸€å…¥å£ï¼Œé¿å…é‡å¤å®ç°
- âœ… é™çº§ç­–ç•¥ï¼šAPIå¤±è´¥æ—¶å›é€€åˆ°ç¼“å­˜
- âœ… æ”¯æŒ `OrderStatusSyncService` å’Œå…¶ä»–æ¨¡å—è°ƒç”¨

---

## è®¢å•åŒæ­¥æœºåˆ¶

### åŒé€šé“åŒæ­¥ç­–ç•¥

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   è®¢å•æ•°æ®åŒæ­¥æ¶æ„                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚   äº¤æ˜“æ‰€ API     â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚                   â”‚
        â–¼                   â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ WebSocket    â”‚    â”‚ REST API     â”‚
â”‚ (å®æ—¶æ¨é€)   â”‚    â”‚ (å®šæœŸè½®è¯¢)   â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚                   â”‚
       â”‚ ç§æœ‰WSè®¢å•äº‹ä»¶     â”‚ 120ç§’ä¸€æ¬¡
       â”‚ PrivateEvent      â”‚ GetOrderHistory
       â–¼                   â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  UpsertExchangeOrdersFrom       â”‚
â”‚  PrivateEvent()                 â”‚
â”‚  (exchange_order_store.go)      â”‚
â”‚  â†“ å†™å…¥                          â”‚
â”‚  hg_trading_exchange_order      â”‚
â”‚  (äº‹å®è¡¨ï¼Œä¾›å‰ç«¯æŒ‚å•åˆ—è¡¨)         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

                   â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  OrderStatusSyncService         â”‚
â”‚  (order_status_sync.go)         â”‚
â”‚  â†“ æ¯ç§’åŒæ­¥ä¸€æ¬¡è¿è¡Œä¸­çš„æœºå™¨äºº     â”‚
â”‚  syncRobotOrders()              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚
          â”œâ”€â†’ è·å–è®¢å•å†å²ï¼ˆ120ç§’èŠ‚æµï¼‰
          â”‚   engine.GetOrderHistorySmart()
          â”‚
          â”œâ”€â†’ åŒæ­¥åˆ°æ•°æ®åº“
          â”‚   SyncOrderHistoryToDB()
          â”‚   â†“
          â”‚   hg_trading_order
          â”‚
          â””â”€â†’ æŒä»“å¯¹è´¦ + çŠ¶æ€æ›´æ–°
              syncPositionsWithCache()
              syncLocalOrders()
```

### åŒæ­¥æµç¨‹è¯¦è§£

#### ğŸ”¹ WebSocket å®æ—¶æ¨é€

**æ–‡ä»¶**: `internal/logic/toogo/exchange_order_store.go`

```go
// UpsertExchangeOrdersFromPrivateEvent å¤„ç†ç§æœ‰WSè®¢å•äº‹ä»¶
func UpsertExchangeOrdersFromPrivateEvent(ctx context.Context, robotId int64, ev *exchange.PrivateEvent) {
    if ev == nil || ev.Type != exchange.PrivateEventOrder {
        return
    }
    
    // 1. è·å–æœºå™¨äººå…ƒæ•°æ®ï¼ˆå¸¦5ç§’ç¼“å­˜ï¼‰
    meta, err := getRobotMeta(ctx, robotId)
    
    // 2. è§£æè®¢å•äº‹ä»¶
    orders := parsePrivateOrderEvent(platform, ev.Raw)
    
    // 3. æ‰¹é‡ Upsert åˆ°äº‹å®è¡¨
    for _, order := range orders {
        upsertSingleOrder(ctx, meta, order)
    }
}
```

**ä¼˜åŠ¿**ï¼š
- âœ… **æ¯«ç§’çº§å®æ—¶æ€§**ï¼šè®¢å•çŠ¶æ€å˜æ›´ç«‹å³æ¨é€
- âœ… **ä½å»¶è¿Ÿ**ï¼šæ— éœ€è½®è¯¢ï¼Œå‡å°‘APIè°ƒç”¨
- âœ… **å¢é‡æ›´æ–°**ï¼šåªä¼ è¾“å˜æ›´çš„è®¢å•

**å±€é™**ï¼š
- âš ï¸ å¯èƒ½å­˜åœ¨ WS æ–­è¿/æ¼åŒ…çš„æƒ…å†µ
- âš ï¸ éœ€è¦ REST å®šæœŸåŒæ­¥åšå…œåº•

#### ğŸ”¹ REST å®šæœŸåŒæ­¥

**æ–‡ä»¶**: `internal/logic/toogo/order_status_sync.go`

##### åŒæ­¥æœåŠ¡å¯åŠ¨

```go
// StartOrderStatusSyncService å¯åŠ¨è®¢å•çŠ¶æ€åŒæ­¥æœåŠ¡
func StartOrderStatusSyncService(ctx context.Context) *OrderStatusSyncService {
    service := &OrderStatusSyncService{
        syncingRobots: make(map[int64]bool),
    }
    
    // æ¯1ç§’åŒæ­¥ä¸€æ¬¡æ‰€æœ‰è¿è¡Œä¸­çš„æœºå™¨äºº
    go func() {
        ticker := time.NewTicker(1 * time.Second)
        defer ticker.Stop()
        
        for {
            select {
            case <-ctx.Done():
                return
            case <-ticker.C:
                service.SyncAll(ctx)
            }
        }
    }()
    
    return service
}
```

##### åŒæ­¥å•ä¸ªæœºå™¨äºº

```go
// syncRobotOrders åŒæ­¥å•ä¸ªæœºå™¨äººçš„è®¢å•ä¿¡æ¯
func (s *OrderStatusSyncService) syncRobotOrders(ctx context.Context, robot *entity.TradingRobot) {
    // é˜²æ­¢å¹¶å‘åŒæ­¥
    if s.syncingRobots[robot.Id] {
        return
    }
    s.syncingRobots[robot.Id] = true
    defer func() {
        delete(s.syncingRobots, robot.Id)
    }()
    
    // è·å–å¼•æ“
    engine := GetRobotTaskManager().GetEngine(robot.Id)
    if engine == nil {
        return
    }
    
    // 1. è·å–ç¼“å­˜çš„è®¢å•å†å²å’ŒæŒä»“
    cachedPositions, _ := engine.GetCachedPositions()
    historyOrders, _ := engine.GetCachedOrderHistory()
    
    // 2. æ£€æŸ¥æ˜¯å¦éœ€è¦åˆ·æ–°ï¼ˆ120ç§’èŠ‚æµï¼‰
    engine.mu.RLock()
    lastSync := engine.LastOrderHistoryUpdate
    engine.mu.RUnlock()
    
    if time.Since(lastSync) >= 120*time.Second {
        // è°ƒç”¨æ™ºèƒ½è·å–ï¼ˆå†…éƒ¨æœ‰singleflighté˜²é‡ï¼‰
        fetchedOrders, err := engine.GetOrderHistorySmart(ctx, 0, 50)
        if err == nil {
            historyOrders = fetchedOrders
            
            // 3. åŒæ­¥åˆ°æ•°æ®åº“
            if len(fetchedOrders) > 0 {
                service.ToogoRobot().SyncOrderHistoryToDB(ctx, robot.Id, robot, fetchedOrders)
            }
        }
    }
    
    // 4. æŒä»“çŠ¶æ€åŒæ­¥ï¼ˆæ£€æµ‹æ‰‹åŠ¨å¹³ä»“ã€æœªå®ç°ç›ˆäºåˆ·æ–°ï¼‰
    s.syncPositionsWithCache(ctx, robot, engine.Exchange, cachedPositions, historyOrders)
    
    // 5. æœ¬åœ°è®¢å•è¡¥å…¨ï¼ˆå¸‚åœºçŠ¶æ€/é£é™©åå¥½ç­‰ï¼‰
    s.syncLocalOrders(ctx, robot, engine.Exchange, historyOrders)
    
    // 6. å…œåº•å¯¹è´¦ï¼šOpen Orderså†™å…¥äº‹å®è¡¨
    s.syncOpenOrdersToDBThrottled(ctx, robot, engine.Exchange)
}
```

**åŒæ­¥å†…å®¹**ï¼š

1. **è®¢å•å†å²åŒæ­¥** (`SyncOrderHistoryToDB`)ï¼š
   - å°†äº¤æ˜“æ‰€è®¢å•å†™å…¥ `hg_trading_order`
   - æ–°å¢è®¢å•ï¼šINSERT
   - å·²å­˜åœ¨è®¢å•ï¼šUPDATEï¼ˆè¡¥å…¨ä»·æ ¼ã€æ•°é‡ã€çŠ¶æ€ç­‰ï¼‰

2. **æŒä»“çŠ¶æ€å¯¹è´¦** (`syncPositionsWithCache`)ï¼š
   - æ£€æµ‹"äº¤æ˜“æ‰€æ— æŒä»“ä½†æœ¬åœ°æœ‰OPENè®¢å•" â†’ æ ‡è®°ä¸ºå·²å¹³ä»“ï¼ˆæ‰‹åŠ¨å¹³ä»“æ£€æµ‹ï¼‰
   - æ£€æµ‹"äº¤æ˜“æ‰€æœ‰æŒä»“ä½†æœ¬åœ°æ— è®¢å•" â†’ åˆ›å»ºè¡¥å•ï¼ˆå¤–éƒ¨æŒä»“å¯¼å…¥ï¼‰
   - æ›´æ–°æœªå®ç°ç›ˆäº (`unrealized_profit`)

3. **æœ¬åœ°è®¢å•è¡¥å…¨** (`syncLocalOrders`)ï¼š
   - ä»äº¤æ˜“æ‰€è®¢å•å†å²ä¸­è¡¥å…¨æœ¬åœ°è®¢å•çš„ç¼ºå¤±å­—æ®µ
   - ä¿®æ­£å¼€ä»“ä»·æ ¼ã€æˆäº¤æ•°é‡ã€äº¤æ˜“æ‰€è®¢å•IDç­‰

**é¢‘ç‡æ§åˆ¶**ï¼š
- **æ¯ç§’æ‰«æ**æ‰€æœ‰è¿è¡Œä¸­æœºå™¨äºº
- **120ç§’èŠ‚æµ**ï¼šåŒä¸€æœºå™¨äººæœ€å¤š120ç§’è°ƒç”¨ä¸€æ¬¡ `GetOrderHistory`
- **10ç§’èŠ‚æµ**ï¼šåŒä¸€æœºå™¨äººæœ€å¤š10ç§’è°ƒç”¨ä¸€æ¬¡ `GetOpenOrders`ï¼ˆæŒ‚å•å…œåº•ï¼‰

---

## è®¢å•çŠ¶æ€åŒæ­¥æœåŠ¡

### æ ¸å¿ƒç»„ä»¶

**æ–‡ä»¶**: `internal/logic/toogo/order_status_sync.go`

### ä¸»è¦åŠŸèƒ½

#### 1ï¸âƒ£ æ‰‹åŠ¨å¹³ä»“æ£€æµ‹

```go
// æ£€æµ‹é€»è¾‘ï¼š
// - æœ¬åœ°è®¢å•çŠ¶æ€ä¸º OPENï¼ˆstatus=1ï¼‰
// - äº¤æ˜“æ‰€æŒä»“ä¸ºç©ºæˆ–æŒä»“æ•°é‡ä¸º0
// - ç»“è®ºï¼šè®¢å•å·²åœ¨äº¤æ˜“æ‰€è¢«æ‰‹åŠ¨å¹³ä»“

for _, localOrder := range localOpenOrders {
    positionSide := localOrder.Direction == "long" ? "LONG" : "SHORT"
    exchangePos := exchangePositions[positionSide]
    
    if exchangePos == nil || exchangePos.PositionAmt == 0 {
        // æ£€æµ‹åˆ°æ‰‹åŠ¨å¹³ä»“
        g.Log().Infof(ctx, "[OrderStatusSync] æ£€æµ‹åˆ°æ‰‹åŠ¨å¹³ä»“: orderId=%d", localOrder.Id)
        
        // å°è¯•ä»æˆäº¤å†å²ä¸­æ¨æ–­å¹³ä»“ä¿¡æ¯
        closePrice, realizedPnl, closeFee, closeFeeCoin, closeOrderId, ts, ok := 
            tryCloseInfoFromTradeHistory(ctx, ex, robot.Symbol, positionSide, localOrder.OpenTime)
        
        if ok {
            // æ›´æ–°è®¢å•ä¸ºå·²å¹³ä»“
            updateOrderAsClosed(ctx, localOrder.Id, closePrice, realizedPnl, closeFee, 
                               closeFeeCoin, closeOrderId, ts, "manual_exchange")
        }
    }
}
```

#### 2ï¸âƒ£ å¤–éƒ¨æŒä»“æ£€æµ‹

```go
// æ£€æµ‹é€»è¾‘ï¼š
// - äº¤æ˜“æ‰€æœ‰æŒä»“
// - æœ¬åœ°æ— å¯¹åº”è®¢å•è®°å½•
// - ç»“è®ºï¼šå¤–éƒ¨å¼€ä»“ï¼ˆå…¶ä»–å®¢æˆ·ç«¯/æ‰‹åŠ¨æ“ä½œï¼‰

for positionSide, exchangePos := range exchangePositions {
    if !localOrderSides[positionSide] {
        g.Log().Infof(ctx, "[OrderStatusSync] æ£€æµ‹åˆ°å¤–éƒ¨æŒä»“: robotId=%d, positionSide=%s", 
                     robot.Id, positionSide)
        
        // ä»å†å²è®¢å•ä¸­æŸ¥æ‰¾åŒ¹é…çš„å¼€ä»“è®¢å•
        var matchedOrder *exchange.Order
        for _, histOrder := range historyOrders {
            if isOpenOrder(histOrder) && histOrder.PositionSide == positionSide {
                // æ£€æŸ¥æ•°æ®åº“æ˜¯å¦å·²å­˜åœ¨
                exists := checkOrderExists(ctx, robot.Id, histOrder.OrderId)
                if !exists {
                    matchedOrder = histOrder
                    break
                }
            }
        }
        
        if matchedOrder != nil {
            // åˆ›å»ºè®¢å•è®°å½•
            createOrderFromExchange(ctx, robot, matchedOrder, exchangePos)
        }
    }
}
```

#### 3ï¸âƒ£ æœªå®ç°ç›ˆäºæ›´æ–°

```go
// æŒä»“ä¸­çš„è®¢å•ï¼Œå®æ—¶æ›´æ–° unrealized_profit
for _, localOrder := range localOpenOrders {
    positionSide := localOrder.Direction == "long" ? "LONG" : "SHORT"
    exchangePos := exchangePositions[positionSide]
    
    if exchangePos != nil && exchangePos.UnrealizedProfit != 0 {
        // æ›´æ–°æœªå®ç°ç›ˆäº
        dao.TradingOrder.Ctx(ctx).
            Where("id", localOrder.Id).
            Update(g.Map{
                "unrealized_profit": exchangePos.UnrealizedProfit,
                "updated_at": gtime.Now(),
            })
    }
}
```

#### 4ï¸âƒ£ è®¢å•å­—æ®µè¡¥å…¨

```go
// syncLocalOrders ä»å†å²è®¢å•è¡¥å…¨æœ¬åœ°è®¢å•ç¼ºå¤±å­—æ®µ
func (s *OrderStatusSyncService) syncLocalOrders(ctx context.Context, robot *entity.TradingRobot, 
    ex exchange.Exchange, historyOrders []*exchange.Order) {
    
    // æŸ¥è¯¢æœ¬åœ°è®¢å•
    var localOrders []*entity.TradingOrder
    dao.TradingOrder.Ctx(ctx).
        Where("robot_id", robot.Id).
        Where("status", 1). // åªè¡¥å…¨æŒä»“ä¸­çš„è®¢å•
        Scan(&localOrders)
    
    // éå†åŒ¹é…
    for _, historyOrder := range historyOrders {
        orderIdToMatch := historyOrder.OrderId
        if orderIdToMatch == "" {
            orderIdToMatch = historyOrder.ClientId
        }
        
        for _, localOrder := range localOrders {
            if localOrder.ExchangeOrderId == orderIdToMatch || 
               localOrder.ClientOrderId == orderIdToMatch {
                
                updateData := g.Map{}
                
                // è¡¥å…¨å¼€ä»“ä»·æ ¼
                if localOrder.OpenPrice == 0 && historyOrder.AvgPrice > 0 {
                    updateData["open_price"] = historyOrder.AvgPrice
                }
                
                // è¡¥å…¨æˆäº¤æ•°é‡
                if localOrder.Quantity == 0 && historyOrder.FilledQty > 0 {
                    updateData["quantity"] = historyOrder.FilledQty
                }
                
                // è¡¥å…¨äº¤æ˜“æ‰€è®¢å•ID
                if localOrder.ExchangeOrderId == "" && historyOrder.OrderId != "" {
                    updateData["exchange_order_id"] = historyOrder.OrderId
                }
                
                // è¡¥å…¨å¼€ä»“æ—¶é—´
                if (localOrder.OpenTime == nil || localOrder.OpenTime.IsZero()) && 
                   historyOrder.CreateTime > 0 {
                    updateData["open_time"] = gtime.NewFromTimeStamp(historyOrder.CreateTime / 1000)
                }
                
                if len(updateData) > 0 {
                    dao.TradingOrder.Ctx(ctx).
                        Where("id", localOrder.Id).
                        Update(updateData)
                }
            }
        }
    }
}
```

---

## äº¤æ˜“æ‰€æ¥å£å®ç°

### Exchange æ¥å£å®šä¹‰

**æ–‡ä»¶**: `internal/library/exchange/exchange.go`

```go
type Exchange interface {
    // GetOrderHistory è·å–å†å²è®¢å•
    GetOrderHistory(ctx context.Context, symbol string, limit int) ([]*Order, error)
    
    // GetOpenOrders è·å–å½“å‰æŒ‚å•
    GetOpenOrders(ctx context.Context, symbol string) ([]*Order, error)
    
    // GetPositions è·å–æŒä»“
    GetPositions(ctx context.Context, symbol string) ([]*Position, error)
    
    // å…¶ä»–æ–¹æ³•...
}

// ExchangeAdvanced é«˜çº§æ¥å£ï¼ˆå¯é€‰å®ç°ï¼‰
type ExchangeAdvanced interface {
    Exchange
    
    // GetTradeHistory è·å–æˆäº¤è®°å½•
    GetTradeHistory(ctx context.Context, symbol string, limit int) ([]*Trade, error)
}
```

### å„äº¤æ˜“æ‰€å®ç°å¯¹æ¯”

#### 1ï¸âƒ£ Binance

**æ–‡ä»¶**: `internal/library/exchange/binance.go`

```go
// GetOrderHistory è·å–å†å²è®¢å•
func (b *Binance) GetOrderHistory(ctx context.Context, symbol string, limit int) ([]*Order, error) {
    params := map[string]string{
        "limit": strconv.Itoa(limit),
    }
    if symbol != "" {
        params["symbol"] = b.formatSymbol(symbol)
    }
    
    // è°ƒç”¨å¸å®‰API: GET /fapi/v1/allOrders
    resp, err := b.signedRequest(ctx, "GET", "/fapi/v1/allOrders", params)
    if err != nil {
        return nil, err
    }
    
    var orders []*Order
    json.Unmarshal(resp, &orders)
    
    return orders, nil
}
```

**ç‰¹ç‚¹**ï¼š
- âœ… æ”¯æŒè·å–å…¨éƒ¨å†å²è®¢å•
- âœ… å¯æŒ‡å®š symbol ç­›é€‰
- âš ï¸ limit æœ€å¤§å€¼ï¼š1000

#### 2ï¸âƒ£ Bitget

**æ–‡ä»¶**: `internal/library/exchange/bitget.go`

```go
// GetOrderHistory è·å–æˆäº¤æ˜ç»†
func (b *Bitget) GetOrderHistory(ctx context.Context, symbol string, limit int) ([]*Order, error) {
    if symbol == "" {
        return nil, gerror.New("symbol is required for fills")
    }
    
    params := map[string]string{
        "productType": "USDT-FUTURES",
        "symbol":      b.formatSymbol(symbol),
    }
    if limit > 0 {
        params["pageSize"] = strconv.Itoa(limit)
    }
    
    // è°ƒç”¨Bitget V2 API: GET /api/v2/mix/order/fills
    resp, err := b.signedRequest(ctx, "GET", "/api/v2/mix/order/fills", params)
    if err != nil {
        return nil, err
    }
    
    // è§£æå“åº”...
    return orders, nil
}
```

**ç‰¹ç‚¹**ï¼š
- âœ… V2 APIï¼Œæ›´ç¨³å®š
- âš ï¸ **å¿…é¡»æä¾› symbol**ï¼ˆä¸æ”¯æŒå…¨é‡æŸ¥è¯¢ï¼‰
- âš ï¸ limit æœ€å¤§å€¼ï¼š100

#### 3ï¸âƒ£ OKX

**æ–‡ä»¶**: `internal/library/exchange/okx.go`

```go
// GetOrderHistory è·å–å†å²è®¢å•
func (o *OKX) GetOrderHistory(ctx context.Context, symbol string, limit int) ([]*Order, error) {
    q := url.Values{}
    q.Set("instType", "SWAP")
    q.Set("limit", strconv.Itoa(limit))
    if symbol != "" {
        q.Set("instId", o.formatInstId(symbol))
    }
    
    // è°ƒç”¨OKX API: GET /api/v5/trade/orders-history
    raw, err := o.signedRequest(ctx, "GET", "/api/v5/trade/orders-history", q, nil)
    if err != nil {
        return nil, err
    }
    
    // è§£æå“åº”...
    return orders, nil
}
```

**ç‰¹ç‚¹**ï¼š
- âœ… æ”¯æŒåˆçº¦ç±»å‹ç­›é€‰ (`instType`)
- âœ… æ”¯æŒå…¨é‡æŸ¥è¯¢ï¼ˆä¸ä¼  symbolï¼‰
- âš ï¸ limit æœ€å¤§å€¼ï¼š100

#### 4ï¸âƒ£ Gate.io

**æ–‡ä»¶**: `internal/library/exchange/gate.go`

```go
// GetOrderHistory è·å–å†å²è®¢å•
func (gt *Gate) GetOrderHistory(ctx context.Context, symbol string, limit int) ([]*Order, error) {
    contract := gt.formatContract(symbol)
    q := url.Values{}
    q.Set("contract", contract)
    q.Set("status", "finished")
    q.Set("limit", strconv.Itoa(limit))
    
    // è°ƒç”¨Gate API: GET /futures/usdt/orders
    raw, err := gt.signedRequest(ctx, "GET", "/futures/usdt/orders", q, nil)
    if err != nil {
        return nil, err
    }
    
    // è§£æå“åº”...
    return orders, nil
}
```

**ç‰¹ç‚¹**ï¼š
- âœ… æ˜ç¡®åªæŸ¥è¯¢ "finished" çŠ¶æ€è®¢å•
- âš ï¸ **å¿…é¡»æä¾› contract**
- âš ï¸ limit æœ€å¤§å€¼ï¼šæœªæ˜ç¡®

### ç»Ÿä¸€è®¢å•æ¨¡å‹

```go
type Order struct {
    OrderId      string  // äº¤æ˜“æ‰€è®¢å•ID
    ClientId     string  // å®¢æˆ·ç«¯è®¢å•ID
    Symbol       string  // äº¤æ˜“å¯¹
    Side         string  // ä¹°å–æ–¹å‘: BUY/SELL
    PositionSide string  // æŒä»“æ–¹å‘: LONG/SHORT
    Type         string  // è®¢å•ç±»å‹: MARKET/LIMIT/å¼€ä»“/å¹³ä»“
    Price        float64 // å§”æ‰˜ä»·æ ¼
    Quantity     float64 // å§”æ‰˜æ•°é‡
    FilledQty    float64 // å·²æˆäº¤æ•°é‡
    AvgPrice     float64 // æˆäº¤å‡ä»·
    Status       string  // è®¢å•çŠ¶æ€: NEW/FILLED/CANCELED
    CreateTime   int64   // åˆ›å»ºæ—¶é—´ï¼ˆæ¯«ç§’æ—¶é—´æˆ³ï¼‰
    UpdateTime   int64   // æ›´æ–°æ—¶é—´ï¼ˆæ¯«ç§’æ—¶é—´æˆ³ï¼‰
}
```

---

## æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### å·²å®æ–½çš„ä¼˜åŒ–

#### âœ… 1. å¤šå±‚ç¼“å­˜å‡å°‘APIè°ƒç”¨

| å±‚çº§ | TTL | æ•ˆæœ |
|------|-----|------|
| å¼•æ“ç¼“å­˜ | 120ç§’ | å‡å°‘90%+çš„APIè°ƒç”¨ |
| APIç¼“å­˜ | 5åˆ†é’Ÿ | å‰ç«¯åˆ·æ–°æ—¶å‘½ä¸­ç‡>80% |
| æ™ºèƒ½åˆ¤æ–­ | - | è€è®¢å•ä¸è°ƒç”¨API |

**æ•°æ®æ”¯æŒ**ï¼š
- ä¼˜åŒ–å‰ï¼šæ¯æ¬¡æŸ¥è¯¢éƒ½è°ƒç”¨äº¤æ˜“æ‰€API
- ä¼˜åŒ–åï¼š120ç§’å†…åŒä¸€æœºå™¨äººå…±äº«ç¼“å­˜
- **APIè°ƒç”¨å‡å°‘çº¦95%**

#### âœ… 2. æ•°æ®åº“ç´¢å¼•ä¼˜åŒ–

```sql
-- è®¢å•å†å²æŸ¥è¯¢æ ¸å¿ƒç´¢å¼•
CREATE INDEX idx_user_status_closetime ON hg_trading_order(user_id, status, close_time);
CREATE INDEX idx_robot_status ON hg_trading_order(robot_id, status);
CREATE INDEX idx_exchange_order_id ON hg_trading_order(exchange_order_id);
CREATE INDEX idx_close_time ON hg_trading_order(close_time);

-- æˆäº¤æµæ°´æŸ¥è¯¢ç´¢å¼•
CREATE INDEX idx_user_robot_ts ON hg_trading_trade_fill(user_id, robot_id, ts);
CREATE INDEX idx_order_id ON hg_trading_trade_fill(order_id);
```

**æ•ˆæœ**ï¼š
- è®¢å•å†å²åˆ—è¡¨æŸ¥è¯¢ä» **200ms â†’ 10ms**
- å¤§æ•°æ®é‡ï¼ˆ10ä¸‡+è®¢å•ï¼‰ä¸‹ä»ä¿æŒä½å»¶è¿Ÿ

#### âœ… 3. æ™ºèƒ½æ•°æ®å¢å¼º

```go
// åªå¯¹"è¿‘14å¤©çš„å·²å¹³ä»“è®¢å•"ä¸”"å…³é”®å­—æ®µç¼ºå¤±"æ—¶è°ƒç”¨äº¤æ˜“æ‰€
needExchangeQuery := (order.Status == 2) && 
                     (order.CloseTime.After(now.Add(-14*24*time.Hour))) &&
                     (order.RealizedProfit == 0 || order.CloseFee == 0)
```

**å‡å°‘æ¯”ä¾‹**ï¼š
- ä¼˜åŒ–å‰ï¼š100%è®¢å•è°ƒç”¨API
- ä¼˜åŒ–åï¼šçº¦10-20%è®¢å•éœ€è¦è°ƒç”¨API
- **å‡å°‘80-90%çš„TradeHistoryè°ƒç”¨**

#### âœ… 4. é™æµä¿æŠ¤

```go
// ä½ä¼˜å…ˆçº§é™æµå™¨ï¼ˆè®¢å•å†å²æŸ¥è¯¢ï¼‰
getTradeHistoryLimiter(apiId).Allow()

// ä¸ç­‰å¾…ï¼Œç›´æ¥è·³è¿‡ï¼Œé¿å…å½±å“æŒä»“åˆ·æ–°ç­‰å…³é”®æ¥å£
if !limiter.Allow() {
    return nil, gerror.New("trade history rate limited")
}
```

**ä¿æŠ¤æœºåˆ¶**ï¼š
- æŒä»“åˆ·æ–°ã€ä¸‹å•ç­‰é«˜ä¼˜å…ˆçº§æ“ä½œä¸å—é™æµå½±å“
- è®¢å•å†å²æŸ¥è¯¢åœ¨é«˜è´Ÿè½½æ—¶é™çº§ï¼ˆä½¿ç”¨æ•°æ®åº“æ•°æ®ï¼‰

#### âœ… 5. å‘½ä¸­ç‡è‡ªé€‚åº”

```go
// åˆå§‹æ‹‰å–400æ¡
trades := fetchTrades(400)

// å‘½ä¸­ç‡æ£€æŸ¥
hitRate := float64(hit) / float64(len(idSet))
if hitRate < 0.30 {
    // è‡ªåŠ¨æ‰©å¤§åˆ°1200æ¡
    trades = fetchTrades(1200)
}
```

**æ™ºèƒ½æ‰©å±•**ï¼š
- ä½äº¤æ˜“é‡ï¼š400æ¡è¶³å¤Ÿï¼ŒèŠ‚çœèµ„æº
- é«˜äº¤æ˜“é‡ï¼šè‡ªåŠ¨æ‰©å±•åˆ°1200æ¡ï¼Œç¡®ä¿å®Œæ•´æ€§

### æ€§èƒ½æŒ‡æ ‡å¯¹æ¯”

| æŒ‡æ ‡ | ä¼˜åŒ–å‰ | ä¼˜åŒ–å | æå‡ |
|------|--------|--------|------|
| è®¢å•åˆ—è¡¨æŸ¥è¯¢ï¼ˆDBï¼‰ | 200ms | 10ms | **20å€** |
| äº¤æ˜“æ‰€APIè°ƒç”¨é¢‘ç‡ | æ¯æ¬¡è¯·æ±‚ | 120ç§’/æ¬¡ | **å‡å°‘95%** |
| TradeHistoryè°ƒç”¨ | 100% | 10-20% | **å‡å°‘80-90%** |
| å‰ç«¯é¡µé¢åŠ è½½ | 1-2ç§’ | 300-500ms | **2-4å€** |
| å¹¶å‘æ”¯æŒ | 10 QPS | 100+ QPS | **10å€+** |

---

## æ—¶åºå›¾

### å®Œæ•´è®¢å•è·å–æµç¨‹

```mermaid
sequenceDiagram
    participant å‰ç«¯
    participant APIå±‚
    participant Engine
    participant æ•°æ®åº“
    participant äº¤æ˜“æ‰€

    å‰ç«¯->>APIå±‚: GET /order-history (page=1)
    
    APIå±‚->>æ•°æ®åº“: æŸ¥è¯¢è®¢å•ä¸»è¡¨ (hg_trading_order)
    æ•°æ®åº“-->>APIå±‚: è¿”å›è®¢å•åˆ—è¡¨ (orders)
    
    Note over APIå±‚: æ™ºèƒ½åˆ¤æ–­æ˜¯å¦éœ€è¦å¢å¼º
    
    alt éœ€è¦å¢å¼ºï¼ˆè¿‘14å¤©+å­—æ®µç¼ºå¤±ï¼‰
        APIå±‚->>APIå±‚: æ£€æŸ¥ orderHistoryTradeCache (5åˆ†é’ŸTTL)
        
        alt ç¼“å­˜æœªå‘½ä¸­
            APIå±‚->>Engine: æ£€æŸ¥å¼•æ“ç¼“å­˜ (120ç§’TTL)
            
            alt å¼•æ“ç¼“å­˜è¿‡æœŸ
                Engine->>äº¤æ˜“æ‰€: GetTradeHistory(symbol, 400)
                äº¤æ˜“æ‰€-->>Engine: è¿”å›æˆäº¤è®°å½•
                Engine->>Engine: æ›´æ–°ç¼“å­˜
            end
            
            Engine-->>APIå±‚: è¿”å›æˆäº¤è®°å½• (trades)
            APIå±‚->>APIå±‚: èšåˆè®¡ç®—ç›ˆäº/æ‰‹ç»­è´¹
            APIå±‚->>APIå±‚: å†™å…¥ç¼“å­˜ (5åˆ†é’Ÿ)
        end
    end
    
    APIå±‚->>APIå±‚: æ„å»ºå®Œæ•´å“åº” (enriched orders)
    APIå±‚-->>å‰ç«¯: è¿”å›å¢å¼ºåçš„è®¢å•åˆ—è¡¨
    
    Note over å‰ç«¯: æ¸²æŸ“è®¢å•åˆ—è¡¨
```

### è®¢å•åŒæ­¥æµç¨‹

```mermaid
sequenceDiagram
    participant WS as WebSocket
    participant Sync as OrderStatusSync
    participant Engine as RobotEngine
    participant DB as æ•°æ®åº“
    participant Exchange as äº¤æ˜“æ‰€

    Note over Sync: æ¯ç§’æ‰«æè¿è¡Œä¸­æœºå™¨äºº
    
    loop æ¯1ç§’
        Sync->>Sync: SyncAll()
        
        Sync->>Engine: è·å–ç¼“å­˜è®¢å•å†å²
        Engine-->>Sync: historyOrders (120ç§’å†…)
        
        alt ç¼“å­˜è¿‡æœŸ (>120ç§’)
            Sync->>Engine: GetOrderHistorySmart()
            Engine->>Exchange: GetOrderHistory(symbol, 50)
            Exchange-->>Engine: è¿”å›è®¢å•åˆ—è¡¨
            Engine->>Engine: æ›´æ–°ç¼“å­˜
            Engine-->>Sync: è¿”å›æœ€æ–°è®¢å•
            
            Sync->>DB: SyncOrderHistoryToDB()
            Note over DB: INSERTæ–°è®¢å•<br/>UPDATEå·²å­˜åœ¨è®¢å•
        end
        
        Sync->>Sync: syncPositionsWithCache()
        Note over Sync: æ£€æµ‹æ‰‹åŠ¨å¹³ä»“<br/>æ£€æµ‹å¤–éƒ¨æŒä»“<br/>æ›´æ–°æœªå®ç°ç›ˆäº
        
        Sync->>Sync: syncLocalOrders()
        Note over Sync: è¡¥å…¨è®¢å•å­—æ®µ
    end
    
    par WebSocketå®æ—¶æ¨é€
        WS->>DB: UpsertExchangeOrders()
        Note over DB: å†™å…¥äº‹å®è¡¨<br/>ä¾›å‰ç«¯æŒ‚å•åˆ—è¡¨
    end
```

---

## é—®é¢˜ä¸å»ºè®®

### å½“å‰å­˜åœ¨çš„é—®é¢˜

#### âš ï¸ 1. WebSocketæ–­è¿å¤„ç†

**ç°è±¡**ï¼š
- WebSocketè¿æ¥æ–­å¼€åï¼Œå¯èƒ½ä¸¢å¤±è®¢å•çŠ¶æ€å˜æ›´äº‹ä»¶
- è™½ç„¶æœ‰RESTå…œåº•ï¼Œä½†å­˜åœ¨æœ€å¤š120ç§’çš„å»¶è¿Ÿ

**å»ºè®®**ï¼š
```go
// æ·»åŠ  WS é‡è¿æ—¶çš„å…¨é‡å¯¹è´¦é€»è¾‘
func onWebSocketReconnect(ctx context.Context, robotId int64) {
    // è§¦å‘ä¸€æ¬¡å…¨é‡è®¢å•åŒæ­¥
    engine := GetRobotTaskManager().GetEngine(robotId)
    if engine != nil {
        engine.mu.Lock()
        engine.LastOrderHistoryUpdate = time.Time{} // é‡ç½®ç¼“å­˜
        engine.mu.Unlock()
        
        // ç«‹å³åŒæ­¥
        service.OrderStatusSync().syncRobotOrders(ctx, robot)
    }
}
```

#### âš ï¸ 2. æˆäº¤å†å²å‘½ä¸­ç‡é—®é¢˜

**ç°è±¡**ï¼š
- é«˜é¢‘äº¤æ˜“æœºå™¨äººçš„æˆäº¤è®°å½•è¶…è¿‡1200æ¡æ—¶ï¼Œå¯èƒ½æ— æ³•å®Œå…¨è¦†ç›–
- å¯¼è‡´éƒ¨åˆ†è®¢å•çš„ç›ˆäº/æ‰‹ç»­è´¹æ•°æ®ç¼ºå¤±

**å»ºè®®**ï¼š
```go
// æ·»åŠ åˆ†é¡µæ‹‰å–é€»è¾‘
func fetchAllTradesForOrder(ctx context.Context, ex exchange.Exchange, 
    symbol string, orderId string) ([]*exchange.Trade, error) {
    
    var allTrades []*exchange.Trade
    lastId := ""
    
    for {
        trades, err := ex.GetTradeHistory(ctx, symbol, 1000)
        if err != nil || len(trades) == 0 {
            break
        }
        
        // è¿‡æ»¤ç›®æ ‡è®¢å•
        for _, t := range trades {
            if t.OrderId == orderId {
                allTrades = append(allTrades, t)
            }
        }
        
        // æ£€æŸ¥æ˜¯å¦éœ€è¦ç»§ç»­åˆ†é¡µ
        if len(trades) < 1000 {
            break
        }
        lastId = trades[len(trades)-1].Id
    }
    
    return allTrades, nil
}
```

#### âš ï¸ 3. æ•°æ®åº“å†™å…¥é¢‘ç‡

**ç°è±¡**ï¼š
- æ¯ç§’åŒæ­¥æ‰€æœ‰è¿è¡Œä¸­æœºå™¨äººï¼Œé«˜å¹¶å‘æ—¶æ•°æ®åº“å‹åŠ›å¤§
- å¤§é‡ UPDATE æ“ä½œå¯èƒ½å¯¼è‡´é”ç«äº‰

**å»ºè®®**ï¼š
```go
// æ·»åŠ æ‰¹é‡æ›´æ–°é€»è¾‘
func (s *sToogoRobot) SyncOrderHistoryToDBBatch(ctx context.Context, 
    updates map[int64]map[string]interface{}) error {
    
    // ä½¿ç”¨äº‹åŠ¡æ‰¹é‡æ›´æ–°
    tx, err := g.DB().Begin(ctx)
    if err != nil {
        return err
    }
    defer tx.Rollback()
    
    for orderId, updateData := range updates {
        _, err := tx.Model("hg_trading_order").
            Where("id", orderId).
            Update(updateData)
        if err != nil {
            return err
        }
    }
    
    return tx.Commit()
}
```

#### âš ï¸ 4. æ—¶é—´æˆ³ç²¾åº¦é—®é¢˜

**ç°è±¡**ï¼š
- éƒ¨åˆ†äº¤æ˜“æ‰€è¿”å›çš„æ—¶é—´æˆ³æ˜¯ç§’çº§ï¼Œéƒ¨åˆ†æ˜¯æ¯«ç§’çº§
- å¯èƒ½å¯¼è‡´æ—¶é—´å­—æ®µæ··ä¹±

**å»ºè®®**ï¼š
```go
// ç»Ÿä¸€æ—¶é—´æˆ³å¤„ç†å‡½æ•°
func normalizeTimestamp(ts int64) int64 {
    // åˆ¤æ–­æ˜¯ç§’è¿˜æ˜¯æ¯«ç§’
    if ts < 10000000000 {
        // ç§’çº§æ—¶é—´æˆ³ï¼Œè½¬ä¸ºæ¯«ç§’
        return ts * 1000
    }
    return ts
}

// ä½¿ç”¨ç¤ºä¾‹
openTime := gtime.NewFromTimeStamp(normalizeTimestamp(order.CreateTime) / 1000)
```

### ä¼˜åŒ–å»ºè®®

#### âœ… 1. å¢åŠ è®¢å•çŠ¶æ€å˜æ›´é€šçŸ¥

```go
// å½“è®¢å•çŠ¶æ€å˜æ›´æ—¶ï¼Œå‘é€ WebSocket é€šçŸ¥åˆ°å‰ç«¯
func notifyOrderStatusChange(ctx context.Context, orderId int64, newStatus int) {
    event := &OrderStatusChangeEvent{
        OrderId:   orderId,
        NewStatus: newStatus,
        Timestamp: time.Now().UnixMilli(),
    }
    
    // æ¨é€åˆ°å‰ç«¯ WebSocket
    service.WebSocket().BroadcastToUser(userId, "order_status_change", event)
}
```

#### âœ… 2. æ·»åŠ è®¢å•å¯¹è´¦æ—¥å¿—

```go
// æ¯æ—¥å®šæ—¶å¯¹è´¦ï¼šå¯¹æ¯”æ•°æ®åº“è®¢å•ä¸äº¤æ˜“æ‰€è®¢å•
func dailyOrderReconciliation(ctx context.Context) error {
    // 1. è·å–æ˜¨æ—¥æ‰€æœ‰è®¢å•
    var orders []*entity.TradingOrder
    dao.TradingOrder.Ctx(ctx).
        WhereGTE("created_at", gtime.Now().Add(-24*time.Hour)).
        Scan(&orders)
    
    // 2. é€ä¸ªå¯¹è´¦
    for _, order := range orders {
        // è·å–äº¤æ˜“æ‰€è®¢å•è¯¦æƒ…
        exOrder, err := ex.GetOrder(ctx, order.Symbol, order.ExchangeOrderId)
        if err != nil {
            continue
        }
        
        // 3. å¯¹æ¯”å…³é”®å­—æ®µ
        if math.Abs(order.OpenPrice-exOrder.AvgPrice) > 0.01 {
            g.Log().Warningf(ctx, "[å¯¹è´¦å¼‚å¸¸] orderId=%d, å¼€ä»“ä»·æ ¼ä¸ä¸€è‡´: db=%.4f, exchange=%.4f",
                order.Id, order.OpenPrice, exOrder.AvgPrice)
        }
        
        if math.Abs(order.Quantity-exOrder.FilledQty) > 0.0001 {
            g.Log().Warningf(ctx, "[å¯¹è´¦å¼‚å¸¸] orderId=%d, æˆäº¤æ•°é‡ä¸ä¸€è‡´: db=%.4f, exchange=%.4f",
                order.Id, order.Quantity, exOrder.FilledQty)
        }
    }
    
    return nil
}
```

#### âœ… 3. ä¼˜åŒ–æ•°æ®åº“æŸ¥è¯¢

```sql
-- æ·»åŠ å¤åˆç´¢å¼•
CREATE INDEX idx_robot_status_closetime ON hg_trading_order(robot_id, status, close_time DESC);

-- æ·»åŠ éƒ¨åˆ†ç´¢å¼•ï¼ˆåªç´¢å¼•æŒä»“ä¸­çš„è®¢å•ï¼‰
CREATE INDEX idx_open_orders ON hg_trading_order(robot_id, exchange_order_id) 
WHERE status = 1;
```

#### âœ… 4. å¢åŠ ç›‘æ§æŒ‡æ ‡

```go
// æ·»åŠ  Prometheus ç›‘æ§æŒ‡æ ‡
var (
    orderSyncDuration = prometheus.NewHistogramVec(
        prometheus.HistogramOpts{
            Name: "order_sync_duration_seconds",
            Help: "è®¢å•åŒæ­¥è€—æ—¶",
        },
        []string{"robot_id", "result"},
    )
    
    orderCacheHitRate = prometheus.NewGaugeVec(
        prometheus.GaugeOpts{
            Name: "order_cache_hit_rate",
            Help: "è®¢å•ç¼“å­˜å‘½ä¸­ç‡",
        },
        []string{"cache_type"},
    )
    
    exchangeApiCalls = prometheus.NewCounterVec(
        prometheus.CounterOpts{
            Name: "exchange_api_calls_total",
            Help: "äº¤æ˜“æ‰€APIè°ƒç”¨æ¬¡æ•°",
        },
        []string{"exchange", "method", "result"},
    )
)
```

---

## æ€»ç»“

### æ ¸å¿ƒè®¾è®¡åŸåˆ™

1. **åˆ†å±‚ç¼“å­˜** - å¼•æ“ç¼“å­˜(120s) + APIç¼“å­˜(5min) + æ•°æ®åº“æŒä¹…åŒ–
2. **æ™ºèƒ½åˆ¤æ–­** - åªå¯¹"è¿‘æœŸ+ç¼ºå¤±å­—æ®µ"çš„è®¢å•è°ƒç”¨äº¤æ˜“æ‰€API
3. **åŒé€šé“åŒæ­¥** - WebSocketå®æ—¶æ¨é€ + RESTå®šæœŸå…œåº•
4. **é™çº§ç­–ç•¥** - APIå¤±è´¥æ—¶å›é€€åˆ°ç¼“å­˜/æ•°æ®åº“
5. **æ€§èƒ½ä¼˜å…ˆ** - æ•°æ®åº“ç´¢å¼•ä¼˜åŒ– + é™æµä¿æŠ¤ + æ‰¹é‡å¤„ç†

### æ•°æ®æµè½¬è·¯å¾„

```
äº¤æ˜“æ‰€ â†’ WebSocketæ¨é€ â†’ äº‹å®è¡¨ (å®æ—¶)
   â†“
äº¤æ˜“æ‰€ â†’ RESTå®šæœŸæ‹‰å– â†’ å¼•æ“ç¼“å­˜(120s) â†’ æ•°æ®åº“ (å…œåº•)
   â†“
æ•°æ®åº“ â†’ APIç¼“å­˜(5min) â†’ å‰ç«¯å±•ç¤º
```

### å…³é”®æŒ‡æ ‡

- **APIè°ƒç”¨å‡å°‘**: 95%
- **æŸ¥è¯¢å“åº”æ—¶é—´**: 10msï¼ˆä¼˜åŒ–åï¼‰
- **ç¼“å­˜å‘½ä¸­ç‡**: 80%+
- **å¹¶å‘æ”¯æŒ**: 100+ QPS
- **æ•°æ®ä¸€è‡´æ€§**: æœ€ç»ˆä¸€è‡´æ€§ï¼ˆæœ€å¤§å»¶è¿Ÿ120ç§’ï¼‰

---

**æŠ¥å‘Šç»“æŸ**

