# 生产环境更新部署方案（零停机/最小停机）

## 一、部署策略选择

### 策略对比

| 策略 | 停机时间 | 复杂度 | 成本 | 推荐场景 |
|------|---------|--------|------|---------|
| **直接重启** | 30-60秒 | ⭐ 简单 | 无 | 凌晨维护窗口 |
| **滚动更新** | 0秒 | ⭐⭐⭐ 中等 | 需要2台服务器 | 中等规模 |
| **蓝绿部署** | <5秒 | ⭐⭐⭐⭐ 较复杂 | 需要2倍服务器 | 大规模生产 |
| **热重载** | 0秒 | ⭐⭐ 中等 | 无 | Go应用（优先推荐）|

---

## 二、推荐方案：优雅重启 + 自动化脚本 ⭐⭐⭐⭐⭐

### 2.1 方案特点

- ✅ **停机时间**: <5秒
- ✅ **成本**: 无需额外服务器
- ✅ **复杂度**: 低
- ✅ **风险**: 低（支持回滚）

### 2.2 核心原理

```
旧进程处理完当前请求后优雅退出
     ↓
新进程启动并监听端口
     ↓
切换流量到新进程
     ↓
总停机时间: 2-5秒
```

---

## 三、实施方案（单服务器）

### 3.1 代码层面：实现优雅退出

**修改 Go 应用主文件**

```go
// main.go
package main

import (
    "context"
    "os"
    "os/signal"
    "syscall"
    "time"
    
    "github.com/gogf/gf/v2/frame/g"
    "github.com/gogf/gf/v2/net/ghttp"
    "github.com/gogf/gf/v2/os/gctx"
)

func main() {
    ctx := gctx.New()
    s := g.Server()
    
    // 配置路由
    initRouter(s)
    
    // 启动服务器
    go func() {
        if err := s.Start(); err != nil {
            g.Log().Fatal(ctx, err)
        }
    }()
    
    // 监听系统信号
    quit := make(chan os.Signal, 1)
    signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
    <-quit
    
    g.Log().Info(ctx, "收到退出信号，开始优雅关闭...")
    
    // 优雅关闭流程
    gracefulShutdown(ctx, s)
}

func gracefulShutdown(ctx context.Context, s *ghttp.Server) {
    // 1. 停止接收新连接
    g.Log().Info(ctx, "停止接收新请求...")
    
    // 2. 等待现有请求处理完成（最多30秒）
    shutdownCtx, cancel := context.WithTimeout(ctx, 30*time.Second)
    defer cancel()
    
    // 3. 关闭交易引擎（重要！）
    g.Log().Info(ctx, "关闭交易引擎...")
    closeAllTradingEngines(ctx)
    
    // 4. 关闭数据库连接
    g.Log().Info(ctx, "关闭数据库连接...")
    closeDatabase(ctx)
    
    // 5. 关闭Redis连接
    g.Log().Info(ctx, "关闭Redis连接...")
    closeRedis(ctx)
    
    // 6. 关闭HTTP服务器
    if err := s.Shutdown(); err != nil {
        g.Log().Errorf(ctx, "服务器关闭失败: %v", err)
    }
    
    g.Log().Info(ctx, "服务器已优雅关闭")
}

// 关闭所有交易引擎（避免数据不一致）
func closeAllTradingEngines(ctx context.Context) {
    // TODO: 实现你的交易引擎关闭逻辑
    // 1. 停止所有机器人接收新信号
    // 2. 等待当前正在处理的交易完成
    // 3. 保存状态到数据库
    
    g.Log().Info(ctx, "所有交易引擎已关闭")
}
```

---

### 3.2 系统层面：Systemd 服务配置

**创建 Systemd 服务文件**

```ini
# /etc/systemd/system/hotgo.service

[Unit]
Description=HotGo Trading System
After=network.target postgresql.service redis.service
Wants=postgresql.service redis.service

[Service]
Type=simple
User=hotgo
Group=hotgo
WorkingDirectory=/opt/hotgo/server
ExecStart=/opt/hotgo/server/main http
ExecReload=/bin/kill -HUP $MAINPID

# 优雅关闭配置
KillMode=mixed
KillSignal=SIGTERM
TimeoutStopSec=30
Restart=on-failure
RestartSec=5s

# 环境变量
Environment="GF_GCFG_PATH=/opt/hotgo/server/manifest/config"
Environment="GF_GLOG_PATH=/opt/hotgo/server/logs"

# 资源限制
LimitNOFILE=65536
LimitNPROC=4096

# 日志
StandardOutput=journal
StandardError=journal

[Install]
WantedBy=multi-user.target
```

**启用并启动服务**

```bash
# 重新加载 systemd
sudo systemctl daemon-reload

# 启用开机自启
sudo systemctl enable hotgo

# 启动服务
sudo systemctl start hotgo

# 查看状态
sudo systemctl status hotgo
```

---

## 四、自动化部署脚本

### 4.1 完整部署脚本（推荐）⭐

```bash
#!/bin/bash
# deploy.sh - 自动化部署脚本

set -e  # 遇到错误立即退出

# ==================== 配置区 ====================
APP_NAME="hotgo"
APP_DIR="/opt/hotgo/server"
BACKUP_DIR="/opt/hotgo/backups"
GIT_REPO="https://github.com/your/repo.git"
GIT_BRANCH="main"

# 颜色输出
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# ==================== 函数定义 ====================

log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# 检查服务状态
check_service() {
    if systemctl is-active --quiet $APP_NAME; then
        return 0
    else
        return 1
    fi
}

# 备份当前版本
backup_current() {
    local timestamp=$(date +%Y%m%d_%H%M%S)
    local backup_file="${BACKUP_DIR}/backup_${timestamp}.tar.gz"
    
    log_info "备份当前版本到: $backup_file"
    mkdir -p $BACKUP_DIR
    
    tar -czf $backup_file \
        -C $APP_DIR \
        --exclude='logs' \
        --exclude='tmp' \
        --exclude='*.log' \
        .
    
    # 只保留最近10个备份
    ls -t $BACKUP_DIR/backup_*.tar.gz | tail -n +11 | xargs -r rm
    
    log_info "备份完成"
}

# 拉取最新代码
update_code() {
    log_info "拉取最新代码..."
    cd $APP_DIR
    
    # 保存本地修改（如果有）
    git stash
    
    # 拉取最新代码
    git fetch origin $GIT_BRANCH
    git checkout $GIT_BRANCH
    git pull origin $GIT_BRANCH
    
    log_info "代码更新完成"
}

# 编译应用
build_app() {
    log_info "编译应用程序..."
    cd $APP_DIR
    
    # 备份旧的可执行文件
    if [ -f "main" ]; then
        mv main main.old
    fi
    
    # 编译新版本
    go build -o main main.go
    
    # 检查编译是否成功
    if [ ! -f "main" ]; then
        log_error "编译失败！恢复旧版本..."
        mv main.old main
        exit 1
    fi
    
    # 赋予执行权限
    chmod +x main
    
    log_info "编译完成"
}

# 数据库迁移
migrate_database() {
    log_info "检查数据库迁移..."
    cd $APP_DIR
    
    # 如果有数据库迁移脚本
    if [ -d "storage/migrations" ]; then
        log_warn "请手动执行数据库迁移（如有需要）"
        # 这里可以添加自动迁移逻辑
        # ./main migrate up
    fi
}

# 优雅重启服务
restart_service() {
    log_info "重启服务..."
    
    if check_service; then
        # 服务正在运行，执行优雅重启
        log_info "服务运行中，执行优雅重启..."
        sudo systemctl reload-or-restart $APP_NAME
        
        # 等待服务重启
        sleep 3
        
        # 检查服务状态
        if check_service; then
            log_info "✅ 服务重启成功"
        else
            log_error "❌ 服务重启失败！检查日志："
            sudo journalctl -u $APP_NAME -n 50 --no-pager
            exit 1
        fi
    else
        # 服务未运行，直接启动
        log_info "服务未运行，启动服务..."
        sudo systemctl start $APP_NAME
        
        sleep 3
        
        if check_service; then
            log_info "✅ 服务启动成功"
        else
            log_error "❌ 服务启动失败！"
            exit 1
        fi
    fi
}

# 健康检查
health_check() {
    log_info "执行健康检查..."
    
    local max_retries=10
    local retry_count=0
    
    while [ $retry_count -lt $max_retries ]; do
        # 检查HTTP服务是否响应
        if curl -f -s -o /dev/null http://localhost:8000/api/health; then
            log_info "✅ 健康检查通过"
            return 0
        fi
        
        retry_count=$((retry_count + 1))
        log_warn "健康检查失败，重试 $retry_count/$max_retries..."
        sleep 2
    done
    
    log_error "❌ 健康检查失败！服务可能未正常启动"
    return 1
}

# 回滚到上一个版本
rollback() {
    log_error "部署失败，执行回滚..."
    
    # 找到最新的备份
    local latest_backup=$(ls -t $BACKUP_DIR/backup_*.tar.gz | head -n 1)
    
    if [ -z "$latest_backup" ]; then
        log_error "未找到备份文件，无法回滚！"
        exit 1
    fi
    
    log_info "从备份恢复: $latest_backup"
    
    # 停止服务
    sudo systemctl stop $APP_NAME
    
    # 恢复备份
    tar -xzf $latest_backup -C $APP_DIR
    
    # 重启服务
    sudo systemctl start $APP_NAME
    
    sleep 3
    
    if check_service; then
        log_info "✅ 回滚成功"
    else
        log_error "❌ 回滚后服务启动失败！需要人工介入"
        exit 1
    fi
}

# ==================== 主流程 ====================

main() {
    log_info "========================================="
    log_info "开始部署 $APP_NAME"
    log_info "时间: $(date '+%Y-%m-%d %H:%M:%S')"
    log_info "========================================="
    
    # 1. 备份当前版本
    backup_current
    
    # 2. 拉取最新代码
    update_code
    
    # 3. 编译应用
    build_app
    
    # 4. 数据库迁移（可选）
    migrate_database
    
    # 5. 重启服务
    restart_service
    
    # 6. 健康检查
    if ! health_check; then
        rollback
        exit 1
    fi
    
    log_info "========================================="
    log_info "✅ 部署成功！"
    log_info "========================================="
    
    # 显示服务状态
    sudo systemctl status $APP_NAME --no-pager -l
}

# ==================== 脚本入口 ====================

# 检查是否有root权限
if [ "$EUID" -ne 0 ] && ! sudo -n true 2>/dev/null; then 
    log_error "此脚本需要sudo权限"
    exit 1
fi

# 执行主流程
main "$@"
```

**使用方法：**

```bash
# 赋予执行权限
chmod +x deploy.sh

# 执行部署
./deploy.sh

# 部署输出示例：
# [INFO] =========================================
# [INFO] 开始部署 hotgo
# [INFO] 时间: 2025-12-24 13:30:00
# [INFO] =========================================
# [INFO] 备份当前版本到: /opt/hotgo/backups/backup_20251224_133000.tar.gz
# [INFO] 备份完成
# [INFO] 拉取最新代码...
# [INFO] 代码更新完成
# [INFO] 编译应用程序...
# [INFO] 编译完成
# [INFO] 重启服务...
# [INFO] 服务运行中，执行优雅重启...
# [INFO] ✅ 服务重启成功
# [INFO] 执行健康检查...
# [INFO] ✅ 健康检查通过
# [INFO] =========================================
# [INFO] ✅ 部署成功！
# [INFO] =========================================
```

---

### 4.2 快速更新脚本（简化版）

```bash
#!/bin/bash
# quick-update.sh - 快速更新脚本

APP_DIR="/opt/hotgo/server"

cd $APP_DIR

# 拉取代码
git pull

# 编译
go build -o main.new main.go

# 替换可执行文件
mv main main.old
mv main.new main
chmod +x main

# 优雅重启
sudo systemctl reload-or-restart hotgo

# 检查状态
sleep 2
systemctl status hotgo

echo "更新完成！"
```

---

## 五、零停机方案（双服务器）

### 5.1 架构图

```
                 ┌──────────────┐
                 │ 负载均衡器    │
                 │ (Nginx/HAProxy)│
                 └───────┬────────┘
                         │
            ┌────────────┴────────────┐
            │                         │
     ┌──────▼──────┐          ┌──────▼──────┐
     │ 服务器A      │          │ 服务器B      │
     │ (运行中)     │          │ (待更新)     │
     └─────────────┘          └─────────────┘

更新流程:
1. 从负载均衡器摘除服务器B
2. 更新服务器B
3. 测试服务器B
4. 加入服务器B到负载均衡器
5. 重复步骤1-4更新服务器A
```

### 5.2 Nginx 配置

```nginx
# /etc/nginx/nginx.conf

upstream hotgo_backend {
    least_conn;  # 最少连接负载均衡
    
    server 192.168.1.10:8000 max_fails=3 fail_timeout=30s;
    server 192.168.1.11:8000 max_fails=3 fail_timeout=30s backup;
    
    keepalive 32;
}

server {
    listen 80;
    server_name api.yourdomain.com;
    
    location / {
        proxy_pass http://hotgo_backend;
        proxy_http_version 1.1;
        proxy_set_header Connection "";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        
        # 健康检查
        proxy_next_upstream error timeout http_500 http_502 http_503;
        proxy_connect_timeout 5s;
        proxy_send_timeout 10s;
        proxy_read_timeout 10s;
    }
    
    # 健康检查端点
    location /health {
        access_log off;
        proxy_pass http://hotgo_backend/api/health;
    }
}
```

---

## 六、数据库更新策略

### 6.1 兼容性更新（推荐）

**原则：新代码兼容旧数据库，旧代码兼容新数据库**

```
部署流程:
1. 只添加新字段（不删除旧字段）
2. 部署新代码
3. 等待稳定运行
4. 再删除废弃字段（如需要）
```

**示例：添加新字段**

```sql
-- 阶段1: 添加新字段（允许NULL）
ALTER TABLE hg_trading_robot 
ADD COLUMN new_feature VARCHAR(100) DEFAULT NULL;

-- 部署新代码...

-- 阶段2: 填充数据（如需要）
UPDATE hg_trading_robot 
SET new_feature = 'default_value' 
WHERE new_feature IS NULL;

-- 阶段3: 设置NOT NULL约束（可选）
ALTER TABLE hg_trading_robot 
ALTER COLUMN new_feature SET NOT NULL;
```

### 6.2 迁移脚本

```bash
#!/bin/bash
# migrate.sh - 数据库迁移脚本

PGHOST="localhost"
PGPORT="5432"
PGDATABASE="hotgo"
PGUSER="postgres"
MIGRATION_DIR="/opt/hotgo/server/storage/migrations"

# 执行迁移
for file in $(ls -v $MIGRATION_DIR/*.sql); do
    echo "执行迁移: $file"
    psql -h $PGHOST -p $PGPORT -U $PGUSER -d $PGDATABASE -f $file
done

echo "迁移完成！"
```

---

## 七、更新检查清单 ✅

### 部署前检查

```
□ 代码已经过测试
□ 数据库迁移脚本已准备
□ 备份已创建
□ 维护窗口已确认（如需要）
□ 回滚方案已准备
□ 团队成员已通知
```

### 部署中检查

```
□ 编译成功
□ 服务启动成功
□ 健康检查通过
□ 日志无明显错误
□ 机器人正常运行
□ WebSocket连接正常
```

### 部署后监控（前30分钟）

```
□ CPU使用率正常
□ 内存使用率正常
□ 数据库连接正常
□ Redis连接正常
□ API响应时间正常
□ 交易执行正常
□ 无异常日志
```

---

## 八、常见问题处理

### Q1: 更新过程中有正在处理的订单怎么办？

**A:** 优雅关闭会等待订单处理完成（最多30秒）

```go
// 在 gracefulShutdown() 中
func closeAllTradingEngines(ctx context.Context) {
    // 1. 设置"停止接收新信号"标志
    setStopNewSignals(true)
    
    // 2. 等待当前订单处理完成
    maxWait := 30 * time.Second
    deadline := time.Now().Add(maxWait)
    
    for time.Now().Before(deadline) {
        if countPendingOrders() == 0 {
            break
        }
        time.Sleep(1 * time.Second)
    }
    
    // 3. 保存状态
    saveAllEngineStates()
}
```

### Q2: 如果更新后发现严重bug怎么办？

**A:** 立即执行回滚

```bash
# 方法1: 使用备份回滚
cd /opt/hotgo/backups
latest_backup=$(ls -t backup_*.tar.gz | head -n 1)
sudo systemctl stop hotgo
tar -xzf $latest_backup -C /opt/hotgo/server
sudo systemctl start hotgo

# 方法2: 使用Git回滚
cd /opt/hotgo/server
git log --oneline -10  # 查看最近10次提交
git reset --hard <previous_commit_hash>
go build -o main main.go
sudo systemctl restart hotgo
```

### Q3: 凌晨更新还是白天更新？

**A:** 建议选择：

```
最佳时间: 
  - 凌晨 2:00-4:00 (亚洲交易量最低)
  - 避开美盘开盘 (21:30-23:00 北京时间)
  - 避开欧盘开盘 (15:00-17:00 北京时间)

如果使用零停机方案:
  - 任何时间都可以
```

### Q4: 需要通知用户吗？

**A:** 根据影响程度：

```
重大更新（可能影响交易）:
  ✅ 提前24小时通知
  ✅ 说明更新内容
  ✅ 说明预计停机时间

小更新（bug修复）:
  ⚠️ 更新后通知即可

热修复（紧急bug）:
  ✅ 更新后立即通知并说明修复内容
```

---

## 九、监控和告警

### 9.1 部署监控脚本

```bash
#!/bin/bash
# monitor.sh - 部署后监控

APP_NAME="hotgo"
ALERT_EMAIL="admin@yourdomain.com"

# 检查服务状态
check_service() {
    if ! systemctl is-active --quiet $APP_NAME; then
        echo "服务未运行！" | mail -s "紧急：$APP_NAME 服务故障" $ALERT_EMAIL
        exit 1
    fi
}

# 检查API响应
check_api() {
    response=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8000/api/health)
    if [ "$response" != "200" ]; then
        echo "API响应异常: $response" | mail -s "警告：$APP_NAME API异常" $ALERT_EMAIL
        exit 1
    fi
}

# 检查CPU使用率
check_cpu() {
    cpu_usage=$(top -bn1 | grep "Cpu(s)" | awk '{print $2}' | cut -d% -f1)
    if (( $(echo "$cpu_usage > 90" | bc -l) )); then
        echo "CPU使用率过高: $cpu_usage%" | mail -s "警告：$APP_NAME CPU使用率高" $ALERT_EMAIL
    fi
}

# 检查内存使用率
check_memory() {
    mem_usage=$(free | grep Mem | awk '{print ($3/$2) * 100.0}')
    if (( $(echo "$mem_usage > 85" | bc -l) )); then
        echo "内存使用率过高: $mem_usage%" | mail -s "警告：$APP_NAME 内存使用率高" $ALERT_EMAIL
    fi
}

# 执行所有检查
check_service
check_api
check_cpu
check_memory

echo "所有检查通过 - $(date)"
```

**添加到 Crontab（每5分钟检查一次）:**

```bash
crontab -e

# 添加
*/5 * * * * /opt/hotgo/scripts/monitor.sh >> /var/log/hotgo-monitor.log 2>&1
```

---

## 十、最佳实践总结

### ✅ 推荐做法

1. **使用版本控制** - 所有代码都提交到Git
2. **自动化部署** - 使用脚本减少人为错误
3. **优雅关闭** - 确保所有请求处理完成
4. **健康检查** - 部署后立即检查
5. **备份策略** - 每次部署前自动备份
6. **回滚方案** - 准备好快速回滚
7. **监控告警** - 部署后持续监控
8. **分阶段发布** - 先小流量测试
9. **文档记录** - 记录每次部署
10. **测试环境** - 先在测试环境验证

### ❌ 避免做法

1. ❌ 直接在生产环境修改代码
2. ❌ 不备份就更新
3. ❌ 没有健康检查就认为部署成功
4. ❌ 交易高峰期更新
5. ❌ 跳过测试环境直接上生产
6. ❌ 没有回滚方案
7. ❌ 不通知用户就更新
8. ❌ 部署后不监控
9. ❌ 一次更新多个功能
10. ❌ 强制kill进程（应该优雅关闭）

---

## 十一、快速参考

### 常用命令

```bash
# 查看服务状态
sudo systemctl status hotgo

# 重启服务（优雅）
sudo systemctl reload-or-restart hotgo

# 查看实时日志
sudo journalctl -u hotgo -f

# 查看最近50行日志
sudo journalctl -u hotgo -n 50 --no-pager

# 强制重启（不推荐）
sudo systemctl restart hotgo

# 停止服务
sudo systemctl stop hotgo

# 启动服务
sudo systemctl start hotgo

# 检查配置文件语法
go run main.go -check

# 查看进程
ps aux | grep hotgo

# 查看端口占用
ss -tlnp | grep 8000
```

---

**最后更新**: 2025-12-24
**版本**: v1.0
**适用系统**: Ubuntu 20.04/22.04 LTS

