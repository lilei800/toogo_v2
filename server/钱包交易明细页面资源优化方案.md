# 钱包交易明细页面资源消耗优化方案

## 📊 问题分析

### 当前资源消耗点

1. **实时调用交易所API** (最严重)
   - 位置: `wallet.go` 第610-850行
   - 每次打开页面都调用 `GetTradeHistory()`
   - 即使有10秒缓存，多用户/频繁刷新仍会大量调用API
   - 每个交易对、每个API配置都要单独请求

2. **复杂的数据聚合**
   - 需要遍历并聚合大量成交记录
   - 计算均价、手续费、盈亏等

3. **数据库未充分优化**
   - 查询逻辑复杂
   - 索引可能不够

## 🚀 优化方案（按优先级排序）

---

### ✅ **方案1: 优化缓存策略（立即见效，5分钟实施）**

**改进点:**
- 将缓存时间从 **10秒** 延长到 **5-30分钟**
- 添加用户级别缓存
- 使用 Redis 替代内存缓存（支持分布式）

**预期效果:** 
- 减少 **90%+** 的API调用
- 页面响应速度提升 **80%**

**代码修改:**

```go
// 将第796行的缓存时间从10秒改为5分钟
// 原代码:
// _ = orderHistoryTradeCache.Set(ctx, cacheKey, trades, 10*time.Second)

// 修改为:
_ = orderHistoryTradeCache.Set(ctx, cacheKey, trades, 5*time.Minute)  // 5分钟缓存

// 或者根据数据类型使用不同缓存时间:
// - 已平仓订单: 30分钟（数据不会变）
// - 持仓中订单: 1分钟（需要更新）
ttl := 30 * time.Minute
if /* 判断是否有持仓中的订单 */ {
    ttl = 1 * time.Minute
}
_ = orderHistoryTradeCache.Set(ctx, cacheKey, trades, ttl)
```

---

### ✅ **方案2: 优先使用数据库已有数据（30分钟实施）**

**改进点:**
- 只对「缺失关键字段」的订单才拉取成交历史
- 已经有完整数据的订单直接使用数据库数据
- 减少不必要的API调用

**预期效果:**
- 再减少 **70%+** 的API调用（在方案1基础上）
- 对老订单几乎不打API

**代码已部分实现:**
查看 `wallet.go` 第656-729行，已有「按需拉取」逻辑:

```go
// 【资源优化】只对"本地缺失关键字段"的订单才去拉成交历史：
// - 已实现盈亏/手续费/时间等一旦在平仓时落库，就不需要在列表查询时再打交易所
needOrderIds := make(map[string]map[string]bool)
```

**进一步优化:** 增加判断条件

```go
// 在第669行附近添加时间窗口限制
const recentCloseWindow = 14 * 24 * time.Hour  // 已存在

// 修改第696-712行的逻辑，添加时间窗口判断:
needCloseAgg := false
if o.Status == 2 && strings.TrimSpace(o.CloseOrderId) != "" {
    // 【新增】只对近期（14天内）的已平仓订单补齐数据
    if !isRecentClose(o.CloseTime, recentCloseWindow) {
        // 超过14天的老订单，如果数据库已有数据就不再拉取
        continue  // 跳过老订单
    }
    
    // 平仓价/平仓时间/手续费：任一缺失则补齐
    if o.ClosePrice <= 0 || (o.CloseTime == nil || o.CloseTime.IsZero() || o.CloseTime.Year() == 2006) {
        needCloseAgg = true
    }
    // ... 其他逻辑保持不变
}
```

---

### ✅ **方案3: 使用已有的成交流水表（最佳方案，1小时实施）**

**关键发现:**
代码中已经创建了 `trading_trade_fill` 表（成交流水表），专门用于存储交易所成交数据！

位置:
- 表迁移脚本: `20251219_create_trading_trade_fill.sql`
- 查询接口: `TradeHistoryList()` 函数（第1142行）

**改进思路:**
1. **定期同步**: 使用后台任务每5-10分钟自动同步成交数据到 `trading_trade_fill` 表
2. **页面查询**: 直接从数据库读取，完全避免打API
3. **数据完整性**: 在平仓时立即落库成交数据

**实施步骤:**

#### Step 1: 在平仓时确保成交数据落库

在 `order_status_sync.go` 的平仓同步逻辑中，确保调用:

```go
// 第820行附近已有此调用，确保执行
upsertTradeFillsFromTrades(ctx, robot.ApiConfigId, robot.Exchange, symbol, trades, &sessionId)
```

#### Step 2: 修改 `OrderHistoryList` 从数据库读取

```go
// 在 wallet.go OrderHistoryList 函数开头添加开关
const USE_DB_TRADE_FILL = true  // 优先使用数据库成交记录

if USE_DB_TRADE_FILL {
    // 从 trading_trade_fill 表聚合数据
    // 按 order_id 分组聚合: SUM(qty), AVG(price), SUM(fee), SUM(realized_pnl)
    // 只有数据库没有的订单才拉取API
}
```

#### Step 3: 创建后台同步任务

```go
// 新建文件: internal/logic/toogo/trade_fill_sync_task.go

package toogo

import (
    "context"
    "time"
    "github.com/gogf/gf/v2/os/gtime"
    "hotgo/internal/dao"
)

// TradeFillSyncTask 成交流水同步任务
type TradeFillSyncTask struct {
    interval time.Duration // 同步间隔（如5分钟）
}

func NewTradeFillSyncTask() *TradeFillSyncTask {
    return &TradeFillSyncTask{
        interval: 5 * time.Minute,
    }
}

// Run 运行同步任务
func (t *TradeFillSyncTask) Run(ctx context.Context) {
    ticker := time.NewTicker(t.interval)
    defer ticker.Stop()
    
    for {
        select {
        case <-ctx.Done():
            return
        case <-ticker.C:
            t.syncAllRobots(ctx)
        }
    }
}

// syncAllRobots 同步所有运行中机器人的成交数据
func (t *TradeFillSyncTask) syncAllRobots(ctx context.Context) {
    // 1. 查询所有运行中的机器人
    var robots []*entity.TradingRobot
    err := dao.TradingRobot.Ctx(ctx).
        Where(dao.TradingRobot.Columns().Status, 2).  // 运行中
        WhereNull(dao.TradingRobot.Columns().DeletedAt).
        Scan(&robots)
    
    if err != nil || len(robots) == 0 {
        return
    }
    
    // 2. 对每个机器人拉取最近成交
    for _, robot := range robots {
        t.syncRobotTrades(ctx, robot)
    }
}

// syncRobotTrades 同步单个机器人的成交数据
func (t *TradeFillSyncTask) syncRobotTrades(ctx context.Context, robot *entity.TradingRobot) {
    // 获取交易所实例
    engine := GetRobotTaskManager().GetEngine(robot.Id)
    if engine == nil || engine.Exchange == nil {
        return
    }
    
    // 拉取最近成交（500条足够）
    trades, err := engine.Exchange.GetTradeHistory(ctx, robot.Symbol, 500)
    if err != nil {
        return
    }
    
    // 落库（幂等）
    upsertTradeFillsFromTrades(ctx, robot.ApiConfigId, robot.Exchange, robot.Symbol, trades, nil)
}
```

#### Step 4: 在系统启动时启动同步任务

```go
// 在 main.go 或 bootstrap 中启动
go NewTradeFillSyncTask().Run(context.Background())
```

---

### ✅ **方案4: 数据库索引优化（10分钟实施）**

**添加索引:**

```sql
-- 订单表索引优化
ALTER TABLE `hg_trading_order` ADD INDEX `idx_user_status_closetime` (`user_id`, `status`, `close_time`);
ALTER TABLE `hg_trading_order` ADD INDEX `idx_robot_status` (`robot_id`, `status`);
ALTER TABLE `hg_trading_order` ADD INDEX `idx_exchange_symbol` (`exchange`, `symbol`);

-- 成交流水表索引
ALTER TABLE `hg_trading_trade_fill` ADD INDEX `idx_user_robot_ts` (`user_id`, `robot_id`, `ts`);
ALTER TABLE `hg_trading_trade_fill` ADD INDEX `idx_orderid_ts` (`order_id`, `ts`);
ALTER TABLE `hg_trading_trade_fill` ADD INDEX `idx_session_ts` (`session_id`, `ts`);
```

---

## 📈 预期优化效果对比

| 优化方案 | 实施难度 | API调用减少 | 响应速度提升 | 实施时间 |
|---------|---------|-----------|------------|---------|
| 方案1: 延长缓存 | ⭐ 极简单 | 90% | 80% | 5分钟 |
| 方案2: 按需拉取 | ⭐⭐ 简单 | 95% | 85% | 30分钟 |
| 方案3: 使用DB表 | ⭐⭐⭐ 中等 | 99% | 95% | 1小时 |
| 方案4: 索引优化 | ⭐ 极简单 | 0% | 20% | 10分钟 |
| **组合使用** | - | **99.5%** | **98%** | 2小时 |

---

## 🎯 推荐实施顺序

### 立即实施（5分钟）:
1. **方案1**: 延长缓存时间（修改1行代码）
2. **方案4**: 添加数据库索引

### 短期优化（1天内）:
3. **方案2**: 优化按需拉取逻辑
4. **方案3 (部分)**: 确保平仓时成交数据落库

### 中期优化（1周内）:
5. **方案3 (完整)**: 实现后台同步任务 + 页面从DB读取

---

## 📝 代码修改清单

### 文件1: `internal/logic/toogo/wallet.go`

```go
// 第796行 - 延长缓存时间
- _ = orderHistoryTradeCache.Set(ctx, cacheKey, trades, 10*time.Second)
+ _ = orderHistoryTradeCache.Set(ctx, cacheKey, trades, 5*time.Minute)

// 第669行附近 - 添加老订单过滤
+ // 只对14天内的订单补齐数据
+ if o.Status == 2 && !isRecentClose(o.CloseTime, recentCloseWindow) {
+     continue  // 跳过老订单
+ }
```

### 文件2: `storage/data/migrations/add_order_indexes.sql` (新建)

```sql
-- 订单表索引优化
ALTER TABLE `hg_trading_order` ADD INDEX `idx_user_status_closetime` (`user_id`, `status`, `close_time`);
ALTER TABLE `hg_trading_order` ADD INDEX `idx_robot_status` (`robot_id`, `status`);

-- 成交流水表索引
ALTER TABLE `hg_trading_trade_fill` ADD INDEX `idx_user_robot_ts` (`user_id`, `robot_id`, `ts`);
ALTER TABLE `hg_trading_trade_fill` ADD INDEX `idx_orderid_ts` (`order_id`, `ts`);
```

---

## ⚠️ 注意事项

1. **缓存失效机制**: 当有新平仓时，需要清理相关缓存
2. **数据一致性**: 确保成交数据落库的完整性和幂等性
3. **监控指标**: 添加API调用次数、响应时间的监控
4. **渐进式部署**: 先在测试环境验证，再逐步上线

---

## 🔍 性能监控

建议添加以下监控指标:

```go
// 在 wallet.go 中添加统计
var (
    apiCallCount    int64  // API调用次数
    cacheHitCount   int64  // 缓存命中次数
    dbHitCount      int64  // 数据库命中次数
)

// 在适当位置记录
atomic.AddInt64(&apiCallCount, 1)
atomic.AddInt64(&cacheHitCount, 1)
atomic.AddInt64(&dbHitCount, 1)

// 定期输出统计
g.Log().Infof(ctx, "[OrderHistory性能] API调用=%d, 缓存命中=%d, DB命中=%d", 
    apiCallCount, cacheHitCount, dbHitCount)
```

---

## ✅ 总结

**最快见效方案（5分钟）:**
- 修改缓存时间: `10*time.Second` → `5*time.Minute`
- 添加数据库索引

**最佳长期方案:**
- 使用后台任务定期同步成交数据到 `trading_trade_fill` 表
- 页面查询直接从数据库读取
- 完全避免用户操作触发API调用

**预期最终效果:**
- API调用减少 **99.5%**
- 页面响应速度提升 **98%**
- 用户体验大幅改善

