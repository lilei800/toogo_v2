# 创建时保存策略参数必要性分析

## 一、当前实现

### 1.1 创建时保存的内容

```json
{
  "strategyKey": "...",
  "strategyName": "...",
  "description": "...",
  "monitorWindow": 60,              // ← 策略参数快照
  "volatilityThreshold": 50,       // ← 策略参数快照
  "leverageMin": 10,               // ← 策略参数快照
  "leverageMax": 10,               // ← 策略参数快照
  "marginPercentMin": 10,          // ← 策略参数快照
  "marginPercentMax": 10,          // ← 策略参数快照
  "stopLossPercent": 10,          // ← 策略参数快照
  "profitRetreatPercent": 10,     // ← 策略参数快照
  "autoStartRetreatPercent": 5,   // ← 策略参数快照
  "groupId": 18,                   // ← 策略组ID（必需）
  "riskConfig": {
    "marketRiskMapping": {         // ← 映射关系（必需）
      "trend": "balanced",
      ...
    }
  }
}
```

### 1.2 运行时使用情况

**运行时加载策略参数：**
```go
// 运行时总是从策略模板动态加载
func (e *RobotEngine) loadFullStrategyParams(ctx context.Context, marketState, riskPreference string) (*StrategyParams, error) {
    // 1. 获取策略组ID（从 Robot.StrategyGroupId 或 CurrentStrategy.groupId）
    groupId := e.Robot.StrategyGroupId
    if groupId == 0 {
        // 从 CurrentStrategy JSON 中获取 groupId
        groupId = getGroupIdFromCurrentStrategy(e.Robot.CurrentStrategy)
    }
    
    // 2. 从策略模板查询参数
    var strategy *entity.TradingStrategyTemplate
    err := dao.TradingStrategyTemplate.Ctx(ctx).
        Where("group_id", groupId).
        Where("market_state", marketState).
        Where("risk_preference", riskPreference).
        Scan(&strategy)
    
    // 3. 返回策略模板的参数（不是 CurrentStrategy 中的快照）
    return &StrategyParams{
        Window: strategy.MonitorWindow,           // ← 从数据库查询，不是从 CurrentStrategy
        Threshold: strategy.VolatilityThreshold, // ← 从数据库查询，不是从 CurrentStrategy
        // ...
    }
}
```

**关键发现：**
- ✅ 运行时**不使用** `CurrentStrategy` 中的策略参数快照
- ✅ 运行时**总是**从策略模板动态加载参数
- ✅ `CurrentStrategy` 中的策略参数快照**不被运行时使用**

---

## 二、策略参数快照是否有意义？

### 2.1 ❌ 运行时不需要

**原因：**
1. ✅ 运行时总是从策略模板动态加载参数
2. ✅ 如果策略模板被修改，快照就过时了
3. ✅ 如果策略模板被删除，快照也无法使用（代码要求必须找到策略模板）

**结论：** 运行时不需要策略参数快照

---

### 2.2 ⚠️ 历史记录用途有限

**潜在用途：**
1. **前端显示创建时的配置**
   - ⚠️ 但前端可以实时查询策略模板，不需要快照
   - ⚠️ 如果策略模板被修改，快照显示的是过时数据

2. **问题排查**
   - ⚠️ 如果策略模板被修改，无法知道创建时使用的参数
   - ⚠️ 如果策略模板被删除，快照也无法使用

3. **对比分析**
   - ⚠️ 可以对比创建时和当前的参数差异
   - ⚠️ 但如果策略模板被修改，对比没有意义

**结论：** 历史记录用途有限，且不可靠

---

### 2.3 ✅ 必需的部分

**真正必需的部分：**
1. **策略组ID（groupId）**
   - ✅ 必需：用于查询策略模板
   - ✅ 运行时使用：`Robot.StrategyGroupId` 或 `CurrentStrategy.groupId`

2. **映射关系（marketRiskMapping）**
   - ✅ 必需：用户配置的映射关系
   - ✅ 运行时使用：引擎启动时从 `CurrentStrategy` 加载

**结论：** 只有 `groupId` 和 `marketRiskMapping` 是必需的

---

## 三、精简方案

### 3.1 精简后的 CurrentStrategy JSON

**只保存必需的数据：**
```json
{
  "groupId": 18,                   // ← 策略组ID（必需）
  "riskConfig": {
    "marketRiskMapping": {         // ← 映射关系（必需）
      "trend": "balanced",
      "volatile": "balanced",
      "high_vol": "aggressive",
      "low_vol": "conservative"
    }
  }
}
```

**移除的部分：**
- ❌ `strategyKey`、`strategyName`、`description`（不需要）
- ❌ `monitorWindow`、`volatilityThreshold`（运行时从策略模板加载）
- ❌ `leverageMin`、`leverageMax`（运行时从策略模板加载）
- ❌ `marginPercentMin`、`marginPercentMax`（运行时从策略模板加载）
- ❌ `stopLossPercent`、`profitRetreatPercent`、`autoStartRetreatPercent`（运行时从策略模板加载）

---

### 3.2 代码修改

**修改前：**
```go
// 构建完整的策略配置JSON（包含策略参数和映射关系）
strategyConfig := map[string]interface{}{
    // 策略参数（从推荐策略获取）
    "strategyKey":             strategy.StrategyKey,
    "strategyName":            strategy.StrategyName,
    "description":             strategy.Description,
    "monitorWindow":           strategy.MonitorWindow,
    "volatilityThreshold":     strategy.VolatilityThreshold,
    "leverageMin":             strategy.LeverageMin,
    "leverageMax":             strategy.LeverageMax,
    "marginPercentMin":        strategy.MarginPercentMin,
    "marginPercentMax":        strategy.MarginPercentMax,
    "stopLossPercent":         strategy.StopLossPercent,
    "profitRetreatPercent":    strategy.ProfitRetreatPercent,
    "autoStartRetreatPercent": strategy.AutoStartRetreatPercent,
    "groupId":                 in.StrategyGroupId,
    "riskConfig": map[string]interface{}{
        "marketRiskMapping": in.MarketRiskMapping,
    },
}
```

**修改后：**
```go
// 构建精简的策略配置JSON（只保存必需的数据）
strategyConfig := map[string]interface{}{
    // 策略组ID（必需：用于查询策略模板）
    "groupId": in.StrategyGroupId,
}

// 如果前端没有传递策略组ID，尝试从推荐策略获取
if in.StrategyGroupId == 0 {
    // 注意：这里可能需要查询策略模板获取 groupId
    // 但更好的方式是要求前端必须传递 strategyGroupId
}

// 风险配置（包含映射关系）
if in.MarketRiskMapping != nil && len(in.MarketRiskMapping) > 0 {
    strategyConfig["riskConfig"] = map[string]interface{}{
        "marketRiskMapping": in.MarketRiskMapping,
    }
}
```

---

## 四、优势分析

### 4.1 ✅ 优势

1. **减少存储空间**
   - ✅ JSON 更小，占用更少的数据库空间
   - ✅ 减少序列化/反序列化的开销

2. **避免数据不一致**
   - ✅ 不会有过时的策略参数快照
   - ✅ 数据来源唯一：策略模板

3. **职责清晰**
   - ✅ `CurrentStrategy` 只保存用户配置（映射关系、策略组ID）
   - ✅ 策略参数从策略模板动态加载

4. **简化代码**
   - ✅ 不需要查询推荐策略获取参数
   - ✅ 不需要保存策略参数快照
   - ✅ 代码更简洁

5. **数据一致性**
   - ✅ 运行时总是使用最新的策略模板参数
   - ✅ 不会因为快照过时而使用错误的参数

---

### 4.2 ⚠️ 潜在问题

1. **前端显示创建时的配置**
   - ⚠️ 如果前端需要显示创建时的配置，需要实时查询策略模板
   - ✅ 但这样更准确，因为显示的是当前策略模板的参数

2. **历史记录**
   - ⚠️ 如果策略模板被修改，无法知道创建时使用的参数
   - ✅ 解决方案：如果需要历史记录，可以保存到历史记录表

---

## 五、推荐方案

### 5.1 精简 CurrentStrategy JSON

**只保存必需的数据：**
```json
{
  "groupId": 18,
  "riskConfig": {
    "marketRiskMapping": {
      "trend": "balanced",
      "volatile": "balanced",
      "high_vol": "aggressive",
      "low_vol": "conservative"
    }
  }
}
```

**移除策略参数快照：**
- ❌ 不需要保存策略参数
- ✅ 运行时从策略模板动态加载

---

### 5.2 代码修改

**修改创建机器人的代码：**
```go
// Create 创建机器人
func (s *robotImpl) Create(ctx context.Context, in *input.TradingRobotCreateInp) (id int64, err error) {
    // ... 验证API配置 ...
    
    // ✅ 不再需要查询推荐策略获取参数
    // strategy, err := s.GetRecommendStrategy(ctx, in.RiskPreference, in.MarketState)
    
    // ✅ 构建精简的策略配置JSON（只保存必需的数据）
    strategyConfig := map[string]interface{}{
        // 策略组ID（必需：用于查询策略模板）
        "groupId": in.StrategyGroupId,
    }
    
    // 如果前端没有传递策略组ID，返回错误（要求必须传递）
    if in.StrategyGroupId == 0 {
        return 0, gerror.New("策略组ID不能为空")
    }
    
    // 风险配置（包含映射关系）
    if in.MarketRiskMapping != nil && len(in.MarketRiskMapping) > 0 {
        strategyConfig["riskConfig"] = map[string]interface{}{
            "marketRiskMapping": in.MarketRiskMapping,
        }
    }
    
    // 将策略配置转换为JSON
    strategyJSON, err := json.Marshal(strategyConfig)
    if err != nil {
        return 0, gerror.Wrap(err, "策略JSON转换失败")
    }
    
    // ... 保存到数据库 ...
}
```

---

### 5.3 前端显示

**如果需要显示创建时的配置：**
```javascript
// 前端可以实时查询策略模板
const getStrategyParams = async (groupId, marketState, riskPreference) => {
  const res = await http.request({
    url: '/strategy/template/get',
    method: 'get',
    params: {
      groupId,
      marketState,
      riskPreference,
    },
  });
  return res;
};
```

**优点：**
- ✅ 显示的是当前策略模板的参数（更准确）
- ✅ 如果策略模板被修改，显示的是最新参数

---

## 六、总结

### 6.1 用户观点正确 ✅

**创建时保存策略参数快照确实没有意义：**
1. ✅ 运行时不使用：运行时总是从策略模板动态加载
2. ✅ 数据可能过时：如果策略模板被修改，快照就过时了
3. ✅ 数据不可靠：如果策略模板被删除，快照也无法使用
4. ✅ 增加复杂度：需要查询推荐策略，保存快照，但运行时不使用

---

### 6.2 推荐方案

**精简 CurrentStrategy JSON：**
- ✅ 只保存 `groupId`（必需：用于查询策略模板）
- ✅ 只保存 `marketRiskMapping`（必需：用户配置的映射关系）
- ❌ 不保存策略参数快照（运行时从策略模板动态加载）

**优势：**
- ✅ 减少存储空间
- ✅ 避免数据不一致
- ✅ 职责清晰
- ✅ 简化代码
- ✅ 数据一致性

---

### 6.3 实施建议

1. **修改创建机器人的代码**
   - ✅ 移除查询推荐策略的逻辑
   - ✅ 只保存 `groupId` 和 `marketRiskMapping`

2. **前端显示**
   - ✅ 如果需要显示创建时的配置，实时查询策略模板
   - ✅ 这样更准确，因为显示的是当前策略模板的参数

3. **历史记录（可选）**
   - ✅ 如果需要历史记录，可以保存到历史记录表
   - ✅ 不影响运行时逻辑

**结论：用户说得对，创建时保存策略参数快照确实没有意义，应该精简！**

