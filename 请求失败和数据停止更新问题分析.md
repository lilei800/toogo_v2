# 请求失败和数据停止更新问题分析

## 一、问题现象

1. **请求失败提示**：运行一段时间后，前端显示"请求失败"错误提示
2. **数据停止更新**：机器人页面的所有数据停止更新，包括：
   - 实时价格不再变化
   - 血条进度不再更新
   - 持仓盈亏不再刷新

---

## 二、系统架构概览

### 2.1 整体架构

```
┌─────────────────────────────────────────────────────────────────┐
│                        前端 (Vue 3)                              │
│  ┌─────────────────────────────────────────────────────────────┐│
│  │ 定时器机制：                                                 ││
│  │ - fastRefreshTimer: 每1秒 → loadRealtimeData()             ││
│  │ - orderRefreshTimer: 每10秒 → refreshOrderData()           ││
│  │ - refreshTimer: 每30秒 → loadPositionData()                ││
│  └─────────────────────────────────────────────────────────────┘│
│                              │                                   │
│                              │ HTTP 请求                         │
│                              ▼                                   │
├─────────────────────────────────────────────────────────────────┤
│                        后端 (GoFrame)                            │
│  ┌─────────────────────────────────────────────────────────────┐│
│  │ API 层：                                                     ││
│  │ - /trading/monitor/batchRobotAnalysis → 批量获取分析数据    ││
│  │ - /toogo/robot/positions → 获取持仓数据                     ││
│  └─────────────────────────────────────────────────────────────┘│
│                              │                                   │
│                              │ 调用                              │
│                              ▼                                   │
│  ┌─────────────────────────────────────────────────────────────┐│
│  │ 全局服务层：                                                 ││
│  │ - RobotTaskManager: 管理机器人引擎（每5秒同步）              ││
│  │ - MarketServiceManager: 管理行情数据（WebSocket/HTTP轮询）   ││
│  │ - OrderStatusSyncService: 同步订单状态（每秒）               ││
│  └─────────────────────────────────────────────────────────────┘│
│                              │                                   │
│                              │ 请求                              │
│                              ▼                                   │
│  ┌─────────────────────────────────────────────────────────────┐│
│  │ 交易所 API 层：                                              ││
│  │ - Bitget API (HTTP 超时30秒)                                 ││
│  │ - Binance API                                                ││
│  │ - WebSocket 连接（如果启用）                                 ││
│  └─────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────┘
```

### 2.2 数据流分析

```
前端每1秒请求 batchRobotAnalysis
       │
       ▼
后端 GetBatchRobotAnalysis
       │
       ├─> 循环处理每个机器人
       │         │
       │         ▼
       │   GetRobotAnalysis
       │         │
       │         ├─> 从数据库获取机器人信息
       │         ├─> 从 MarketServiceManager 获取 Ticker 缓存
       │         │         │
       │         │         ├─> 优先 WebSocket 数据
       │         │         └─> 降级 HTTP 缓存（10秒有效期）
       │         │
       │         ├─> 从 RobotEngine 获取分析数据
       │         └─> 构建配置信息
       │
       └─> 返回聚合结果
```

---

## 三、问题根因分析

### 3.1 可能的失败点

#### 3.1.1 前端 Axios 拦截器的错误处理

**代码位置**：`web/src/utils/http/axios/index.ts`

```typescript
// 第210行
const msg: string = response?.data?.message || message || '请求失败';
```

**问题**：当后端返回空响应或网络错误时，默认显示"请求失败"。

**触发条件**：
1. 网络超时（前端 axios 默认 10 秒超时）
2. 后端返回非标准格式
3. 代理连接中断

#### 3.1.2 MarketServiceManager Ticker 缓存过期

**代码位置**：`server/internal/library/market/market_service_manager.go`

```go
// 第401-405行
func (s *ExchangeMarketService) GetTicker(symbol string) *exchange.Ticker {
    if cache, ok := s.Tickers[symbol]; ok {
        if time.Since(cache.UpdatedAt) < 10*time.Second {
            return cache.Data
        }
    }
    return nil  // 超过10秒返回 nil
}
```

**问题**：Ticker 缓存 10 秒过期，如果 `runTickerUpdater` 更新失败超过 10 秒，缓存失效。

**后果**：
- `GetRobotAnalysis` 返回 `Connected=false`，`ConnectionError="市场数据未就绪，请稍后"`
- 前端收到"连接失败"状态

#### 3.1.3 runTickerUpdater 更新失败

**代码位置**：`server/internal/library/market/market_service_manager.go`

```go
// 第569-581行
func (s *ExchangeMarketService) updateAllTickers(ctx context.Context) {
    // ...获取订阅的 symbols...
    
    for _, symbol := range symbols {
        ticker, err := s.Exchange.GetTicker(ctx, symbol)
        if err != nil {
            continue  // 错误时静默跳过，不更新缓存
        }
        // 更新缓存...
    }
}
```

**问题**：
1. 没有记录连续失败次数
2. 没有错误日志
3. 失败时不更新缓存，导致缓存过期

#### 3.1.4 交易所 API 超时或限流

**代码位置**：`server/internal/library/exchange/bitget.go`

```go
// 第36行
client.SetTimeout(30 * time.Second) // HTTP 超时30秒
```

**问题**：
1. 交易所 API 可能限流（429 Too Many Requests）
2. 网络波动导致超时
3. 代理服务器故障

### 3.2 连锁反应分析

```
交易所 API 超时/限流
       │
       ▼
runTickerUpdater 获取 Ticker 失败
       │
       ▼
Ticker 缓存不更新
       │
       ▼
10秒后缓存过期，GetTicker 返回 nil
       │
       ▼
GetRobotAnalysis 返回 Connected=false
       │
       ▼
前端显示"连接失败"，数据停止更新
```

---

## 四、关键代码分析

### 4.1 RobotEngine 错误处理

```go
// robot_engine.go 第940-970行
func (e *RobotEngine) syncAccountData(ctx context.Context) {
    balance, err := e.Exchange.GetBalance(ctx)
    if err == nil {
        e.SyncErrorCount = 0  // 成功重置
    } else {
        e.SyncErrorCount++    // 失败累加
        g.Log().Debugf(ctx, "获取余额失败: %v (连续错误%d次)", err, e.SyncErrorCount)
    }
    
    positions, err := e.Exchange.GetPositions(ctx, e.Robot.Symbol)
    if err == nil {
        e.SyncErrorCount = 0
    } else {
        e.SyncErrorCount++
    }
}
```

**优点**：有错误计数机制
**缺点**：没有基于错误计数的自动恢复或报警

### 4.2 syncAccountDataIfNeeded 错误退避

```go
// robot_engine.go 第1049-1057行
if syncErrorCount > 0 {
    // 连续错误时，延长同步间隔，避免API限流
    minInterval := time.Duration(syncErrorCount) * 5 * time.Second
    if minInterval > 30*time.Second {
        minInterval = 30 * time.Second  // 最大30秒
    }
    if timeSinceLastPositionUpdate < minInterval {
        return false  // 跳过同步
    }
}
```

**问题**：当连续错误时，同步间隔增加到最大 30 秒，可能导致数据严重延迟。

### 4.3 前端静默错误处理

```typescript
// robot/index.vue 第2470-2475行
} catch (error: any) {
    // 静默失败，避免控制台刷屏
    if (Math.random() < 0.1) {  // 只打印10%的错误
        console.warn('实时数据刷新失败:', error.message);
    }
}
```

**问题**：错误被静默处理，用户无法感知问题。

---

## 五、解决方案

### 5.1 短期修复（快速止血）

#### 5.1.1 增加 Ticker 缓存有效期

```go
// market_service_manager.go 修改第404行
if time.Since(cache.UpdatedAt) < 30*time.Second {  // 从10秒改为30秒
    return cache.Data
}
```

#### 5.1.2 增加 updateAllTickers 错误日志和重试

```go
func (s *ExchangeMarketService) updateAllTickers(ctx context.Context) {
    // ...
    for _, symbol := range symbols {
        var ticker *exchange.Ticker
        var err error
        
        // 重试3次
        for i := 0; i < 3; i++ {
            ticker, err = s.Exchange.GetTicker(ctx, symbol)
            if err == nil {
                break
            }
            g.Log().Warningf(ctx, "[MarketService] 获取Ticker失败(尝试%d/3): %s, %v", i+1, symbol, err)
            time.Sleep(time.Duration(i+1) * 500 * time.Millisecond)
        }
        
        if err != nil {
            g.Log().Errorf(ctx, "[MarketService] 获取Ticker最终失败: %s, %v", symbol, err)
            continue
        }
        // 更新缓存...
    }
}
```

#### 5.1.3 前端增加连接状态提示

```typescript
// 在 loadRealtimeData 中增加连接状态统计
let disconnectedCount = 0;
for (const item of batchRes.list) {
    if (!item.connected) {
        disconnectedCount++;
    }
}
if (disconnectedCount > 0) {
    console.warn(`${disconnectedCount}个机器人连接异常`);
}
```

### 5.2 长期优化（根本解决）

#### 5.2.1 启用 WebSocket 数据推送

当前系统已实现 WebSocket，但默认未启用。启用后可避免 HTTP 轮询的问题。

**配置方式**：在 `config.yaml` 中设置：
```yaml
toogo:
  websocketEnabled: true
```

#### 5.2.2 实现数据源降级机制

```
优先级1: WebSocket 实时推送
    ↓ 断开
优先级2: HTTP 轮询缓存（1秒更新）
    ↓ 超时
优先级3: 本地缓存（30秒有效）
    ↓ 过期
显示"数据延迟"警告，而非完全停止
```

#### 5.2.3 增加健康检查和自动恢复

```go
// 在 MarketServiceManager 中增加健康检查
func (m *MarketServiceManager) healthCheck(ctx context.Context) {
    for platform, svc := range m.services {
        // 检查订阅是否有数据更新
        staleCount := 0
        for symbol := range svc.Subscriptions {
            if !svc.IsDataFresh(symbol, 30*time.Second) {
                staleCount++
            }
        }
        
        if staleCount > 0 {
            g.Log().Warningf(ctx, "[HealthCheck] %s 有 %d 个交易对数据陈旧，尝试重连",
                platform, staleCount)
            // 触发重新订阅
            m.reconnectService(ctx, platform)
        }
    }
}
```

---

## 六、监控建议

### 6.1 后端监控指标

1. **Ticker 更新成功率**：`ticker_update_success_rate`
2. **API 调用延迟**：`exchange_api_latency_ms`
3. **连续失败次数**：`sync_error_count`
4. **WebSocket 连接状态**：`websocket_connected`

### 6.2 前端监控指标

1. **请求失败率**：`request_failure_rate`
2. **数据更新延迟**：`data_update_delay_ms`
3. **连接状态分布**：`connection_status_distribution`

### 6.3 告警规则

| 指标 | 阈值 | 告警级别 |
|------|------|---------|
| Ticker 更新成功率 < 80% | 持续1分钟 | Warning |
| 连续失败次数 > 5 | 立即 | Error |
| WebSocket 断开 | 持续30秒 | Warning |
| 全部机器人连接失败 | 立即 | Critical |

---

## 七、总结

### 问题根因

**主要原因**：`MarketServiceManager.runTickerUpdater` 在 API 调用失败时静默跳过，不更新缓存。当失败持续超过 10 秒时，缓存过期，导致 `GetRobotAnalysis` 返回连接失败，前端数据停止更新。

**次要原因**：
1. 前端错误被静默处理，用户无法感知
2. 缺少自动恢复机制
3. WebSocket 未启用，完全依赖 HTTP 轮询

### 推荐修复优先级

1. **P0（立即）**：增加 Ticker 缓存有效期到 30 秒
2. **P1（24小时内）**：增加 updateAllTickers 重试和错误日志
3. **P2（本周）**：启用 WebSocket 数据推送
4. **P3（下周）**：实现完整的降级和自动恢复机制
