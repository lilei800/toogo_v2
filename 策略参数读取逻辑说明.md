# 策略参数读取逻辑说明

## 一、创建订单时保存策略参数

### 1.1 保存位置（robot_engine.go:3931-3942）

**函数**: `recordOrder()`

**保存的字段**:
```go
if strategyParams != nil {
    if strategyParams.StopLossPercent > 0 {
        orderData["stop_loss_percent"] = strategyParams.StopLossPercent
    }
    if strategyParams.AutoStartRetreatPercent > 0 {
        orderData["auto_start_retreat_percent"] = strategyParams.AutoStartRetreatPercent
    }
    if strategyParams.ProfitRetreatPercent > 0 {
        orderData["profit_retreat_percent"] = strategyParams.ProfitRetreatPercent
    }
}
```

**保存时机**: 订单创建时，使用下单时的策略参数

**数据库字段**:
- `stop_loss_percent`: 止损百分比
- `auto_start_retreat_percent`: 启动止盈百分比
- `profit_retreat_percent`: 止盈回撤百分比

## 二、后端判断时读取策略参数

### 2.1 自动平仓判断（robot_engine.go:3558-3582）

**函数**: `shouldCloseFromOrder()`

**读取方式**:
```go
// 从数据库订单中获取策略参数（订单状态每秒同步，参数已是最新）
var stopLossPercent, autoStartRetreatPercent, profitRetreatPercent float64
orderData, err := dao.TradingOrder.Ctx(ctx).
    Fields("stop_loss_percent", "auto_start_retreat_percent", "profit_retreat_percent").
    WherePri(order.Id).
    One()

if err == nil && !orderData.IsEmpty() {
    // 从订单中获取策略参数
    if val := orderData["stop_loss_percent"]; val != nil {
        if v := val.Float64(); v > 0 {
            stopLossPercent = v
        }
    }
    if val := orderData["auto_start_retreat_percent"]; val != nil {
        if v := val.Float64(); v > 0 {
            autoStartRetreatPercent = v
        }
    }
    if val := orderData["profit_retreat_percent"]; val != nil {
        if v := val.Float64(); v > 0 {
            profitRetreatPercent = v
        }
    }
}
```

**使用场景**:
- ✅ 止损判断：使用订单中的 `stop_loss_percent`
- ✅ 启动止盈判断：使用订单中的 `auto_start_retreat_percent`
- ✅ 止盈回撤判断：使用订单中的 `profit_retreat_percent`

**兜底机制**: 如果订单中没有参数，使用默认值（止损10%，启动止盈5%，止盈回撤30%）

## 三、前端显示时读取策略参数

### 3.1 获取订单策略参数（index.vue:1773-1793）

**函数**: `getOrderStrategyParam()`

**逻辑**:
```javascript
const getOrderStrategyParam = (pos: any, paramName: string, robotId: number, fallbackGetter: (id: number) => number | null): number | null => {
  // 只使用订单创建时的参数（最准确，因为这是下单时使用的实际参数）
  // 支持驼峰和下划线两种命名方式
  const camelCaseName = paramName; // stopLossPercent
  const snakeCaseName = paramName.replace(/([A-Z])/g, '_$1').toLowerCase(); // stop_loss_percent
  
  // 优先使用驼峰命名（后端返回的 JSON 字段名）
  let value = pos[camelCaseName];
  if (value === undefined || value === null) {
    // 其次使用下划线命名
    value = pos[snakeCaseName];
  }
  
  // 检查值是否有效（大于0）
  if (value !== undefined && value !== null && typeof value === 'number' && value > 0) {
    return value;
  }
  
  // 如果订单中没有参数，返回 null（不使用数据库静态值）
  return null;
};
```

**特点**:
- ✅ **优先使用订单中的参数**（`pos.stopLossPercent` 或 `pos.stop_loss_percent`）
- ✅ 如果订单中没有参数，返回 `null`（不使用数据库静态值）
- ✅ 支持驼峰和下划线两种命名方式

### 3.2 后端返回持仓数据（robot.go:271-310）

**函数**: `GetRobotPositions()`

**读取方式**:
```go
// 查询订单创建时的策略参数（优先使用订单创建时的参数）
orderData, err := dao.TradingOrder.Ctx(ctx).
    Fields("stop_loss_percent", "auto_start_retreat_percent", "profit_retreat_percent", "margin_percent").
    Where("robot_id", robotId).
    Where("symbol", pos.Symbol).
    Where("direction", ...).
    Where("status", 1). // 持仓中
    OrderDesc("created_at").
    One()

// 从查询结果中提取策略参数
if val := orderData["auto_start_retreat_percent"]; val != nil {
    if v := val.Float64(); v > 0 {
        autoStartRetreatPercent = &v
    }
}
if val := orderData["profit_retreat_percent"]; val != nil {
    if v := val.Float64(); v > 0 {
        profitRetreatPercent = &v
    }
}
```

**返回给前端**:
```go
result = append(result, &toogoin.PositionModel{
    // ...
    StopLossPercent:         stopLossPercent,
    AutoStartRetreatPercent: autoStartRetreatPercent,
    ProfitRetreatPercent:    profitRetreatPercent,
    // ...
})
```

### 3.3 前端血条计算使用订单参数

**启动止盈血条**（index.vue:1900）:
```javascript
const autoStartPercent = getOrderStrategyParam(pos, 'autoStartRetreatPercent', robot.id, getRobotAutoStartRetreat);
```

**止盈回撤血条**（index.vue:1868）:
```javascript
const profitRetreatPercent = getOrderStrategyParam(pos, 'profitRetreatPercent', robot.id, getRobotProfitRetreat);
```

**止损血条**（index.vue:1804）:
```javascript
const stopLossPercent = getOrderStrategyParam(pos, 'stopLossPercent', robot.id, getRobotStopLossPercent);
```

## 四、完整流程总结

### 4.1 创建订单时
1. 获取策略参数：从策略模板加载（根据市场状态和风险偏好）
2. 保存到订单：`stop_loss_percent`, `auto_start_retreat_percent`, `profit_retreat_percent`
3. 数据库记录：订单表中保存这些字段

### 4.2 后端判断时
1. 读取订单参数：从订单表查询策略参数
2. 使用订单参数：进行止损、启动止盈、止盈回撤判断
3. 兜底机制：如果订单中没有参数，使用默认值

### 4.3 前端显示时
1. 后端返回：`GetRobotPositions()` 从订单中读取参数并返回
2. 前端获取：`getOrderStrategyParam()` 优先使用订单中的参数
3. 血条计算：使用订单创建时的参数进行计算

## 五、关键优势

### 5.1 参数一致性
- ✅ **每个订单使用创建时的策略参数**，不受后续策略变更影响
- ✅ 确保订单的止损止盈逻辑与创建时一致

### 5.2 参数准确性
- ✅ **使用实际下单时的参数**，而不是当前策略模板的参数
- ✅ 避免策略变更影响已有订单

### 5.3 状态持久化
- ✅ 参数保存在订单表中，重启后仍可使用
- ✅ 订单历史可追溯，便于分析

## 六、结论

**是的，启动止盈值和止盈回撤的值都是从创建订单时保存在订单上的值读取的。**

**读取路径**:
1. **创建订单时**: 保存策略参数到订单表
2. **后端判断时**: 从订单表读取策略参数
3. **前端显示时**: 后端返回订单参数，前端使用订单参数计算血条

**优势**:
- ✅ 参数一致性：每个订单使用创建时的参数
- ✅ 参数准确性：使用实际下单时的参数
- ✅ 状态持久化：参数保存在订单表中

