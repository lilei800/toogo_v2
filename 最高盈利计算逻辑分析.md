# 最高盈利（最高价格）计算逻辑分析

## 一、显示内容

**监控列显示的是"最高盈利"，不是"最高价格"**

- **显示位置**：订单列表的监控列
- **显示内容**：`最高盈利`（maxProfitReached）
- **单位**：USDT（未实现盈亏的最高值）

---

## 二、计算逻辑

### 2.1 后端计算（`server/internal/logic/trading/robot.go`）

**位置：** `GetRobotPositions` 方法

```go
// 获取机器人的持仓
func (s *robotImpl) GetRobotPositions(ctx context.Context, robotId int64) ([]*toogoin.PositionModel, error) {
    // 1. 从引擎获取持仓信息
    engine := toogo.GetRobotTaskManager().GetEngine(robotId)
    if engine == nil {
        return nil, gerror.New("机器人引擎未运行")
    }
    
    positions := engine.CurrentPositions
    // ...
    
    // 2. 获取 PositionTracker（包含最高盈利）
    tracker := engine.PositionTrackers[positionKey]
    
    // 3. 设置 maxProfitReached
    var maxProfitReached float64
    if tracker != nil && tracker.HighestProfit > 0 {
        maxProfitReached = tracker.HighestProfit
    } else if pos.UnrealizedPnl > 0 {
        // 如果引擎中没有最高盈利记录，且当前未实现盈亏为正，初始化为当前盈亏
        maxProfitReached = pos.UnrealizedPnl
    }
    
    // 4. 返回给前端
    return &toogoin.PositionModel{
        MaxProfitReached: maxProfitReached,
        // ...
    }
}
```

---

### 2.2 引擎跟踪（`server/internal/logic/toogo/robot_engine.go`）

**位置：** `PositionTracker` 结构体和 `shouldClose` 方法

```go
// PositionTracker 持仓跟踪器
type PositionTracker struct {
    EntryTime        time.Time
    EntryMargin      float64
    HighestProfit    float64   // ← 最高盈利金额
    TakeProfitEnabled bool     // ← 是否启动止盈
}

// shouldClose 检查是否应该平仓
func (t *RobotTrader) shouldClose(ctx context.Context, pos *exchange.Position) bool {
    // ...
    
    // 【重要】只有正盈利才更新最高盈利
    if pos.UnrealizedPnl > 0 && pos.UnrealizedPnl > tracker.HighestProfit {
        tracker.HighestProfit = pos.UnrealizedPnl  // ← 更新最高盈利
    }
    
    // ...
}
```

**关键逻辑：**
- ✅ 只有**未实现盈亏为正**时才更新最高盈利
- ✅ 最高盈利**只增加不减少**
- ✅ 平仓后清除 `PositionTracker`

---

### 2.3 前端计算（`web/src/views/toogo/robot/index.vue`）

#### 2.3.1 加载持仓数据时（`loadPositionData`）

```javascript
const loadPositionData = async () => {
  for (const robot of runningRobots) {
    const posRes = await ToogoRobotApi.positions({ robotId: robot.id });
    if (posRes?.list) {
      const oldPositions = positionData.value[robot.id] || [];
      const newPositions = posRes.list.map((newPos: any) => {
        // 1. 获取后端返回的最高盈利和旧值中的较大者
        const backendMaxProfit = newPos.maxProfitReached || 0;
        const oldMaxProfit = oldPos?.maxProfitReached || 0;
        let finalMaxProfit = Math.max(backendMaxProfit, oldMaxProfit);
        
        // 2. 如果当前未实现盈亏为正且大于记录的最高盈利，更新最高盈利（只增加不减少）
        const currentProfit = newPos.unrealizedPnl || 0;
        if (currentProfit > 0 && currentProfit > finalMaxProfit) {
          finalMaxProfit = currentProfit;
        }
        
        return {
          ...newPos,
          maxProfitReached: finalMaxProfit
        };
      });
      positionData.value[robot.id] = newPositions;
    }
  }
};
```

**关键逻辑：**
- ✅ 使用后端返回的 `maxProfitReached` 或旧值中的较大者
- ✅ 如果当前未实现盈亏为正且大于记录的最高盈利，更新最高盈利
- ✅ **只增加不减少**

---

#### 2.3.2 实时价格刷新时（`refreshRealTimeData`）

```javascript
// 【重要】使用实时行情更新持仓的未实现盈亏
const currentPrice = item.ticker?.lastPrice;
if (currentPrice && positionData.value[robotId]?.length > 0) {
  const maxProfitCache = getMaxProfitCache();
  
  positionData.value[robotId] = positionData.value[robotId].map((pos: any) => {
    // 计算未实现盈亏: (当前价 - 开仓价) * 数量 * 方向
    const direction = pos.positionSide === 'LONG' ? 1 : -1;
    const quantity = Math.abs(pos.positionAmt || 0);
    const entryPrice = pos.entryPrice || 0;
    
    const priceDiff = currentPrice - entryPrice;
    const unrealizedPnl = priceDiff * quantity * direction;
    
    // 更新最高盈利值（只有盈利时才更新）
    const cacheKey = `${robotId}_${pos.symbol}_${pos.positionSide}`;
    let maxProfitReached = pos.maxProfitReached || 0;
    
    // 【重要】只有盈利才能更新最高盈利
    if (unrealizedPnl > 0 && unrealizedPnl > maxProfitReached) {
      maxProfitReached = unrealizedPnl;
      maxProfitCache[cacheKey] = maxProfitReached;
    }
    
    return {
      ...pos,
      markPrice: currentPrice,
      unrealizedPnl: unrealizedPnl,
      maxProfitReached: maxProfitReached,
    };
  });
  
  // 保存到 localStorage
  saveMaxProfitCache(maxProfitCache);
}
```

**关键逻辑：**
- ✅ 使用实时价格计算未实现盈亏
- ✅ 如果未实现盈亏为正且大于记录的最高盈利，更新最高盈利
- ✅ 保存到 `localStorage` 防止页面刷新后丢失

---

#### 2.3.3 localStorage 缓存

```javascript
// 使用 localStorage 持久化最高盈利，防止页面刷新后丢失
const MAX_PROFIT_STORAGE_KEY = 'toogo_max_profit_cache';

// 从 localStorage 获取最高盈利缓存
const getMaxProfitCache = (): Record<string, number> => {
  try {
    const cached = localStorage.getItem(MAX_PROFIT_STORAGE_KEY);
    return cached ? JSON.parse(cached) : {};
  } catch {
    return {};
  }
};

// 保存最高盈利到 localStorage
const saveMaxProfitCache = (cache: Record<string, number>) => {
  try {
    localStorage.setItem(MAX_PROFIT_STORAGE_KEY, JSON.stringify(cache));
  } catch {
    // ignore
  }
};
```

**缓存键格式：** `${robotId}_${symbol}_${positionSide}`

---

## 三、数据流向

```
后端引擎：
  持仓跟踪器（PositionTracker）
    ↓
  HighestProfit（最高盈利）
    ↓
GetRobotPositions API
    ↓
返回 maxProfitReached
    ↓
前端 loadPositionData
    ↓
合并后端值和旧值中的较大者
    ↓
如果当前未实现盈亏为正且大于记录的最高盈利，更新最高盈利
    ↓
实时价格刷新
    ↓
使用实时价格计算未实现盈亏
    ↓
如果未实现盈亏为正且大于记录的最高盈利，更新最高盈利
    ↓
保存到 localStorage
    ↓
显示在监控列
```

---

## 四、计算规则总结

### 4.1 核心规则

1. **只记录正盈利**
   - ✅ 只有未实现盈亏为正时才更新最高盈利
   - ✅ 如果未实现盈亏为负，不更新最高盈利

2. **只增加不减少**
   - ✅ 最高盈利只增加，不会减少
   - ✅ 如果当前未实现盈亏小于最高盈利，不更新

3. **多数据源合并**
   - ✅ 后端返回的 `maxProfitReached`
   - ✅ 前端旧值中的 `maxProfitReached`
   - ✅ 当前计算的未实现盈亏
   - ✅ localStorage 缓存的值
   - ✅ 取这些值中的最大值

4. **持久化**
   - ✅ 保存到 `localStorage` 防止页面刷新后丢失
   - ✅ 缓存键：`${robotId}_${symbol}_${positionSide}`

---

### 4.2 计算公式

**未实现盈亏计算：**
```javascript
// 多单：未实现盈亏 = (当前价 - 开仓价) × 持仓量
// 空单：未实现盈亏 = (开仓价 - 当前价) × 持仓量
const direction = pos.positionSide === 'LONG' ? 1 : -1;
const priceDiff = currentPrice - entryPrice;
const unrealizedPnl = priceDiff * quantity * direction;
```

**最高盈利更新：**
```javascript
// 只有盈利时才更新，且只增加不减少
if (unrealizedPnl > 0 && unrealizedPnl > maxProfitReached) {
  maxProfitReached = unrealizedPnl;
}
```

---

## 五、显示位置

**前端模板：**
```vue
<!-- 最高盈利 -->
<div class="monitor-item monitor-max-profit">
  <div class="monitor-label">最高盈利</div>
  <div class="monitor-value">
    <span v-if="pos.maxProfitReached > 0" style="color: #22c55e;">
      {{ pos.maxProfitReached.toFixed(4) }} USDT
    </span>
    <span v-else>--</span>
  </div>
</div>
```

---

## 六、问题分析

### 6.1 用户问的是"最高价格"

**可能误解：**
- ❌ 用户可能认为显示的是"最高价格"（价格）
- ✅ 实际显示的是"最高盈利"（未实现盈亏的最高值）

**说明：**
- ✅ 显示的是**未实现盈亏的最高值**，单位是 USDT
- ✅ 不是价格，而是盈利金额

---

### 6.2 计算逻辑是否正确？

**当前逻辑：**
- ✅ 只记录正盈利
- ✅ 只增加不减少
- ✅ 多数据源合并
- ✅ 持久化到 localStorage

**潜在问题：**
- ⚠️ 如果后端引擎重启，`PositionTracker` 会丢失，需要重新初始化
- ⚠️ 如果前端页面刷新，`localStorage` 缓存可能丢失（但后端会返回）

---

## 七、总结

### 7.1 计算逻辑

1. **后端引擎跟踪**
   - ✅ `PositionTracker.HighestProfit` 跟踪最高盈利
   - ✅ 只有正盈利时才更新
   - ✅ 只增加不减少

2. **前端合并**
   - ✅ 合并后端返回值和旧值中的较大者
   - ✅ 实时价格刷新时更新最高盈利
   - ✅ 保存到 localStorage 持久化

3. **显示**
   - ✅ 显示在监控列的"最高盈利"
   - ✅ 单位：USDT
   - ✅ 格式：`maxProfitReached.toFixed(4)`

### 7.2 关键点

- ✅ **最高盈利 = 未实现盈亏的最高值**（不是价格）
- ✅ **只记录正盈利**（亏损时不更新）
- ✅ **只增加不减少**（符合用户理解）
- ✅ **多数据源合并**（后端、前端、localStorage）

---

## 八、建议

如果用户想要显示"最高价格"而不是"最高盈利"，需要：
1. 添加价格跟踪逻辑
2. 记录持仓期间的最高价格
3. 修改前端显示

但根据当前代码，显示的是"最高盈利"（未实现盈亏的最高值），这是正确的。

