# 原始配置来源分析

## 一、创建时的原始配置是如何得到的？

### 1.1 数据流程

```
创建机器人时：
  前端传递：
    - marketState: "trend"
    - riskPreference: "balanced"
    - marketRiskMapping: {...}
    - strategyGroupId: 18
  ↓
后端处理：
  1. 调用 GetRecommendStrategy(ctx, "balanced", "trend")
  2. 从数据库查询策略模板：
     SELECT * FROM hg_trading_strategy_template 
     WHERE risk_preference = 'balanced' 
     AND market_state = 'trend'
  3. 返回策略模板的参数：
     - monitorWindow: 60
     - volatilityThreshold: 50
     - leverage: 10
     - marginPercent: 10
     - stopLossPercent: 10
     - profitRetreatPercent: 10
     - autoStartRetreatPercent: 5
  ↓
构建 CurrentStrategy JSON：
  {
    "strategyKey": "...",
    "strategyName": "...",
    "monitorWindow": 60,        // ← 来自策略模板
    "volatilityThreshold": 50,   // ← 来自策略模板
    "leverageMin": 10,          // ← 来自策略模板
    "leverageMax": 10,          // ← 来自策略模板
    "marginPercentMin": 10,     // ← 来自策略模板
    "marginPercentMax": 10,     // ← 来自策略模板
    "stopLossPercent": 10,      // ← 来自策略模板
    "profitRetreatPercent": 10, // ← 来自策略模板
    "autoStartRetreatPercent": 5, // ← 来自策略模板
    "groupId": 18,              // ← 来自前端或策略模板
    "riskConfig": {
      "marketRiskMapping": {    // ← 来自前端配置
        "trend": "balanced",
        "volatile": "balanced",
        ...
      }
    }
  }
  ↓
保存到数据库：
  INSERT INTO hg_trading_robot (..., current_strategy) VALUES (..., '{"monitorWindow":60,...}')
```

---

## 二、原始配置的来源

### 2.1 策略参数来源

**来源：策略模板表（`hg_trading_strategy_template`）**

```go
// 创建机器人时
strategy, err := s.GetRecommendStrategy(ctx, in.RiskPreference, in.MarketState)

// GetRecommendStrategy 的实现
func (s *robotImpl) GetRecommendStrategy(ctx context.Context, riskPreference, marketState string) {
    var strategy *entity.TradingStrategyTemplate
    err := dao.TradingStrategyTemplate.Ctx(ctx).
        Where(dao.TradingStrategyTemplate.Columns().RiskPreference, riskPreference).
        Where(dao.TradingStrategyTemplate.Columns().MarketState, marketState).
        Scan(&strategy)
    
    // 返回策略模板的参数
    return &TradingRobotRecommendStrategyModel{
        MonitorWindow:           strategy.MonitorWindow,      // ← 从数据库查询
        VolatilityThreshold:     strategy.VolatilityThreshold, // ← 从数据库查询
        LeverageMin:             strategy.Leverage,           // ← 从数据库查询
        // ... 其他参数
    }
}
```

**关键点：**
- ✅ 原始配置来自**创建时查询的策略模板**
- ✅ 是创建时**策略模板的快照**
- ✅ 保存了创建时策略模板的**所有参数**

---

### 2.2 映射关系来源

**来源：前端用户配置**

```javascript
// 前端创建机器人时
const data = {
  marketRiskMapping: {
    trend: 'balanced',
    volatile: 'balanced',
    high_vol: 'aggressive',
    low_vol: 'conservative',
  }
}
```

**关键点：**
- ✅ 映射关系来自**用户在前端的配置**
- ✅ 是用户**自定义的配置**
- ✅ 保存了用户**期望的映射关系**

---

### 2.3 策略组ID来源

**来源：前端传递或策略模板**

```go
// 优先使用前端传递的
if in.StrategyGroupId > 0 {
    strategyConfig["groupId"] = in.StrategyGroupId  // ← 来自前端
} else if strategy.GroupId > 0 {
    strategyConfig["groupId"] = strategy.GroupId    // ← 来自策略模板
}
```

---

## 三、如果实时更新会丢失什么？

### 3.1 丢失的内容

#### 3.1.1 创建时的策略模板参数

**场景1：策略模板被修改**
```
创建时：
  策略模板 A: monitorWindow = 60, volatilityThreshold = 50
  保存到 CurrentStrategy JSON
  
运行时（市场状态变化）：
  策略模板 A: monitorWindow = 90, volatilityThreshold = 60  ← 被修改了
  实时更新 CurrentStrategy JSON
  
结果：
  ❌ 创建时的原始参数（60, 50）丢失了
  ✅ 只能看到最新的参数（90, 60）
```

**场景2：策略模板被删除**
```
创建时：
  策略模板 A: monitorWindow = 60
  保存到 CurrentStrategy JSON
  
运行时（策略模板被删除）：
  查询策略模板失败
  无法更新 CurrentStrategy JSON
  
结果：
  ✅ 创建时的原始参数（60）还在
  ⚠️ 但无法知道创建时使用的是哪个策略模板
```

---

### 3.2 无法追溯的信息

1. **创建时使用的策略模板版本**
   - 如果策略模板被修改，无法知道创建时使用的是哪个版本
   - 无法知道参数是如何变化的

2. **创建时的市场状态和风险偏好**
   - 如果实时更新，无法知道创建时使用的是哪个市场状态和风险偏好
   - 虽然可以从 `Robot.MarketState` 和 `Robot.RiskPreference` 获取，但这些可能被修改

3. **创建时的完整配置快照**
   - 无法知道创建时的完整配置
   - 无法对比创建时和当前的差异

---

## 四、如何保留原始配置？

### 4.1 方案一：保存到单独字段（推荐）⭐⭐⭐

**在 `hg_trading_robot` 表中添加字段：**
```sql
ALTER TABLE hg_trading_robot 
ADD COLUMN initial_strategy_config TEXT COMMENT '创建时的策略配置快照';
```

**创建时保存：**
```go
// 创建机器人时
insertData := g.Map{
    "current_strategy": string(strategyJSON),        // 运行时配置（可更新）
    "initial_strategy_config": string(strategyJSON), // 原始配置（不更新）
}
```

**优点：**
- ✅ 原始配置永久保存
- ✅ 运行时配置可以实时更新
- ✅ 职责清晰：原始配置 vs 运行时配置

**缺点：**
- ⚠️ 需要数据库迁移
- ⚠️ 增加存储空间

---

### 4.2 方案二：保存到历史记录表（最佳）⭐⭐⭐⭐

**创建历史记录表：**
```sql
CREATE TABLE hg_trading_robot_strategy_history (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    robot_id BIGINT NOT NULL,
    strategy_config TEXT NOT NULL COMMENT '策略配置JSON',
    market_state VARCHAR(50) NOT NULL COMMENT '市场状态',
    risk_preference VARCHAR(50) NOT NULL COMMENT '风险偏好',
    created_at DATETIME NOT NULL COMMENT '创建时间',
    INDEX idx_robot_id (robot_id),
    INDEX idx_created_at (created_at)
);
```

**创建时保存：**
```go
// 创建机器人时
// 1. 保存到 CurrentStrategy（运行时配置）
insertData["current_strategy"] = string(strategyJSON)

// 2. 保存到历史记录表（原始配置）
dao.TradingRobotStrategyHistory.Ctx(ctx).Insert(g.Map{
    "robot_id": robotId,
    "strategy_config": string(strategyJSON),
    "market_state": in.MarketState,
    "risk_preference": in.RiskPreference,
    "created_at": gtime.Now(),
})
```

**运行时更新：**
```go
// 市场状态变化时
// 1. 更新 CurrentStrategy（运行时配置）
e.updateCurrentStrategyJSON(ctx, ...)

// 2. 可选：保存到历史记录表（记录变化）
dao.TradingRobotStrategyHistory.Ctx(ctx).Insert(g.Map{
    "robot_id": e.Robot.Id,
    "strategy_config": string(newStrategyJSON),
    "market_state": marketState,
    "risk_preference": riskPreference,
    "created_at": gtime.Now(),
})
```

**优点：**
- ✅ 原始配置永久保存
- ✅ 可以记录所有变化历史
- ✅ 可以追溯配置变化轨迹
- ✅ 不影响运行时性能

**缺点：**
- ⚠️ 需要创建新表
- ⚠️ 需要数据库迁移

---

### 4.3 方案三：版本控制（高级）⭐⭐⭐

**在策略配置JSON中添加版本信息：**
```json
{
  "version": "1.0.0",
  "createdAt": "2025-12-06T10:00:00Z",
  "initialConfig": {
    "monitorWindow": 60,
    "volatilityThreshold": 50,
    // ... 原始配置
  },
  "currentConfig": {
    "monitorWindow": 90,
    "volatilityThreshold": 60,
    // ... 当前配置
  },
  "groupId": 18,
  "riskConfig": {
    "marketRiskMapping": {...}
  }
}
```

**优点：**
- ✅ 原始配置和当前配置都在一个JSON中
- ✅ 可以对比差异
- ✅ 不需要数据库迁移

**缺点：**
- ⚠️ JSON结构复杂
- ⚠️ 更新时需要合并，逻辑复杂

---

## 五、推荐方案

### 5.1 综合评估

| 方案 | 实现难度 | 存储成本 | 追溯能力 | 推荐度 |
|------|---------|---------|---------|--------|
| 单独字段 | ⭐⭐ | ⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ |
| 历史记录表 | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| 版本控制 | ⭐⭐⭐⭐ | ⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐ |

### 5.2 最终推荐：**方案二（历史记录表）** ⭐⭐⭐⭐⭐

**理由：**
1. ✅ **完整的追溯能力**：可以查看所有配置变化历史
2. ✅ **不影响运行时性能**：历史记录独立存储
3. ✅ **便于问题排查**：可以对比不同时间点的配置
4. ✅ **扩展性好**：可以记录更多信息（如变化原因、操作人等）

---

## 六、实施建议

### 6.1 短期方案（快速实施）

**使用方案一（单独字段）：**
```sql
ALTER TABLE hg_trading_robot 
ADD COLUMN initial_strategy_config TEXT COMMENT '创建时的策略配置快照';
```

**创建时保存：**
```go
insertData["initial_strategy_config"] = string(strategyJSON)
```

**优点：**
- ✅ 实现简单，不需要创建新表
- ✅ 可以快速实施

---

### 6.2 长期方案（完整方案）

**使用方案二（历史记录表）：**
- ✅ 创建历史记录表
- ✅ 创建时保存原始配置
- ✅ 运行时可以记录配置变化（可选）

**优点：**
- ✅ 完整的追溯能力
- ✅ 可以分析配置变化趋势

---

## 七、总结

### 7.1 原始配置的来源

1. **策略参数**：来自创建时查询的策略模板（`hg_trading_strategy_template`）
2. **映射关系**：来自前端用户配置
3. **策略组ID**：来自前端传递或策略模板

### 7.2 如果实时更新会丢失什么

- ❌ 创建时的策略模板参数（如果策略模板被修改）
- ❌ 创建时的完整配置快照
- ❌ 无法追溯配置变化历史

### 7.3 如何保留原始配置

**推荐方案：历史记录表**
- ✅ 创建时保存原始配置到历史记录表
- ✅ 运行时可以实时更新 `CurrentStrategy`
- ✅ 可以追溯所有配置变化历史

**这样既能保证运行时配置的实时性，又能保留原始配置的完整性。**

