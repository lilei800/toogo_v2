# 每个方向只能下一单检查逻辑确认

## ✅ 逻辑已正确实现

### 检查机制

信号事件会检查**每个方向只能下一单**，逻辑如下：

---

## 实现位置

### 1. 信号事件处理入口

**位置**：`TryAutoTradeAndUpdate()` 方法

```go
// 提前过滤：只处理开仓信号
if signal.Action != "OPEN_LONG" && signal.Action != "OPEN_SHORT" {
    return
}

// 下单前再次检查条件（可能已变化）
canTrade, reason := t.checkTradingConditions(ctx, signal)
if !canTrade {
    // 拒绝下单，记录原因
    return
}
```

---

### 2. 方向检查逻辑（核心）

**位置**：`checkTradingConditions()` 方法

```go
// 确定持仓方向
positionSide := "LONG"
if signal.Direction == "SHORT" {
    positionSide = "SHORT"
}

// 【关键】同步等待订单状态同步完成
syncCtx, cancel := context.WithTimeout(ctx, 3*time.Second)
defer cancel()
GetOrderStatusSyncService().SyncSingleRobot(syncCtx, robot.Id)

// 【双重检查】检查该方向是否有持仓
// 1. 检查内存中的持仓（已同步）
hasMemoryPosition := t.engine.HasActivePosition(positionSide)

// 2. 检查数据库中的订单状态（作为双重验证，已同步）
hasDbOrder := false
dbDirection := "long"
if positionSide == "SHORT" {
    dbDirection = "short"
}
count, err := dao.TradingOrder.Ctx(ctx).
    Where("robot_id", robot.Id).
    Where("direction", dbDirection).  // ✅ 只检查该方向
    Where("status", 1). // 持仓中
    Count()

// 任一有持仓，都认为有持仓
if hasMemoryPosition || hasDbOrder {
    return false, "该方向已有持仓"  // ✅ 拒绝下单
}
```

---

### 3. 内存持仓检查

**位置**：`HasActivePosition()` 方法

```go
func (e *RobotEngine) HasActivePosition(side string) bool {
    e.mu.RLock()
    defer e.mu.RUnlock()
    
    for _, pos := range e.CurrentPositions {
        if pos.PositionAmt != 0 && pos.PositionSide == side {  // ✅ 只检查特定方向
            return true
        }
    }
    return false
}
```

---

## 检查流程

```
信号事件触发（OPEN_LONG 或 OPEN_SHORT）
  ↓
确定持仓方向（LONG 或 SHORT）
  ↓
同步等待订单状态同步完成
  ↓
检查内存持仓（HasActivePosition(positionSide)）
  ├─ 只检查该方向（LONG 或 SHORT）
  └─ 如果该方向有持仓 → 拒绝下单
  ↓
检查数据库订单状态
  ├─ Where("direction", dbDirection)  // 只检查该方向
  ├─ Where("status", 1)  // 持仓中
  └─ 如果该方向有持仓订单 → 拒绝下单
  ↓
双重验证：任一有持仓 → 拒绝下单
  ↓
无持仓 → 允许下单
```

---

## 关键特性

### ✅ 1. 方向独立检查
- **LONG方向**：只检查LONG方向的持仓
- **SHORT方向**：只检查SHORT方向的持仓
- **互不影响**：可以同时持有LONG和SHORT方向的订单

### ✅ 2. 双重验证
- **内存持仓检查**：检查内存中的持仓状态
- **数据库订单检查**：检查数据库中的订单状态
- **任一有持仓**：都拒绝下单

### ✅ 3. 同步等待
- **同步订单状态**：确保检查的是最新数据
- **避免重复下单**：防止检查到旧数据

---

## 示例场景

### 场景1：已有LONG持仓，收到LONG信号
```
信号：OPEN_LONG
  ↓
检查LONG方向持仓
  ├─ 内存：有LONG持仓 ✅
  └─ 数据库：有LONG订单 ✅
  ↓
结果：拒绝下单 ✅ "该方向已有持仓"
```

### 场景2：已有LONG持仓，收到SHORT信号
```
信号：OPEN_SHORT
  ↓
检查SHORT方向持仓
  ├─ 内存：无SHORT持仓 ✅
  └─ 数据库：无SHORT订单 ✅
  ↓
结果：允许下单 ✅（可以同时持有LONG和SHORT）
```

### 场景3：无持仓，收到LONG信号
```
信号：OPEN_LONG
  ↓
检查LONG方向持仓
  ├─ 内存：无LONG持仓 ✅
  └─ 数据库：无LONG订单 ✅
  ↓
结果：允许下单 ✅
```

### 场景4：已有LONG持仓，再次收到LONG信号
```
信号：OPEN_LONG（重复）
  ↓
检查LONG方向持仓
  ├─ 内存：有LONG持仓 ✅
  └─ 数据库：有LONG订单 ✅
  ↓
结果：拒绝下单 ✅ "该方向已有持仓"
```

---

## 验证点

### ✅ 1. 方向独立性
- LONG和SHORT方向独立检查
- 可以同时持有两个方向的订单
- 每个方向只能有一单

### ✅ 2. 检查准确性
- 同步等待订单状态同步完成
- 双重验证（内存 + 数据库）
- 确保检查的是最新数据

### ✅ 3. 拒绝逻辑
- 任一有持仓都拒绝下单
- 返回明确的错误信息："该方向已有持仓"

---

## 总结

✅ **逻辑已正确实现**

**核心机制**：
1. ✅ 根据信号方向确定检查方向（LONG 或 SHORT）
2. ✅ 同步等待订单状态同步完成
3. ✅ 双重检查：内存持仓 + 数据库订单状态
4. ✅ 只检查该方向，不影响其他方向
5. ✅ 任一有持仓都拒绝下单

**效果**：
- ✅ 每个方向只能下一单
- ✅ LONG和SHORT方向可以同时持有
- ✅ 避免重复下单
- ✅ 确保检查准确性

逻辑完全正确，可以正常工作！

