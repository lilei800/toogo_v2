# 创建机器人时获取原始配置策略参数的流程

## 一、完整流程

### 1.1 前端创建机器人

**前端传递的数据：**
```javascript
const data = {
  robotName: "测试机器人",
  apiConfigId: 1,
  strategyGroupId: 18,              // ← 策略组ID（用户选择）
  marketRiskMapping: {              // ← 映射关系（用户配置）
    trend: 'balanced',
    volatile: 'balanced',
    high_vol: 'aggressive',
    low_vol: 'conservative',
  },
  marketState: 'trend',             // ← 创建时的市场状态（默认值）
  riskPreference: 'balanced',       // ← 创建时的风险偏好（默认值）
  // ... 其他字段
}
```

**关键点：**
- ✅ 用户选择的是**策略组**（`strategyGroupId`）
- ✅ 用户配置的是**映射关系**（`marketRiskMapping`）
- ✅ `marketState` 和 `riskPreference` 是**默认值**，用于获取创建时的推荐策略

---

### 1.2 后端处理流程

```
1. 接收创建请求
   ↓
2. 验证API配置
   ↓
3. 调用 GetRecommendStrategy(ctx, in.RiskPreference, in.MarketState)
   ↓
4. 从数据库查询策略模板：
   SELECT * FROM hg_trading_strategy_template 
   WHERE risk_preference = 'balanced' 
   AND market_state = 'trend'
   ↓
5. 返回策略模板的参数：
   - monitorWindow: 60
   - volatilityThreshold: 50
   - leverage: 10
   - marginPercent: 10
   - stopLossPercent: 10
   - profitRetreatPercent: 10
   - autoStartRetreatPercent: 5
   ↓
6. 构建 CurrentStrategy JSON：
   {
     "monitorWindow": 60,
     "volatilityThreshold": 50,
     "leverageMin": 10,
     "leverageMax": 10,
     "marginPercentMin": 10,
     "marginPercentMax": 10,
     "stopLossPercent": 10,
     "profitRetreatPercent": 10,
     "autoStartRetreatPercent": 5,
     "groupId": 18,
     "riskConfig": {
       "marketRiskMapping": {...}
     }
   }
   ↓
7. 保存到数据库
```

---

## 二、关键代码分析

### 2.1 后端获取推荐策略

**位置：** `server/internal/logic/trading/robot.go`

```go
// Create 创建机器人
func (s *robotImpl) Create(ctx context.Context, in *input.TradingRobotCreateInp) (id int64, err error) {
    // ... 验证API配置 ...
    
    // ✅ 根据风险偏好和市场状态获取推荐策略
    strategy, err := s.GetRecommendStrategy(ctx, in.RiskPreference, in.MarketState)
    if err != nil {
        return 0, gerror.Wrap(err, "获取推荐策略失败")
    }
    
    // ✅ 构建完整的策略配置JSON（包含策略参数和映射关系）
    strategyConfig := map[string]interface{}{
        // 策略参数（从推荐策略获取）
        "strategyKey":             strategy.StrategyKey,
        "strategyName":            strategy.StrategyName,
        "description":             strategy.Description,
        "monitorWindow":           strategy.MonitorWindow,        // ← 来自策略模板
        "volatilityThreshold":     strategy.VolatilityThreshold,  // ← 来自策略模板
        "leverageMin":             strategy.LeverageMin,          // ← 来自策略模板
        "leverageMax":             strategy.LeverageMax,          // ← 来自策略模板
        "marginPercentMin":        strategy.MarginPercentMin,     // ← 来自策略模板
        "marginPercentMax":        strategy.MarginPercentMax,     // ← 来自策略模板
        "stopLossPercent":         strategy.StopLossPercent,      // ← 来自策略模板
        "profitRetreatPercent":    strategy.ProfitRetreatPercent, // ← 来自策略模板
        "autoStartRetreatPercent": strategy.AutoStartRetreatPercent, // ← 来自策略模板
        "groupId":                 in.StrategyGroupId,            // ← 来自前端
        "riskConfig": map[string]interface{}{
            "marketRiskMapping": in.MarketRiskMapping,           // ← 来自前端
        },
    }
    
    // 保存到数据库
    // ...
}
```

---

### 2.2 GetRecommendStrategy 实现

**位置：** `server/internal/logic/trading/robot.go`

```go
// GetRecommendStrategy 获取推荐策略（内部方法）
func (s *robotImpl) GetRecommendStrategy(ctx context.Context, riskPreference, marketState string) (*input.TradingRobotRecommendStrategyModel, error) {
    // ✅ 从数据库查询策略模板
    var strategy *entity.TradingStrategyTemplate
    err := dao.TradingStrategyTemplate.Ctx(ctx).
        Where(dao.TradingStrategyTemplate.Columns().RiskPreference, riskPreference).
        Where(dao.TradingStrategyTemplate.Columns().MarketState, marketState).
        Scan(&strategy)
    
    if err != nil {
        return nil, err
    }
    if strategy == nil {
        return nil, gerror.Newf("未找到匹配的策略: %s + %s", riskPreference, marketState)
    }
    
    // ✅ 返回策略模板的参数
    out := &input.TradingRobotRecommendStrategyModel{
        StrategyKey:             strategy.StrategyKey,
        StrategyName:            strategy.StrategyName,
        Description:             strategy.Description,
        MonitorWindow:           strategy.MonitorWindow,           // ← 从数据库查询
        VolatilityThreshold:     strategy.VolatilityThreshold,   // ← 从数据库查询
        LeverageMin:             strategy.Leverage,                // ← 从数据库查询
        LeverageMax:             strategy.Leverage,                // ← 从数据库查询
        MarginPercentMin:        strategy.MarginPercent,           // ← 从数据库查询
        MarginPercentMax:        strategy.MarginPercent,           // ← 从数据库查询
        StopLossPercent:         strategy.StopLossPercent,        // ← 从数据库查询
        ProfitRetreatPercent:    strategy.ProfitRetreatPercent,    // ← 从数据库查询
        AutoStartRetreatPercent: strategy.AutoStartRetreatPercent, // ← 从数据库查询
        GroupId:                 strategy.GroupId,               // ← 从数据库查询
    }
    
    return out, nil
}
```

---

### 2.3 数据库查询

**查询的表：** `hg_trading_strategy_template`

**查询条件：**
- `risk_preference = 'balanced'`
- `market_state = 'trend'`

**返回的字段：**
- `monitor_window` → `MonitorWindow`
- `volatility_threshold` → `VolatilityThreshold`
- `leverage` → `LeverageMin` / `LeverageMax`
- `margin_percent` → `MarginPercentMin` / `MarginPercentMax`
- `stop_loss_percent` → `StopLossPercent`
- `profit_retreat_percent` → `ProfitRetreatPercent`
- `auto_start_retreat_percent` → `AutoStartRetreatPercent`
- `group_id` → `GroupId`

---

## 三、问题分析

### 3.1 ⚠️ 当前实现的问题

**问题1：查询条件不完整**
```go
// 当前实现
dao.TradingStrategyTemplate.Ctx(ctx).
    Where(dao.TradingStrategyTemplate.Columns().RiskPreference, riskPreference).
    Where(dao.TradingStrategyTemplate.Columns().MarketState, marketState).
    Scan(&strategy)
```

**问题：**
- ❌ 没有指定 `group_id`，可能查询到错误的策略模板
- ❌ 如果同一个 `riskPreference` + `marketState` 组合在多个策略组中存在，可能返回错误的策略

**示例：**
```
策略组A：
  - trend/balanced: monitorWindow = 60
  
策略组B：
  - trend/balanced: monitorWindow = 90

查询时：
  riskPreference = 'balanced', marketState = 'trend'
  
结果：
  ❌ 可能返回策略组A或策略组B的策略（不确定）
  ✅ 应该返回策略组18（用户选择的策略组）的策略
```

---

### 3.2 ✅ 正确的实现方式

**应该根据策略组ID查询：**
```go
// 正确的实现
dao.TradingStrategyTemplate.Ctx(ctx).
    Where(dao.TradingStrategyTemplate.Columns().GroupId, in.StrategyGroupId).  // ← 添加策略组ID条件
    Where(dao.TradingStrategyTemplate.Columns().RiskPreference, riskPreference).
    Where(dao.TradingStrategyTemplate.Columns().MarketState, marketState).
    Scan(&strategy)
```

**或者：**
```go
// 更简单的方式：直接根据策略组ID和市场状态+风险偏好查询
// 因为用户已经选择了策略组，应该从该策略组中查询
dao.TradingStrategyTemplate.Ctx(ctx).
    Where(dao.TradingStrategyTemplate.Columns().GroupId, in.StrategyGroupId).
    Where(dao.TradingStrategyTemplate.Columns().RiskPreference, riskPreference).
    Where(dao.TradingStrategyTemplate.Columns().MarketState, marketState).
    Scan(&strategy)
```

---

## 四、修复建议

### 4.1 修复 GetRecommendStrategy

**修改前：**
```go
func (s *robotImpl) GetRecommendStrategy(ctx context.Context, riskPreference, marketState string) (*input.TradingRobotRecommendStrategyModel, error) {
    var strategy *entity.TradingStrategyTemplate
    err := dao.TradingStrategyTemplate.Ctx(ctx).
        Where(dao.TradingStrategyTemplate.Columns().RiskPreference, riskPreference).
        Where(dao.TradingStrategyTemplate.Columns().MarketState, marketState).
        Scan(&strategy)
    // ...
}
```

**修改后：**
```go
// 添加 groupId 参数
func (s *robotImpl) GetRecommendStrategy(ctx context.Context, groupId int64, riskPreference, marketState string) (*input.TradingRobotRecommendStrategyModel, error) {
    var strategy *entity.TradingStrategyTemplate
    
    // 如果指定了策略组ID，优先从该策略组查询
    query := dao.TradingStrategyTemplate.Ctx(ctx).
        Where(dao.TradingStrategyTemplate.Columns().RiskPreference, riskPreference).
        Where(dao.TradingStrategyTemplate.Columns().MarketState, marketState)
    
    if groupId > 0 {
        query = query.Where(dao.TradingStrategyTemplate.Columns().GroupId, groupId)
    }
    
    err := query.Scan(&strategy)
    // ...
}
```

**调用处修改：**
```go
// Create 方法中
strategy, err := s.GetRecommendStrategy(ctx, in.StrategyGroupId, in.RiskPreference, in.MarketState)
```

---

### 4.2 或者：直接根据策略组查询

**更简单的方式：**
```go
// Create 方法中
// 如果指定了策略组ID，直接从该策略组查询
if in.StrategyGroupId > 0 {
    var strategyTemplate *entity.TradingStrategyTemplate
    err := dao.TradingStrategyTemplate.Ctx(ctx).
        Where(dao.TradingStrategyTemplate.Columns().GroupId, in.StrategyGroupId).
        Where(dao.TradingStrategyTemplate.Columns().RiskPreference, in.RiskPreference).
        Where(dao.TradingStrategyTemplate.Columns().MarketState, in.MarketState).
        Scan(&strategyTemplate)
    
    if err == nil && strategyTemplate != nil {
        // 使用策略模板的参数
        strategyConfig := map[string]interface{}{
            "monitorWindow":           strategyTemplate.MonitorWindow,
            "volatilityThreshold":     strategyTemplate.VolatilityThreshold,
            // ... 其他参数
        }
    }
}
```

---

## 五、总结

### 5.1 当前获取策略参数的流程

1. **前端传递：**
   - `strategyGroupId`: 18（用户选择的策略组）
   - `marketState`: 'trend'（默认值）
   - `riskPreference`: 'balanced'（默认值）

2. **后端查询：**
   - 调用 `GetRecommendStrategy(ctx, 'balanced', 'trend')`
   - 从 `hg_trading_strategy_template` 表查询
   - 查询条件：`risk_preference = 'balanced' AND market_state = 'trend'`
   - ⚠️ **问题：没有指定 `group_id`，可能查询到错误的策略模板**

3. **返回参数：**
   - 策略模板的所有参数（窗口、波动值、杠杆、保证金、止损等）

4. **保存到数据库：**
   - 构建 `CurrentStrategy` JSON
   - 保存到 `hg_trading_robot.current_strategy` 字段

---

### 5.2 关键发现

**原始配置策略参数的来源：**
- ✅ 来自创建时查询的**策略模板**（`hg_trading_strategy_template`）
- ✅ 查询条件是：`riskPreference` + `marketState`
- ⚠️ **问题：没有指定 `groupId`，可能查询到错误的策略模板**

**修复建议：**
- ✅ 在查询时添加 `groupId` 条件
- ✅ 确保查询到的是用户选择的策略组中的策略模板

---

### 5.3 数据流向

```
创建机器人时：
  前端：
    strategyGroupId: 18
    marketState: 'trend'
    riskPreference: 'balanced'
  ↓
后端：
  查询策略模板：
    SELECT * FROM hg_trading_strategy_template 
    WHERE risk_preference = 'balanced' 
    AND market_state = 'trend'
    ⚠️ 缺少：AND group_id = 18
  ↓
返回策略参数：
    monitorWindow: 60
    volatilityThreshold: 50
    leverage: 10
    ...
  ↓
保存到 CurrentStrategy JSON：
    {
      "monitorWindow": 60,
      "volatilityThreshold": 50,
      "groupId": 18,
      "riskConfig": {...}
    }
```

---

## 六、修复代码

需要修复 `GetRecommendStrategy` 方法，添加 `groupId` 参数，确保查询到正确的策略模板。

