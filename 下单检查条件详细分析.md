# 下单检查条件详细分析

## 一、检查入口

**方法：** `checkTradingConditions(ctx context.Context, signal *RobotSignal) (bool, string)`

**位置：** `server/internal/logic/toogo/robot_engine.go:2367`

**调用时机：**
1. 定时检查时（`CheckAndOpenPosition`）
2. 信号生成时（`TryAutoTradeAndUpdate`）

---

## 二、检查条件列表

### 2.1 ✅ 条件1：自动交易开关

**检查代码：**
```go
if robot.AutoTradeEnabled != 1 {
    return false, "自动下单未开启"
}
```

**条件：**
- ✅ `AutoTradeEnabled == 1`（必须开启自动交易）

**失败原因：** "自动下单未开启"

---

### 2.2 ✅ 条件2：信号类型

**检查代码：**
```go
if signal.Action != "OPEN_LONG" && signal.Action != "OPEN_SHORT" {
    return false, fmt.Sprintf("信号类型为%s，不是开仓信号", signal.Action)
}
```

**条件：**
- ✅ 信号操作必须是 `OPEN_LONG`（开多）或 `OPEN_SHORT`（开空）

**失败原因：** "信号类型为{Action}，不是开仓信号"

---

### 2.3 ✅ 条件3：持仓状态检查

**检查代码：**
```go
// 确定方向
positionSide := "LONG"
oppositeSide := "SHORT"
if signal.Direction == "SHORT" {
    positionSide = "SHORT"
    oppositeSide = "LONG"
}

hasCurrentPosition := t.engine.HasActivePosition(positionSide)
hasOppositePosition := t.engine.HasActivePosition(oppositeSide)

// 每方向最多1单
if hasCurrentPosition {
    return false, "该方向已有持仓"
}
```

**条件：**
- ✅ 该方向没有持仓（每方向最多1单）

**失败原因：** "该方向已有持仓"

**关键点：**
- ✅ 开仓前强制同步持仓（`syncAccountDataIfNeeded(ctx, "before_open")`）
- ✅ 确保持仓状态最新，避免误判

---

### 2.4 ✅ 条件4：反方向下单策略

**检查代码：**
```go
if hasOppositePosition {
    if robot.EnableReverseOrder != 1 {
        return false, "反向下单未开启"
    }
    reason := t.checkReverseCondition(ctx, oppositeSide)
    if reason != "" {
        return false, reason
    }
}
```

**条件：**
- ✅ 如果有反方向持仓：
  - 必须开启反向下单（`EnableReverseOrder == 1`）
  - 必须满足反向下单的回撤条件

**失败原因：**
- "反向下单未开启"
- `checkReverseCondition` 返回的具体原因

**反向下单回撤条件（`checkReverseCondition`）：**

```go
func (t *RobotTrader) checkReverseCondition(ctx context.Context, oppositeSide string) string {
    // 1. 获取反方向持仓
    oppositePos := t.engine.GetPosition(oppositeSide)
    if oppositePos == nil {
        return ""  // 没有反方向持仓，允许下单
    }
    
    // 2. 获取市场状态
    marketState := t.engine.LastMarketState
    if marketState == "" {
        marketState = "trend"  // 默认
    }
    
    // 3. 获取反向下单阈值
    thresholds := GetReverseThresholds(marketState)
    
    // 4. 获取持仓跟踪器
    tracker := t.engine.PositionTrackers[oppositeSide]
    
    // 5. 计算回撤百分比
    var retreatPercent float64
    
    if oppositePos.UnrealizedPnl < 0 {
        // 亏损订单：从最低亏损计算回撤
        if tracker.LowestProfit < 0 {
            retreatPercent = (oppositePos.UnrealizedPnl - tracker.LowestProfit) / (-tracker.LowestProfit) * 100
        }
        // 检查亏损单回撤阈值
        if retreatPercent < thresholds.LossRetreat {
            return fmt.Sprintf("反向订单回撤不足，等待亏损回撤达到%.0f%%后允许(当前%.1f%%)",
                thresholds.LossRetreat, retreatPercent)
        }
    } else {
        // 盈利订单：从最高盈利计算回撤
        if tracker.HighestProfit > 0 {
            retreatPercent = (tracker.HighestProfit - oppositePos.UnrealizedPnl) / tracker.HighestProfit * 100
        }
        // 检查盈利单回撤阈值
        if retreatPercent < thresholds.ProfitRetreat {
            return fmt.Sprintf("反向订单回撤不足，盈利部分回撤达到%.0f%%后允许(当前%.1f%%)",
                thresholds.ProfitRetreat, retreatPercent)
        }
    }
    
    return ""  // 条件满足
}
```

**反向下单回撤条件：**
- ✅ **亏损订单**：回撤百分比 ≥ `LossRetreat`（亏损单反向回撤阈值）
- ✅ **盈利订单**：回撤百分比 ≥ `ProfitRetreat`（盈利单反向回撤阈值）

**回撤计算：**
- **亏损订单**：`(当前亏损 - 最低亏损) / |最低亏损| × 100%`
- **盈利订单**：`(最高盈利 - 当前盈利) / 最高盈利 × 100%`

---

### 2.5 ✅ 条件5：算力检查

**检查代码：**
```go
if !t.checkPower(ctx) {
    return false, "算力不足，请充值"
}
```

**checkPower 方法：**
```go
func (t *RobotTrader) checkPower(ctx context.Context) bool {
    robot := t.engine.Robot
    
    // 查询用户算力
    var wallet struct {
        Power     float64 `json:"power"`
        GiftPower float64 `json:"giftPower"`
    }
    err := g.DB().Model("hg_toogo_wallet").Ctx(ctx).
        Where("user_id", robot.UserId).
        Scan(&wallet)
    
    if err != nil {
        return false
    }
    
    totalPower := wallet.Power + wallet.GiftPower
    
    // 至少需要1点算力
    return totalPower >= 1
}
```

**条件：**
- ✅ 用户算力（`Power + GiftPower`）≥ 1点

**失败原因：** "算力不足，请充值"

---

### 2.6 ✅ 条件6：余额检查

**检查代码：**
```go
balance := t.engine.AccountBalance
if balance == nil || balance.AvailableBalance <= 0 {
    return false, "保证金余额不足"
}
```

**条件：**
- ✅ 账户余额不为 `nil`
- ✅ 可用余额 > 0

**失败原因：** "保证金余额不足"

---

## 三、完整检查流程

```
checkTradingConditions()
  ↓
1. 检查自动交易开关
   ❌ AutoTradeEnabled != 1 → 返回 "自动下单未开启"
   ✅ 继续
  ↓
2. 检查信号类型
   ❌ Action != OPEN_LONG && Action != OPEN_SHORT → 返回 "信号类型为{Action}，不是开仓信号"
   ✅ 继续
  ↓
3. 开仓前强制同步持仓
   syncAccountDataIfNeeded(ctx, "before_open")
  ↓
4. 检查是否已有该方向持仓
   ❌ hasCurrentPosition → 返回 "该方向已有持仓"
   ✅ 继续
  ↓
5. 检查反方向下单策略（如果有反方向持仓）
   ❌ EnableReverseOrder != 1 → 返回 "反向下单未开启"
   ❌ checkReverseCondition() != "" → 返回具体原因
   ✅ 继续
  ↓
6. 检查算力
   ❌ totalPower < 1 → 返回 "算力不足，请充值"
   ✅ 继续
  ↓
7. 检查余额
   ❌ balance == nil || AvailableBalance <= 0 → 返回 "保证金余额不足"
   ✅ 继续
  ↓
返回 true, ""（可以下单）
```

---

## 四、条件详细说明

### 4.1 自动交易开关

**字段：** `Robot.AutoTradeEnabled`

**值：**
- `1` = 开启自动交易
- `0` = 关闭自动交易

**作用：** 控制是否允许自动下单

---

### 4.2 信号类型

**字段：** `Signal.Action`

**有效值：**
- `OPEN_LONG` = 开多仓
- `OPEN_SHORT` = 开空仓

**其他值：**
- `CLOSE_LONG` = 平多仓（不是开仓信号）
- `CLOSE_SHORT` = 平空仓（不是开仓信号）
- `NEUTRAL` = 中性信号（不是开仓信号）

---

### 4.3 持仓状态

**检查方法：** `HasActivePosition(positionSide)`

**逻辑：**
```go
func (e *RobotEngine) HasActivePosition(positionSide string) bool {
    for _, pos := range e.CurrentPositions {
        if pos.PositionSide == positionSide && pos.PositionAmt != 0 {
            return true
        }
    }
    return false
}
```

**规则：**
- ✅ 每方向最多1单
- ✅ 如果该方向已有持仓，不允许再开仓

**同步机制：**
- ✅ 开仓前强制同步持仓（`syncAccountDataIfNeeded(ctx, "before_open")`）
- ✅ 确保持仓状态最新，避免误判

---

### 4.4 反方向下单策略

**字段：** `Robot.EnableReverseOrder`

**值：**
- `1` = 开启反向下单
- `0` = 关闭反向下单

**回撤条件：**

| 持仓状态 | 回撤计算 | 阈值字段 | 说明 |
|---------|---------|---------|------|
| **亏损订单** | `(当前亏损 - 最低亏损) / \|最低亏损\| × 100%` | `LossRetreat` | 亏损单反向回撤阈值 |
| **盈利订单** | `(最高盈利 - 当前盈利) / 最高盈利 × 100%` | `ProfitRetreat` | 盈利单反向回撤阈值 |

**示例：**
```
亏损订单：
  最低亏损：-100 USDT
  当前亏损：-50 USDT
  回撤百分比 = (-50 - (-100)) / 100 × 100% = 50%
  
  如果 LossRetreat = 50%，则允许开反方向单
  如果 LossRetreat = 60%，则不允许（回撤不足）
```

```
盈利订单：
  最高盈利：100 USDT
  当前盈利：60 USDT
  回撤百分比 = (100 - 60) / 100 × 100% = 40%
  
  如果 ProfitRetreat = 40%，则允许开反方向单
  如果 ProfitRetreat = 50%，则不允许（回撤不足）
```

---

### 4.5 算力检查

**查询表：** `hg_toogo_wallet`

**字段：**
- `power` = 用户算力
- `giftPower` = 赠送算力

**条件：**
- ✅ `power + giftPower ≥ 1`

**失败处理：**
- ❌ 返回错误："算力不足，请充值"

---

### 4.6 余额检查

**数据来源：** `RobotEngine.AccountBalance`

**字段：**
- `AvailableBalance` = 可用余额

**条件：**
- ✅ `balance != nil`
- ✅ `AvailableBalance > 0`

**失败处理：**
- ❌ 返回错误："保证金余额不足"

---

## 五、检查顺序

**检查顺序（按优先级）：**

1. **自动交易开关**（最高优先级）
   - 如果未开启，直接返回，不检查其他条件

2. **信号类型**
   - 如果不是开仓信号，直接返回

3. **持仓状态同步**
   - 开仓前强制同步，确保状态最新

4. **该方向持仓检查**
   - 如果已有持仓，直接返回

5. **反方向下单策略**
   - 如果有反方向持仓，检查反向下单条件和回撤

6. **算力检查**
   - 检查用户算力是否充足

7. **余额检查**
   - 检查账户余额是否充足

---

## 六、条件检查的调用位置

### 6.1 定时检查

**位置：** `CheckAndOpenPosition()`

```go
func (t *RobotTrader) CheckAndOpenPosition(ctx context.Context) {
    signal := t.engine.LastSignal
    if signal == nil || signal.Direction == "NEUTRAL" {
        return
    }
    
    if t.engine.Robot.AutoTradeEnabled != 1 {
        return
    }
    
    // 检查条件并尝试下单
    canTrade, _ := t.checkTradingConditions(ctx, signal)
    if canTrade {
        err := t.executeOpen(ctx, signal)
        // ...
    }
}
```

**特点：**
- ✅ 定时检查（每500ms）
- ✅ 不保存预警记录（避免重复）

---

### 6.2 信号驱动

**位置：** `TryAutoTradeAndUpdate()`

```go
func (t *RobotTrader) TryAutoTradeAndUpdate(ctx context.Context, signal *RobotSignal, logId int64) {
    // 检查条件
    canTrade, reason := t.checkTradingConditions(ctx, signal)
    if !canTrade {
        t.updateSignalLog(ctx, logId, 0, reason)
        return
    }
    
    // 执行下单
    err := t.executeOpen(ctx, signal)
    // ...
}
```

**特点：**
- ✅ 信号生成时触发
- ✅ 更新预警记录的执行状态

---

## 七、条件检查失败的处理

### 7.1 失败原因记录

**定时检查：**
- ❌ 不保存预警记录（避免重复）

**信号驱动：**
- ✅ 更新预警记录（`updateSignalLog`）
- ✅ 记录失败原因

---

### 7.2 常见失败原因

| 失败原因 | 说明 | 解决方案 |
|---------|------|---------|
| "自动下单未开启" | `AutoTradeEnabled != 1` | 开启自动交易开关 |
| "信号类型为{Action}，不是开仓信号" | 信号不是 `OPEN_LONG` 或 `OPEN_SHORT` | 等待开仓信号 |
| "该方向已有持仓" | 该方向已有持仓 | 等待平仓后再开仓 |
| "反向下单未开启" | `EnableReverseOrder != 1` | 开启反向下单开关 |
| "反向订单回撤不足..." | 回撤百分比不足 | 等待回撤达到阈值 |
| "算力不足，请充值" | `totalPower < 1` | 充值算力 |
| "保证金余额不足" | `AvailableBalance <= 0` | 充值账户余额 |

---

## 八、总结

### 8.1 检查条件列表

1. ✅ **自动交易开关**：`AutoTradeEnabled == 1`
2. ✅ **信号类型**：`Action == OPEN_LONG || Action == OPEN_SHORT`
3. ✅ **该方向持仓**：该方向没有持仓
4. ✅ **反方向下单策略**：如果开启，检查回撤条件
5. ✅ **算力**：`totalPower >= 1`
6. ✅ **余额**：`AvailableBalance > 0`

### 8.2 关键特点

- ✅ **开仓前强制同步**：确保持仓状态最新
- ✅ **每方向最多1单**：避免重复开仓
- ✅ **反向下单回撤控制**：防止频繁反向开仓
- ✅ **算力和余额验证**：确保有足够资源下单

### 8.3 检查顺序

**按优先级顺序检查：**
1. 自动交易开关（最高优先级）
2. 信号类型
3. 持仓状态同步
4. 该方向持仓检查
5. 反方向下单策略
6. 算力检查
7. 余额检查

**如果任何条件不满足，立即返回失败原因，不继续检查后续条件。**

