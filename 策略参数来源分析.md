# 策略参数来源分析

## 概述

本文档详细分析系统如何从策略模板中获取策略参数，包括查询条件、数据来源和字段映射。

---

## 一、策略模板表

### 1.1 表名
`hg_trading_strategy_template` (策略模板表)

### 1.2 关键字段
- `group_id` - 策略组ID
- `market_state` - 市场状态
- `risk_preference` - 风险偏好
- `leverage` - 杠杆
- `margin_percent` - 保证金比例
- `stop_loss_percent` - 止损百分比
- `auto_start_retreat_percent` - 启动止盈百分比
- `profit_retreat_percent` - 止盈回撤百分比
- `monitor_window` - 监控窗口（秒）
- `volatility_threshold` - 波动阈值（USDT）

---

## 二、查询条件

### 2.1 策略组ID (group_id)

**优先级顺序**：

1. **机器人绑定的策略组ID** (`robot.StrategyGroupId`)
   ```go
   if e.Robot.StrategyGroupId > 0 {
       groupId = e.Robot.StrategyGroupId
   }
   ```

2. **从 CurrentStrategy JSON 中获取**（兼容旧数据）
   ```go
   if groupId == 0 && e.Robot.CurrentStrategy != "" {
       // 支持 groupId 和 group_id 两种格式
       if gid, ok := strategyData["groupId"].(float64); ok {
           groupId = int64(gid)
       } else if gid, ok := strategyData["group_id"].(float64); ok {
           groupId = int64(gid)
       }
   }
   ```

**如果策略组ID为0**：
- 返回错误：`"机器人ID=%d 未绑定策略组ID，无法加载策略参数"`

---

### 2.2 市场状态 (market_state)

**规范化处理** (`normalizeMarketState` 函数)：

```go
func normalizeMarketState(marketState string) string {
    // 转换为小写并去除空格
    ms := strings.ToLower(strings.TrimSpace(marketState))
    
    // 映射关系
    switch ms {
    case "trend", "趋势":
        return "trend"
    case "volatile", "range", "震荡", "波动":
        return "volatile"
    case "high_vol", "high-volatility", "高波动":
        return "high_vol"
    case "low_vol", "low-volatility", "低波动":
        return "low_vol"
    default:
        return ms  // 保持原值
    }
}
```

**查询策略**（尝试多种格式，兼容旧数据）：

```go
marketStatesToTry := []string{
    normalizedMarketState,  // 标准格式（优先级最高）
}

// 如果原始格式与规范化格式不同，添加原始格式
if normalizedMarketState != marketState {
    marketStatesToTry = append(marketStatesToTry, marketState)
}

// 添加兼容格式
if normalizedMarketState == "volatile" && marketState != "volatile" {
    marketStatesToTry = append(marketStatesToTry, "range")  // 兼容旧格式
}
if normalizedMarketState == "high_vol" && marketState != "high_vol" {
    marketStatesToTry = append(marketStatesToTry, "high-volatility")
}
if normalizedMarketState == "low_vol" && marketState != "low_vol" {
    marketStatesToTry = append(marketStatesToTry, "low-volatility")
}
```

**市场状态来源**：
1. **优先**：`e.LastMarketState`（引擎缓存的最后市场状态）
2. **其次**：`e.LastAnalysis.MarketState`（最新分析结果的市场状态）
3. **默认**：`"trend"`（如果都为空）

---

### 2.3 风险偏好 (risk_preference)

**来源**：
- `robot.RiskPreference`（机器人配置的风险偏好）

**默认值**：
- 如果为空，使用 `"balanced"`（平衡型）

**常见值**：
- `conservative` - 保守型
- `balanced` - 平衡型
- `aggressive` - 激进型

---

## 三、SQL查询语句

### 3.1 查询逻辑

```sql
SELECT * FROM hg_trading_strategy_template
WHERE group_id = ?
  AND market_state = ?
  AND risk_preference = ?
```

### 3.2 实际查询代码

```go
var strategy *entity.TradingStrategyTemplate
err := dao.TradingStrategyTemplate.Ctx(ctx).
    Where("group_id", groupId).
    Where(dao.TradingStrategyTemplate.Columns().MarketState, ms).
    Where(dao.TradingStrategyTemplate.Columns().RiskPreference, riskPreference).
    Scan(&strategy)
```

**注意**：
- 移除了 `IsActive` 限制，只要策略模板存在就可以使用
- 会尝试多个市场状态格式，直到找到匹配的记录

---

## 四、字段映射

### 4.1 策略模板字段 → StrategyParams 结构

| 策略模板字段 | StrategyParams 字段 | 说明 |
|------------|-------------------|------|
| `monitor_window` | `Window` | 监控窗口（秒） |
| `volatility_threshold` | `Threshold` | 波动阈值（USDT） |
| `leverage` | `LeverageMin` | 最小杠杆（等于模板值） |
| `leverage` | `LeverageMax` | 最大杠杆（等于模板值） |
| `margin_percent` | `MarginPercentMin` | 最小保证金比例（等于模板值） |
| `margin_percent` | `MarginPercentMax` | 最大保证金比例（等于模板值） |
| `stop_loss_percent` | `StopLossPercent` | 止损百分比 |
| `auto_start_retreat_percent` | `AutoStartRetreatPercent` | 启动止盈百分比 |
| `profit_retreat_percent` | `ProfitRetreatPercent` | 止盈回撤百分比 |

### 4.2 映射代码

```go
params.Window = strategy.MonitorWindow
params.Threshold = strategy.VolatilityThreshold
params.LeverageMin = strategy.Leverage
params.LeverageMax = strategy.Leverage
params.MarginPercentMin = strategy.MarginPercent
params.MarginPercentMax = strategy.MarginPercent
params.StopLossPercent = strategy.StopLossPercent
params.ProfitRetreatPercent = strategy.ProfitRetreatPercent
params.AutoStartRetreatPercent = strategy.AutoStartRetreatPercent
```

**注意**：
- `LeverageMin` 和 `LeverageMax` 都等于模板的 `leverage` 值
- `MarginPercentMin` 和 `MarginPercentMax` 都等于模板的 `margin_percent` 值
- 在计算时使用中值：`(Min + Max) / 2`，实际上就是模板值本身

---

## 五、完整查询流程

### 5.1 流程图

```
下单信号触发
  ↓
executeOpen() 函数
  ↓
【获取策略组ID】
  ├─ 优先级1: robot.StrategyGroupId
  └─ 优先级2: robot.CurrentStrategy JSON 中的 groupId/group_id
  ↓
【获取市场状态】
  ├─ 优先级1: e.LastMarketState
  ├─ 优先级2: e.LastAnalysis.MarketState
  └─ 默认值: "trend"
  ↓
【规范化市场状态】
  normalizeMarketState(marketState)
  ↓
【获取风险偏好】
  robot.RiskPreference (默认: "balanced")
  ↓
【查询策略模板】
  SELECT * FROM hg_trading_strategy_template
  WHERE group_id = ?
    AND market_state IN (规范化值, 原始值, 兼容值...)
    AND risk_preference = ?
  ↓
【字段映射】
  策略模板字段 → StrategyParams 结构
  ↓
【返回策略参数】
  StrategyParams {
    LeverageMin/Max: strategy.Leverage
    MarginPercentMin/Max: strategy.MarginPercent
    StopLossPercent: strategy.StopLossPercent
    ...
  }
```

---

## 六、错误处理

### 6.1 找不到策略模板

**错误信息**：
```
机器人ID=%d 找不到策略模板: groupId=%d, marketState=%s/%s, riskPreference=%s。可用配置: ...
```

**处理逻辑**：
1. 查询策略组中所有可用的市场状态和风险偏好组合
2. 在错误信息中显示可用配置，帮助用户了解可用的策略模板

**查询可用配置**：
```sql
SELECT market_state, risk_preference
FROM hg_trading_strategy_template
WHERE group_id = ?
GROUP BY market_state, risk_preference
```

---

## 七、实际示例

### 7.1 示例场景

**机器人配置**：
- `robot.StrategyGroupId = 1`
- `robot.RiskPreference = "balanced"`
- `e.LastMarketState = "trend"`

**查询过程**：
1. 策略组ID：`groupId = 1`
2. 市场状态：`marketState = "trend"` → 规范化后仍为 `"trend"`
3. 风险偏好：`riskPreference = "balanced"`

**SQL查询**：
```sql
SELECT * FROM hg_trading_strategy_template
WHERE group_id = 1
  AND market_state = 'trend'
  AND risk_preference = 'balanced'
```

**查询结果示例**：
```json
{
  "id": 1,
  "group_id": 1,
  "market_state": "trend",
  "risk_preference": "balanced",
  "leverage": 10,
  "margin_percent": 10.0,
  "stop_loss_percent": 5.0,
  "auto_start_retreat_percent": 10.0,
  "profit_retreat_percent": 3.0,
  "monitor_window": 300,
  "volatility_threshold": 50.0
}
```

**映射后的 StrategyParams**：
```go
StrategyParams {
    LeverageMin: 10,
    LeverageMax: 10,
    MarginPercentMin: 10.0,
    MarginPercentMax: 10.0,
    StopLossPercent: 5.0,
    AutoStartRetreatPercent: 10.0,
    ProfitRetreatPercent: 3.0,
    Window: 300,
    Threshold: 50.0
}
```

---

## 八、关键代码位置

### 8.1 主要函数

1. **loadFullStrategyParams** (`robot_engine.go:658-773`)
   - 从策略模板加载完整参数

2. **normalizeMarketState** (`robot_engine.go:516-543`)
   - 规范化市场状态格式

3. **executeOpen** (`robot_engine.go:2829-3016`)
   - 执行开仓，调用 `loadFullStrategyParams` 获取策略参数

### 8.2 数据库表

- **策略模板表**：`hg_trading_strategy_template`
- **机器人表**：`hg_trading_robot`

---

## 九、总结

### 9.1 查询条件

1. **策略组ID** (`group_id`)
   - 来源：`robot.StrategyGroupId` 或 `robot.CurrentStrategy` JSON

2. **市场状态** (`market_state`)
   - 来源：`e.LastMarketState` 或 `e.LastAnalysis.MarketState`
   - 规范化：`normalizeMarketState()` 函数
   - 兼容：尝试多种格式查询

3. **风险偏好** (`risk_preference`)
   - 来源：`robot.RiskPreference`
   - 默认：`"balanced"`

### 9.2 字段映射

- 策略模板的 `leverage` → `LeverageMin` 和 `LeverageMax`（相同值）
- 策略模板的 `margin_percent` → `MarginPercentMin` 和 `MarginPercentMax`（相同值）
- 其他字段直接映射

### 9.3 注意事项

1. **策略组ID必须存在**：如果为0，无法加载策略参数
2. **市场状态规范化**：系统会自动规范化市场状态格式
3. **兼容性处理**：会尝试多种市场状态格式，确保能找到匹配的策略模板
4. **无 IsActive 限制**：只要策略模板存在就可以使用

