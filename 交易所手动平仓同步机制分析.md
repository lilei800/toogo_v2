# 交易所手动平仓同步机制分析

## 当前同步机制

### 1. 订单状态同步服务（OrderStatusSyncService）

**文件**：`server/internal/logic/toogo/order_status_sync.go`

**同步频率**：每30秒同步一次

**检测逻辑**（154-218行）：
```go
// 1. 获取交易所当前持仓
positions, err := ex.GetPositions(ctx, robot.Symbol)

// 2. 查询本地"持仓中"的订单
var localOrders []*entity.TradingOrder
Where("status", 1). // 持仓中

// 3. 检查本地订单是否在交易所仍有持仓
if !hasPosition {
    // 交易所已无该方向持仓，但本地显示持仓中 → 订单已被手动平仓
    s.closeOrder(ctx, order, closePrice, realizedProfit, "手动平仓(同步检测)")
}
```

**功能**：
- ✅ 检测手动平仓
- ✅ 更新订单状态为已平仓
- ✅ 更新机器人总盈亏
- ✅ 消耗算力（如果是盈利订单）

---

### 2. 机器人引擎账户数据同步

**文件**：`server/internal/logic/toogo/robot_engine.go`

**同步频率**：每10秒同步一次（在主循环中）

**同步内容**（884-963行）：
- 账户余额
- 持仓信息（包括未实现盈亏）

**注意**：
- ⚠️ 只同步到内存（`CurrentPositions`）
- ⚠️ **不会检测手动平仓**
- ⚠️ **不会更新订单状态**

---

## 当前同步延迟分析

### 场景：在交易所手动平仓订单

**时间线**：
- T0：用户在交易所手动平仓
- T0+10秒：机器人引擎同步持仓数据到内存（但不会检测订单状态）
- T0+30秒：订单状态同步服务检测到手动平仓，更新订单状态

**结论**：
- ⚠️ **最快30秒内检测到手动平仓**
- ⚠️ **平均延迟：15-30秒**

---

## 优化方案

### 方案1：在机器人引擎中增加手动平仓检测（推荐）

**优势**：
- 利用现有的10秒同步机制
- 检测更及时（最快10秒内）
- 不需要额外的API调用

**实现位置**：`robot_engine.go` 的 `syncAccountData()` 方法

**实现逻辑**：
```go
func (e *RobotEngine) syncAccountData(ctx context.Context) {
    // ... 现有代码 ...
    
    // 获取持仓
    positions, err := e.Exchange.GetPositions(ctx, e.Robot.Symbol)
    if err == nil {
        // ... 更新 CurrentPositions ...
        
        // 【新增】检测手动平仓
        e.detectManualClose(ctx, positions)
    }
}

func (e *RobotEngine) detectManualClose(ctx context.Context, exchangePositions []*exchange.Position) {
    // 构建交易所持仓映射
    exchangePosMap := make(map[string]bool)
    for _, pos := range exchangePositions {
        if math.Abs(pos.PositionAmt) > 0.0001 {
            exchangePosMap[pos.PositionSide] = true
        }
    }
    
    // 检查本地订单
    e.mu.RLock()
    localPositions := e.CurrentPositions
    e.mu.RUnlock()
    
    for _, localPos := range localPositions {
        if math.Abs(localPos.PositionAmt) > 0.0001 {
            // 本地有持仓
            if !exchangePosMap[localPos.PositionSide] {
                // 交易所已无持仓 → 手动平仓
                g.Log().Infof(ctx, "[RobotEngine] 检测到手动平仓: robotId=%d, side=%s",
                    e.Robot.Id, localPos.PositionSide)
                
                // 触发订单状态同步服务同步该机器人
                go func() {
                    GetOrderStatusSyncService().SyncSingleRobot(ctx, e.Robot.Id)
                }()
                
                // 清除内存中的持仓状态
                e.mu.Lock()
                for i, p := range e.CurrentPositions {
                    if p.PositionSide == localPos.PositionSide {
                        e.CurrentPositions[i].PositionAmt = 0
                    }
                }
                delete(e.PositionTrackers, localPos.PositionSide)
                e.mu.Unlock()
            }
        }
    }
}
```

---

### 方案2：提高订单状态同步频率

**当前**：30秒

**优化**：改为10秒或15秒

**优势**：
- 实现简单
- 检测更及时

**劣势**：
- 增加API调用频率
- 可能触发交易所限流

**建议**：如果API调用频率允许，可以改为15秒

---

### 方案3：在平仓检查时检测手动平仓

**实现位置**：`robot_engine.go` 的 `CheckAndClosePosition()` 方法

**逻辑**：
- 在检查平仓条件前，先检查交易所持仓
- 如果交易所已无持仓，但本地有持仓，则认为是手动平仓

**优势**：
- 利用现有的500ms检查频率
- 检测非常及时（最快500ms内）

**劣势**：
- 每次检查都要调用API（可能频繁）
- 需要优化API调用频率

---

## 推荐方案

### 推荐：方案1 + 方案2（组合）

**方案1**：在机器人引擎中增加手动平仓检测
- 利用10秒同步机制
- 检测到后触发订单状态同步服务

**方案2**：提高订单状态同步频率
- 从30秒改为15秒
- 作为兜底机制

**效果**：
- 最快10秒内检测到手动平仓（方案1）
- 最慢15秒内检测到手动平仓（方案2兜底）
- 平均延迟：5-10秒

---

## 当前状态总结

| 同步机制 | 频率 | 检测手动平仓 | 更新订单状态 | 延迟 |
|---------|------|------------|------------|------|
| 订单状态同步服务 | 30秒 | ✅ | ✅ | 最快30秒 |
| 机器人引擎同步 | 10秒 | ❌ | ❌ | - |

**结论**：
- ✅ 已有同步机制，可以检测到手动平仓
- ⚠️ 当前延迟：最快30秒，平均15-30秒
- 💡 建议优化：在机器人引擎中增加检测，将延迟降低到10秒内

