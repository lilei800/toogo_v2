# 预警与下单职责分离说明

## 一、架构调整

### 1.1 职责分离

**预警模块（EvaluateWindowSignal）**：
- ✅ 只负责检测信号和保存预警记录
- ✅ 不负责下单逻辑
- ✅ 职责单一，更清晰

**下单模块（TryAutoTradeAndUpdate）**：
- ✅ 由其他模块调用（如定时任务）
- ✅ 根据预警记录执行下单
- ✅ 独立的下单逻辑

---

## 二、修改内容

### 2.1 EvaluateWindowSignal修改

**修改前**：
```go
if isNewDirection {
    // 检查是否满足下单条件
    if canTryTrade {
        // 异步保存预警记录
        go func() {
            logId := e.saveSignalAlertSimple(&signalCopy)
        }()
        // 立即执行下单
        e.Trader.TryAutoTradeAndUpdate(logCtx, &signalCopy, 0)
    } else {
        // 保存预警记录
        logId := e.saveSignalAlertSimple(&signalCopy)
        // 记录交易日志
        e.Trader.saveExecutionLog(...)
    }
}
```

**修改后**：
```go
if isNewDirection {
    // 【架构优化】预警只负责保存预警信息，不负责下单
    logId := e.saveSignalAlertSimple(&signalCopy)
    if logId > 0 {
        g.Log().Infof(...)
    }
}
```

---

## 三、下单触发方式

### 3.1 当前下单触发方式

**方式1：定时任务触发**（如果存在）
- 定时检查预警记录
- 根据预警记录执行下单

**方式2：其他触发机制**（如果存在）
- 事件驱动
- 手动触发
- 其他业务逻辑

### 3.2 建议的下单触发方式

**推荐：定时任务触发**
- 定时扫描预警记录（如每1秒）
- 检查是否有未处理的预警记录
- 根据预警记录执行下单

**实现示例**：
```go
// 定时任务：扫描预警记录并下单
func (e *RobotEngine) checkAndExecuteOrders(ctx context.Context) {
    // 1. 查询未处理的预警记录
    // 2. 检查下单条件
    // 3. 执行下单
    // 4. 更新预警记录状态
}
```

---

## 四、优势

### 4.1 职责清晰

✅ **预警模块**：
- 只负责信号检测和预警记录
- 不关心下单逻辑
- 代码更简洁

✅ **下单模块**：
- 独立的下单逻辑
- 可以由多种方式触发
- 更灵活

### 4.2 解耦合

✅ **模块解耦**：
- 预警和下单分离
- 互不影响
- 更容易维护

### 4.3 灵活性

✅ **触发方式灵活**：
- 可以由定时任务触发
- 可以由事件触发
- 可以由手动触发
- 更灵活

---

## 五、注意事项

### 5.1 预警记录状态

**建议添加状态字段**：
- `pending` - 待处理
- `processing` - 处理中
- `completed` - 已完成
- `failed` - 失败

### 5.2 下单条件检查

**下单前需要检查**：
- 自动下单是否开启
- 账户余额是否充足
- 是否已有持仓
- 其他业务条件

### 5.3 预警记录去重

**避免重复下单**：
- 检查预警记录是否已处理
- 使用唯一标识（如logId）
- 防止重复下单

---

## 六、总结

✅ **预警模块职责**：
- 检测信号
- 保存预警记录
- 不负责下单

✅ **下单模块职责**：
- 由其他模块触发
- 根据预警记录执行下单
- 独立的下单逻辑

**架构更清晰，职责更明确，更易维护！**

