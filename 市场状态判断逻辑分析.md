# hotgo_v2 项目市场状态判断逻辑分析

## 一、架构概述

### 1.1 核心组件

市场状态判断采用**全局市场分析器 (MarketAnalyzer)** 架构，位于 `server/internal/library/market/market_analyzer.go`。

**关键特点：**
- **单例模式**：所有机器人共享同一个市场分析器实例
- **按币种独立**：每个 `platform:symbol` 组合有独立的市场状态信号
- **实时更新**：每1秒分析一次所有市场
- **并发优化**：使用 `sync.Map` 存储分析结果，支持高并发读取

### 1.2 市场状态类型

系统定义了4种市场状态：

```go
const (
    MarketStateTrend    MarketState = "trend"    // 趋势市场
    MarketStateVolatile MarketState = "range"    // 震荡市场（数据库存储为"range"，代码中统一为"volatile"）
    MarketStateHighVol  MarketState = "high_vol" // 高波动
    MarketStateLowVol   MarketState = "low_vol"   // 低波动
)
```

## 二、市场状态判断流程

### 2.1 整体流程

```
启动分析循环 (1秒/次)
    ↓
分析所有市场 (并发，最多10个并发)
    ↓
对每个币种 (platform:symbol):
    ├─ 获取多周期K线数据 (1m/5m/1h/1d)
    ├─ 分析每个周期 (analyzeTimeframe)
    ├─ 计算基准波动率 (calculateMultiTimeframeBaselineVolatility)
    ├─ 识别市场状态模式 (calculateMarketStateVolatilities)
    ├─ 计算动态阈值 (calculateDynamicThresholdsFromMarketStates)
    └─ 判定市场状态 (determineMarketState)
```

### 2.2 多周期分析配置

**周期权重配置：**
```go
timeframes := []struct {
    interval  string
    weight    float64
    minKlines int
    maxKlines int
}{
    {"1m", 0.40, 5, 10},   // 1分钟：权重40%，使用最近5-10根K线
    {"5m", 0.35, 10, 15},  // 5分钟：权重35%，使用最近10-15根K线
    {"1h", 0.20, 15, 25},  // 1小时：权重20%，使用最近15-25根K线
    {"1d", 0.05, 5, 10},   // 1天：权重5%，使用最近5-10根K线
}
```

**设计理念：**
- **超短线优化**：大幅减少K线条数，聚焦最近数据，更实时反应市场状态
- **短期权重高**：1m和5m周期权重合计75%，适合超短线交易
- **实时性优先**：只使用最近N根K线，而不是全部历史数据

### 2.3 单周期分析 (analyzeTimeframe)

**核心指标计算：**

1. **价格波动率 (PriceVolatility)**
   ```go
   PriceVolatility = (最高价 - 最低价) / 当前价 * 100
   ```
   - 单位：百分比
   - 反映周期内的价格波动幅度

2. **价格变化率 (PriceChangeRate)**
   ```go
   PriceChangeRate = (当前价 - 起始价) / 起始价 * 100
   ```
   - 单位：百分比
   - 反映价格趋势方向和强度

3. **价格加速度 (PriceAcceleration)**
   ```go
   PriceAcceleration = 当前变化率 - 前一个窗口变化率
   ```
   - 捕捉趋势变化速度
   - 用于判断趋势是否在加速或减速

**趋势判断逻辑：**

```go
// 自适应趋势阈值
baseThreshold := 0.05%  // 基础阈值：0.05%（极敏感）
volatilityMultiplier := 1.0 + PriceVolatility/10.0  // 根据波动率调整
trendThreshold := baseThreshold * volatilityMultiplier  // 限制范围：0.03% - 0.3%

// 结合价格加速度修正趋势强度
if PriceChangeRate > trendThreshold:
    趋势 = "up"（上涨）
    强度 = PriceChangeRate/2.0 + 加速度修正
else if PriceChangeRate < -trendThreshold:
    趋势 = "down"（下跌）
    强度 = |PriceChangeRate|/2.0 + 加速度修正
else:
    趋势 = "sideways"（震荡）
```

**关键优化：**
- **不使用技术指标**：EMA/MACD有滞后性，直接使用价格数据更实时
- **自适应阈值**：根据波动率动态调整，波动率大时提高阈值（避免噪音），波动率小时降低阈值（更敏感）
- **加速度修正**：结合价格加速度判断趋势是否在加速，提高判断准确性

## 三、市场状态判定核心逻辑

### 3.1 基准波动率计算

**多周期基准波动率：**
```go
// 使用1m, 5m, 1h, 1d四个周期的基准波动率，按权重加权平均
baselineVolatility = Σ(各周期基准波动率 × 权重) / Σ权重
```

**单周期基准波动率计算：**
- 将K线分成多个窗口（每个窗口10-20根K线）
- 计算每个窗口的价格波动率
- 取所有窗口的平均值作为基准波动率

**默认值：**
- 如果计算失败，使用默认值 0.8%（基于BTCUSDT正常市场）

### 3.2 市场状态模式识别

**识别6种市场状态模式：**

1. **趋势向上 (TrendUp)**
   - 条件：价格变化率 > 0.2%，价格一致性 > 0.6
   - 波动率特征：基准 × 1.2

2. **趋势向下 (TrendDown)**
   - 条件：价格变化率 < -0.2%，价格一致性 > 0.6
   - 波动率特征：基准 × 1.2

3. **上下插针 (Spike)**
   - 条件：上下影线比例 > 价格波动率 × 0.6
   - 波动率特征：基准 × 3.0

4. **高波动 (HighVol)**
   - 条件：波动率 > 1.5%，且变化率不明显 (< 0.5%)
   - 波动率特征：基准 × 2.0

5. **低波动 (LowVol)**
   - 条件：波动率 < 0.3%
   - 波动率特征：基准 × 0.3

6. **震荡 (Volatile)**
   - 条件：波动率 0.3% - 1.5%，变化率 < 0.3%，一致性 < 0.6
   - 波动率特征：基准 × 0.8

### 3.3 动态阈值计算

**基于市场状态模式的动态阈值：**

```go
// 高波动阈值：取高波动、插针、趋势状态的波动率最大值 × 0.8
highThreshold = max(HighVolVolatility, SpikeVolatility, TrendUpVolatility, TrendDownVolatility) × 0.8

// 低波动阈值：取低波动、震荡状态的波动率最小值 × 1.2
lowThreshold = min(LowVolVolatility, VolatileVolatility) × 1.2

// 限制范围：
// 高波动阈值：基准 × 1.2 ~ 基准 × 3.0，最终限制 0.6% ~ 10%
// 低波动阈值：基准 × 0.2 ~ 基准 × 0.8，最终限制 0.1% ~ 2%
```

**降级策略：**
- 如果无法识别市场状态模式，降级使用基准波动率：
  - 高波动阈值 = 基准 × 1.5
  - 低波动阈值 = 基准 × 0.5

### 3.4 市场状态判定 (determineMarketState)

**判定流程：**

```
步骤1：优先判断波动率（使用动态阈值）
    ├─ if Volatility > highThreshold:
    │   └─ MarketState = "high_vol", Confidence = 0.8
    │
    ├─ else if Volatility < lowThreshold:
    │   └─ MarketState = "low_vol", Confidence = 0.7
    │
    └─ else: 进入步骤2

步骤2：判断趋势 vs 震荡（使用价格变化率）
    ├─ 计算多周期价格变化率的加权平均
    ├─ 自适应趋势阈值（根据基准波动率调整）
    │   baseTrendThreshold = 0.1%
    │   trendThreshold = baseTrendThreshold × (1.0 + baselineVolatility/5.0)
    │   限制范围：0.05% - 0.4%
    │
    ├─ if avgPriceChangeRate > trendThreshold:
    │   └─ MarketState = "trend", Confidence = min(0.9, avgPriceChangeRate/1.0)
    │
    └─ else:
        └─ MarketState = "volatile", Confidence = 0.6

步骤3：根据市场状态调整阈值（用于下一次判定）
    ├─ 趋势市场：高阈值提高10%，低阈值降低10%
    ├─ 震荡市场：高阈值降低10%，低阈值提高10%
    ├─ 高波动市场：高阈值提高20%，低阈值降低20%
    └─ 低波动市场：高阈值降低20%，低阈值提高20%
```

**平滑过渡机制：**
- 如果存在上一次的分析结果，使用加权平均平滑阈值：
  ```go
  newThreshold = newThreshold × 0.7 + previousThreshold × 0.3
  ```
- 避免阈值突变，提高状态切换的稳定性

## 四、关键优化点

### 4.1 实时性优化

1. **移除技术指标**：不使用EMA/MACD，直接使用价格数据
2. **减少K线条数**：只使用最近N根K线，而不是全部历史
3. **高频更新**：每1秒分析一次，满足超短线需求

### 4.2 灵敏度优化

1. **自适应阈值**：根据波动率动态调整趋势阈值
2. **价格加速度**：结合价格加速度判断趋势变化速度
3. **多周期加权**：短期周期权重高，更敏感

### 4.3 稳定性优化

1. **平滑过渡**：使用上一次分析结果平滑阈值，避免突变
2. **状态调整阈值**：根据当前市场状态调整阈值，更符合市场特性
3. **降级策略**：如果模式识别失败，降级使用基准波动率

### 4.4 性能优化

1. **sync.Map**：使用sync.Map替代map+mutex，提高并发性能
2. **并发分析**：使用goroutine并发分析，限制并发数为10
3. **缓存机制**：分析结果缓存，避免重复计算

## 五、使用方式

### 5.1 获取市场状态

```go
// 获取全局市场分析器
analyzer := market.GetMarketAnalyzer()

// 获取指定币种的市场状态
analysis := analyzer.GetAnalysis(platform, symbol)
if analysis != nil {
    marketState := analysis.MarketState        // 市场状态
    confidence := analysis.MarketStateConf     // 置信度 (0-1)
    volatility := analysis.Volatility          // 波动率 (%)
    trendStrength := analysis.TrendStrength    // 趋势强度 (-1到1)
}
```

### 5.2 机器人引擎中的使用

```go
// 在 RobotEngine 中获取市场状态
globalAnalysis := market.GetMarketAnalyzer().GetAnalysis(e.Platform, e.Robot.Symbol)
if globalAnalysis != nil {
    marketState := string(globalAnalysis.MarketState)
    // 规范化市场状态格式（range → volatile）
    if marketState == "range" {
        marketState = "volatile"
    }
    // 根据市场状态加载对应的策略参数
    // ...
}
```

## 六、数据流图

```
MarketServiceManager (行情服务)
    ↓ (提供K线数据)
MarketAnalyzer (市场分析器)
    ├─ analyzeAllMarkets() [每1秒执行]
    │   └─ analyzeMarket() [并发执行]
    │       ├─ analyzeTimeframe() [多周期分析]
    │       ├─ calculateMultiTimeframeBaselineVolatility()
    │       ├─ calculateMarketStateVolatilities()
    │       └─ determineMarketState() [核心判定逻辑]
    │
    └─ GetAnalysis() [机器人调用]
        └─ 返回 MarketAnalysis
            ├─ MarketState (trend/volatile/high_vol/low_vol)
            ├─ MarketStateConf (置信度)
            ├─ Volatility (波动率)
            └─ TrendStrength (趋势强度)
```

## 七、关键参数总结

### 7.1 周期权重
- 1分钟：40%
- 5分钟：35%
- 1小时：20%
- 1天：5%

### 7.2 阈值参数
- **基础趋势阈值**：0.05% - 0.3%（自适应）
- **趋势阈值（多周期）**：0.05% - 0.4%（自适应）
- **高波动阈值**：0.6% - 10%（动态）
- **低波动阈值**：0.1% - 2%（动态）
- **默认基准波动率**：0.8%

### 7.3 模式识别阈值
- **趋势识别**：价格变化率 > 0.2%，一致性 > 0.6
- **插针识别**：上下影线比例 > 价格波动率 × 0.6
- **高波动识别**：波动率 > 1.5%，变化率 < 0.5%
- **低波动识别**：波动率 < 0.3%
- **震荡识别**：波动率 0.3% - 1.5%，变化率 < 0.3%，一致性 < 0.6

## 八、注意事项

1. **市场状态格式统一**：数据库存储为"range"，代码中统一为"volatile"，需要规范化处理
2. **数据过期检查**：MarketServiceManager会检查市场状态数据是否过期（3秒），过期则返回空
3. **平滑过渡**：使用上一次分析结果平滑阈值，避免状态频繁切换
4. **降级策略**：如果模式识别失败，会降级使用基准波动率计算阈值

## 九、相关文件

- **核心实现**：`server/internal/library/market/market_analyzer.go`
- **模式识别**：`server/internal/library/market/market_state_pattern.go`
- **使用示例**：`server/internal/logic/toogo/robot_engine.go`
- **服务管理**：`server/internal/library/market/market_service_manager.go`

