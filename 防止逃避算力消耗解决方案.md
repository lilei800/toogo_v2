# 防止手动平仓和平台平仓逃避算力消耗的解决方案

## 问题分析

### 当前漏洞
1. **只在机器人自动平仓时消耗算力** - 代码位置：`server/internal/logic/toogo/engine.go:1571`
2. **用户可以绕过系统**：
   - 在交易平台直接手动平仓盈利订单
   - 使用其他工具或API平仓
   - 关闭机器人后在平台操作
3. **无法追踪平台外操作** - 系统只记录机器人执行的操作

## 解决方案

### 方案一：订单状态同步 + 补偿机制（推荐）⭐

#### 核心思路
通过定时同步交易所订单状态，检测所有已平仓的盈利订单，自动补扣算力。

#### 实现步骤

##### 1. 在订单表添加算力消耗标记

```sql
-- 修改 trading_order 表，添加算力消耗标记
ALTER TABLE `hg_trading_order` 
ADD COLUMN `power_consumed` tinyint(1) NOT NULL DEFAULT 0 COMMENT '是否已消耗算力：0=未消耗，1=已消耗' AFTER `close_reason`,
ADD COLUMN `power_amount` decimal(20,8) NOT NULL DEFAULT 0.00000000 COMMENT '消耗的算力数量' AFTER `power_consumed`,
ADD INDEX idx_power_consumed (power_consumed, status);
```

##### 2. 创建订单同步任务

```go
// server/internal/logic/toogo/order_sync.go
package toogo

import (
    "context"
    "time"
    
    "github.com/gogf/gf/v2/frame/g"
    "github.com/gogf/gf/v2/os/gtime"
    "hotgo/internal/dao"
    "hotgo/internal/model/entity"
)

// SyncClosedOrders 同步已平仓订单并补扣算力
func (s *sToogoRobot) SyncClosedOrders(ctx context.Context) error {
    g.Log().Info(ctx, "[OrderSync] 开始同步已平仓订单...")
    
    // 1. 查询所有状态为"已平仓"且未消耗算力的盈利订单
    var orders []*entity.TradingOrder
    err := dao.TradingOrder.Ctx(ctx).
        Where("status", 2).                     // 已平仓
        Where("power_consumed", 0).             // 未消耗算力
        Where("realized_profit > 0").           // 盈利订单
        Where("close_time >= ?", gtime.Now().Add(-7*24*time.Hour)). // 最近7天
        Scan(&orders)
    
    if err != nil {
        return err
    }
    
    if len(orders) == 0 {
        g.Log().Info(ctx, "[OrderSync] 没有需要补扣算力的订单")
        return nil
    }
    
    g.Log().Infof(ctx, "[OrderSync] 发现 %d 个未消耗算力的盈利订单，开始补扣...", len(orders))
    
    // 2. 逐个订单补扣算力
    successCount := 0
    failCount := 0
    
    for _, order := range orders {
        err := s.consumeOrderPower(ctx, order)
        if err != nil {
            g.Log().Errorf(ctx, "[OrderSync] 订单 %s 补扣算力失败: %v", order.OrderSn, err)
            failCount++
            continue
        }
        successCount++
    }
    
    g.Log().Infof(ctx, "[OrderSync] 同步完成，成功: %d，失败: %d", successCount, failCount)
    return nil
}

// consumeOrderPower 为订单消耗算力
func (s *sToogoRobot) consumeOrderPower(ctx context.Context, order *entity.TradingOrder) error {
    // 获取机器人信息
    var robot *entity.TradingRobot
    err := dao.TradingRobot.Ctx(ctx).Where("id", order.RobotId).Scan(&robot)
    if err != nil || robot == nil {
        return gerror.New("机器人不存在")
    }
    
    // 调用钱包服务消耗算力
    err = ToogoWallet().ConsumePower(ctx, 
        order.UserId, 
        order.RobotId, 
        order.Id, 
        order.OrderSn, 
        order.RealizedProfit,
    )
    
    if err != nil {
        // 如果算力不足，记录到日志，但不阻止
        g.Log().Warningf(ctx, "[OrderSync] 用户 %d 算力不足，订单 %s 无法扣除算力", 
            order.UserId, order.OrderSn)
        // 可以考虑：标记为欠费状态、禁用用户等
        return err
    }
    
    // 更新订单状态
    _, err = dao.TradingOrder.Ctx(ctx).
        Where("id", order.Id).
        Data(g.Map{
            "power_consumed": 1,
            "power_amount": order.RealizedProfit * 0.1, // 根据实际消耗比例计算
            "updated_at": gtime.Now(),
        }).
        Update()
    
    g.Log().Infof(ctx, "[OrderSync] 订单 %s 补扣算力成功，金额: %.4f", 
        order.OrderSn, order.RealizedProfit * 0.1)
    
    return err
}
```

##### 3. 修改自动平仓逻辑，标记已消耗

```go
// server/internal/logic/toogo/engine.go
// 在 closePosition 方法中，消耗算力后立即标记订单

func (e *TradingEngine) closePosition(ctx context.Context, runner *RobotRunner, pos *exchange.Position, reason string) error {
    // ... 现有平仓逻辑 ...
    
    // 结算算力消耗（只有盈利才扣除算力）
    if pos.UnrealizedPnl > 0 {
        consumedPower := e.settlePowerConsume(ctx, runner, pos.UnrealizedPnl)
        
        // 【新增】标记订单已消耗算力
        _, _ = dao.TradingOrder.Ctx(ctx).
            Where("robot_id", runner.Robot.Id).
            Where("exchange_order_id", order.OrderId).
            Data(g.Map{
                "power_consumed": 1,
                "power_amount": consumedPower,
            }).
            Update()
    }
    
    // ... 其余逻辑 ...
}

// 修改 settlePowerConsume 返回消耗的算力数量
func (e *TradingEngine) settlePowerConsume(ctx context.Context, runner *RobotRunner, profit float64) float64 {
    // ... 现有逻辑 ...
    
    consume = consume * discount
    
    // ... 扣除算力 ...
    
    return consume  // 返回实际消耗的算力
}
```

##### 4. 注册定时任务

```go
// server/internal/logic/toogo/cron.go
package toogo

import (
    "context"
    "github.com/gogf/gf/v2/frame/g"
    "github.com/gogf/gf/v2/os/gcron"
)

// RegisterOrderSyncCron 注册订单同步定时任务
func RegisterOrderSyncCron(ctx context.Context) {
    // 每10分钟执行一次订单同步
    _, err := gcron.AddSingleton(ctx, "*/10 * * * *", func(ctx context.Context) {
        err := ToogoRobot().SyncClosedOrders(ctx)
        if err != nil {
            g.Log().Errorf(ctx, "[OrderSync] 订单同步任务执行失败: %v", err)
        }
    }, "OrderSyncTask")
    
    if err != nil {
        g.Log().Errorf(ctx, "[OrderSync] 注册定时任务失败: %v", err)
    } else {
        g.Log().Info(ctx, "[OrderSync] 订单同步定时任务已注册（每10分钟执行）")
    }
}
```

##### 5. 在系统启动时注册任务

```go
// server/internal/cmd/http.go
// 在 HTTP 服务启动时注册

func Http(ctx context.Context) {
    // ... 现有代码 ...
    
    // 注册订单同步定时任务
    toogo.RegisterOrderSyncCron(ctx)
    
    // ... 其余代码 ...
}
```

---

### 方案二：WebSocket 实时监听（高级方案）

#### 核心思路
通过交易所 WebSocket 实时监听账户订单和持仓变化，立即检测并处理。

#### 实现要点

```go
// 在 exchange 接口中添加订单流监听
type OrderStream interface {
    // SubscribeOrders 订阅订单更新
    SubscribeOrders(ctx context.Context, callback func(*Order)) error
    
    // SubscribePositions 订阅持仓更新  
    SubscribePositions(ctx context.Context, callback func(*Position)) error
}

// 在引擎中处理订单更新
func (e *TradingEngine) handleOrderUpdate(ctx context.Context, order *exchange.Order) {
    // 检查是否是机器人管理的订单
    var dbOrder *entity.TradingOrder
    err := dao.TradingOrder.Ctx(ctx).
        Where("exchange_order_id", order.OrderId).
        Scan(&dbOrder)
    
    if err != nil || dbOrder == nil {
        return // 不是系统订单
    }
    
    // 如果订单已平仓且盈利，检查是否已消耗算力
    if order.Status == "FILLED" && order.RealizedPnl > 0 {
        if dbOrder.PowerConsumed == 0 {
            // 立即补扣算力
            _ = ToogoWallet().ConsumePower(ctx, 
                dbOrder.UserId, 
                dbOrder.RobotId,
                dbOrder.Id,
                dbOrder.OrderSn,
                order.RealizedPnl,
            )
        }
    }
}
```

---

### 方案三：风控限制（辅助方案）

#### 措施列表

1. **算力预扣机制**
   - 开仓时预扣预估算力
   - 平仓时多退少补

2. **欠费处理**
   - 检测到逃避消耗时记录欠费
   - 欠费用户禁止创建新机器人
   - 必须补缴欠费才能继续使用

3. **异常检测**
   - 统计用户的手动平仓比例
   - 高比例用户触发风控审核
   - 严重违规者封禁账号

4. **机器人权限管理**
   - 禁止机器人运行期间手动干预
   - 交易所 API Key 只授予机器人使用
   - 检测到手动操作立即停止机器人

---

## 推荐实施方案

### 第一阶段（立即实施）
✅ **方案一：订单同步 + 补偿机制**
- 数据库添加 `power_consumed` 和 `power_amount` 字段
- 实现订单同步逻辑
- 注册定时任务（每10分钟）
- 修改平仓时标记已消耗

### 第二阶段（后续优化）
✅ **方案三：风控限制**
- 实现欠费处理机制
- 添加异常检测
- 完善权限管理

### 第三阶段（长期规划）
✅ **方案二：WebSocket 监听**
- 实现交易所订单流监听
- 实时处理订单变化
- 提高响应速度

---

## 代码修改清单

### 1. 数据库迁移
```bash
执行文件：server/storage/data/add_power_consumed_field.sql
```

### 2. 新增文件
- `server/internal/logic/toogo/order_sync.go` - 订单同步逻辑
- `server/internal/logic/toogo/cron.go` - 定时任务注册

### 3. 修改文件
- `server/internal/logic/toogo/engine.go` - 标记已消耗算力
- `server/internal/cmd/http.go` - 注册定时任务
- `server/internal/model/entity/trading_order.go` - 添加字段（自动生成）

---

## 测试验证

### 测试场景

1. **正常流程**
   - 机器人自动平仓 → 算力正常扣除 → 订单标记已消耗

2. **手动平仓**
   - 在平台手动平仓盈利订单 → 定时任务检测 → 补扣算力

3. **算力不足**
   - 手动平仓后算力不足 → 记录欠费 → 禁止新建机器人

4. **历史订单**
   - 补扣最近7天内的漏扣订单

---

## 监控指标

### 关键指标
- 每日补扣订单数量
- 补扣算力总额
- 欠费用户数量
- 手动平仓占比

### 告警规则
- 单用户日补扣超过10单 → 异常告警
- 欠费金额超过100 USDT → 风控审核
- 补扣失败率 > 5% → 系统告警

---

## 注意事项

⚠️ **重要提醒**

1. **向后兼容** - 历史订单默认 `power_consumed=0`，会被补扣
2. **性能考虑** - 定时任务限制查询最近7天数据
3. **幂等性** - 通过 `power_consumed` 标记防止重复扣费
4. **容错处理** - 算力不足不阻止订单记录，仅记录日志
5. **数据一致性** - 使用事务确保扣费和标记原子性

---

## 预期效果

✅ **彻底堵住漏洞**
- 所有盈利订单都会被检测并消耗算力
- 手动平仓、平台平仓均会被捕获

✅ **用户体验**
- 正常用户无感知
- 违规用户被限制

✅ **系统收益**
- 防止算力收入流失
- 维护平台公平性
